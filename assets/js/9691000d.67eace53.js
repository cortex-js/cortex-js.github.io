"use strict";(self.webpackChunkcortexjs_io=self.webpackChunkcortexjs_io||[]).push([[2296],{1249:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"compute-engine/guide-evaluate","title":"Evaluation of Expressions","description":"Evaluating an expression is the process of determining the value of the","source":"@site/docs/compute-engine/10-guide-evaluate.md","sourceDirName":"compute-engine","slug":"/compute-engine/guides/evaluate/","permalink":"/compute-engine/guides/evaluate/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1746803465000,"sidebarPosition":10,"frontMatter":{"title":"Evaluation of Expressions","slug":"/compute-engine/guides/evaluate/","preamble":null},"sidebar":"docSidebar","previous":{"title":"Expressions","permalink":"/compute-engine/guides/expressions/"},"next":{"title":"Symbolic Computing","permalink":"/compute-engine/guides/symbolic-computing/"}}');var i=t(4848),o=t(8453);const a={title:"Evaluation of Expressions",slug:"/compute-engine/guides/evaluate/",preamble:null},c="Evaluation",r={},l=[{value:"Evaluation Methods",id:"evaluation-methods",level:2},{value:"Compilation",id:"compilation",level:3},{value:"Asynchronous Evaluation",id:"asynchronous-evaluation",level:2},{value:"Lexical Scopes and Evaluation Contexts",id:"lexical-scopes-and-evaluation-contexts",level:2},{value:"Binding",id:"binding",level:3},{value:"Default Scopes",id:"default-scopes",level:3},{value:"Creating New Scopes",id:"creating-new-scopes",level:3},{value:"Evaluation Loop",id:"evaluation-loop",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code","code-playground":"code-playground",div:"div",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components},t=n["code-playground"],{Icon:s,Intro:a,ReadMore:c}=n;return s||u("Icon",!0),a||u("Intro",!0),c||u("ReadMore",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"evaluation",children:"Evaluation"})}),"\n",(0,i.jsx)(a,{children:(0,i.jsx)(n.p,{children:"Evaluating an expression is the process of determining the value of the\nexpression. This involves looking up the definitions of symbols and functions,\nevaluating the arguments of functions, and applying the function to the\narguments."})}),"\n",(0,i.jsx)(n.h2,{id:"evaluation-methods",children:"Evaluation Methods"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To evaluate an expression"}),", use the ",(0,i.jsx)(n.code,{children:"expr.evaluate()"})," method."]}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:["const expr = ce.parse('2 + 2');\n","expr.evaluate().print();\n"]})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"expr.value"})," property does not evaluate the expression. If the expression\nis a literal, it returns the literal value. If the expression is a symbol, it\nlooks up the symbol in the current scope and returns its value."]}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:["ce.box('x').value = 314;\n","console.info(ce.parse('42').value)\n","console.info(ce.parse('x').value)\n","console.info(ce.parse('2 + 2').value)\n"]})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"expr.N()"})," method is a shorthand for ",(0,i.jsx)(n.code,{children:"expr.evaluate({numericApproximation: true})"}),"."]}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:["const expr = ce.parse('2\\\\pi');\n","expr.evaluate().print();\n","expr.N().print();\n"]})}),"\n",(0,i.jsx)(n.h3,{id:"compilation",children:"Compilation"}),"\n",(0,i.jsxs)(n.p,{children:["An expression can be evaluated by compiling it to JavaScript using the ",(0,i.jsx)(n.code,{children:"expr.compile()"})," method.\nThe method returns a JavaScript function that can be called to evaluate the expression."]}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:["const f = ce.parse('2\\\\pi').compile();\n","console.log(f());\n"]})}),"\n",(0,i.jsx)(c,{path:"/compute-engine/guides/compiling/",children:(0,i.jsxs)(n.p,{children:["Read more about ",(0,i.jsx)(n.strong,{children:"compiling expressions"})," ",(0,i.jsx)(s,{name:"chevron-right-bold"})]})}),"\n",(0,i.jsx)(n.h2,{id:"asynchronous-evaluation",children:"Asynchronous Evaluation"}),"\n",(0,i.jsx)(n.p,{children:"Some computations can be time-consuming. For example, computing a very large\nfactorial. To prevent the browser from freezing, the Compute Engine can\nperform some operations asynchronously."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To perform an asynchronous evaluation"}),", use the ",(0,i.jsx)(n.code,{children:"expr.evaluateAsync()"})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"try {\n  const fact = ce.parse('(70!)!');\n  const factResult = await fact.evaluateAsync();\n  factResult.print();\n} catch (e) {\n  console.error(e);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"expr.evaluateAsync()"})," method returns a ",(0,i.jsx)(n.code,{children:"Promise"})," that resolves to the result\nof the evaluation. It accepts the same ",(0,i.jsx)(n.code,{children:"numericApproximation"})," options as ",(0,i.jsx)(n.code,{children:"expr.evaluate()"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"It is also possible to interrupt an evaluation, for example by providing the user\nwith a pause/cancel button."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To make an evaluation interruptible"}),", use an ",(0,i.jsx)(n.code,{children:"AbortController"}),"\nobject and a ",(0,i.jsx)(n.code,{children:"signal"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"For example, to interrupt an evaluation after 500ms:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const abort = new AbortController();\nconst signal = abort.signal;\nsetTimeout(() => abort.abort(), 500);\ntry {\n  const fact = ce.parse('(70!)!');\n  const factResult = await fact.evaluateAsync({ signal });\n  factResult.print();\n} catch (e) {\n  console.error(e);\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"\n:::html\n<div class=\"stack\">\n  <div class=\"row\">\n    <button id=\"evaluate-button\">Evaluate</button>\n    <button id=\"cancel-button\" disabled>Cancel</button>\n  </div>\n\n  <div id=\"output\"></div>\n</div>\n:::js\nconst abort = new AbortController();\n\ndocument.getElementById('cancel-button').addEventListener('click', \n  () => abort.abort()\n);\n\ndocument.getElementById('evaluate-button').addEventListener('click', async () => {\n  try {\n    document.getElementById('evaluate-button').disabled = true;\n    document.getElementById('cancel-button').disabled = false;\n\n    const fact = ce.parse('(70!)!');\n    const factResult = await fact.evaluateAsync({ signal: abort.signal });\n    document.getElementById('output').textContent = factResult.toString();\n    \n    document.getElementById('evaluate-button').disabled = false;\n    document.getElementById('cancel-button').disabled = true;\n  } catch (e) {\n    document.getElementById('evaluate-button').disabled = false;\n    document.getElementById('cancel-button').disabled = true;\n    console.error(e);\n  }\n});\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To set a time limit for an operation"}),", use the ",(0,i.jsx)(n.code,{children:"ce.timeLimit"})," option, which\nis a number of milliseconds."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"ce.timeLimit = 1000;\ntry {\n  const fact = ce.parse('(70!)!');\n  fact.evaluate().print();\n} catch (e) {\n  console.error(e);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The time limit applies to both the synchronous or asynchronous evaluation."}),"\n",(0,i.jsx)(n.p,{children:"The default time limit is 2,000ms (2 seconds)."}),"\n",(0,i.jsxs)(n.p,{children:["When an operation is canceled either because of a timeout or an abort, a\n",(0,i.jsx)(n.code,{children:"CancellationError"})," is thrown."]}),"\n",(0,i.jsx)(n.h2,{id:"lexical-scopes-and-evaluation-contexts",children:"Lexical Scopes and Evaluation Contexts"}),"\n",(0,i.jsxs)(n.p,{children:["The Compute Engine supports\n",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Scope_(computer_science)",children:"lexical scoping"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"lexical scope"})," is a region of the code where a symbol is defined.\nEach scope has its own bindings table, which is a\nmapping of symbols to their definitions. The definition includes the type\nof the symbol, whether it is a constant and other properties."]}),"\n",(0,i.jsxs)(n.p,{children:["An ",(0,i.jsx)(n.strong,{children:"evaluation context"})," is a snapshot of the current state of the Compute\nEngine. It includes the values of all symbols currently in scope and\na chain of lexical scopes."]}),"\n",(0,i.jsxs)(n.p,{children:["Evaluation contexts are arranged in a stack, with the current (top-most)\nevaluation context available with ",(0,i.jsx)(n.code,{children:"ce.context"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Evaluation contexts are created automatically, for example when a new scope is\ncreated, or each time a recursive function is called."}),"\n",(0,i.jsxs)(n.p,{children:["Some functions may create their own scope. These functions have the ",(0,i.jsx)(n.code,{children:"scoped"}),"\nflag set to ",(0,i.jsx)(n.code,{children:"true"}),". For example, the ",(0,i.jsx)(n.code,{children:"Block"})," function creates a new scope\nwhen it is called: any declarations made in the block are only visible within the\nblock. Similarly, the ",(0,i.jsx)(n.code,{children:"Sum"})," function creates a new scope so that the index\nvariable is not visible outside the sum."]}),"\n",(0,i.jsx)(n.h3,{id:"binding",children:"Binding"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Name_binding",children:"Name Binding"})," is the process of\nassociating a symbol with a definition."]})}),"\n",(0,i.jsxs)(n.p,{children:["Name Binding should not be confused with ",(0,i.jsx)(n.strong,{children:"value binding"})," which is the process\nof associating a ",(0,i.jsx)(n.strong,{children:"value"})," to a symbol."]}),"\n",(0,i.jsx)(n.p,{children:"To bind a symbol to a definition, the Compute Engine looks up the bindings table\nof the current scope. If the symbol is not found in the table, the parent\nscope is searched, and so on until a definition is found."}),"\n",(0,i.jsxs)(n.p,{children:["If no definition is found, the symbol is declared with a type of\n",(0,i.jsx)(n.code,{children:"unknown"}),", or a more specific type if the context allows it."]}),"\n",(0,i.jsx)(n.p,{children:"If the symbol is found, the definition record is used to evaluate the\nexpression."}),"\n",(0,i.jsx)(n.p,{children:"The definition record contains information about the symbol, such as its\ntype, whether it is a constant, and how to evaluate it."}),"\n",(0,i.jsx)(n.p,{children:"There are two kind of definition records:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Value Definition Record"}),": This record contains information about the\nsymbol, such as its type and whether it is a constant."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Operator Definition Record"}),": This record contains information about the\noperator, such as its signature and how to evaluate it."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Name binding is done during canonicalization. If name binding failed, the\n",(0,i.jsx)(n.code,{children:"isValid"})," property of the expression is ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To get a list of the errors in an expression"})," use the ",(0,i.jsx)(n.code,{children:"expr.errors"})," property."]}),"\n",(0,i.jsxs)(c,{path:"/compute-engine/guides/expressions/#errors",children:[" Read more about the\n",(0,i.jsx)("strong",{children:"errors"})," ",(0,i.jsx)(s,{name:"chevron-right-bold"})]}),"\n",(0,i.jsx)(n.h3,{id:"default-scopes",children:"Default Scopes"}),"\n",(0,i.jsxs)(n.p,{children:["The Compute Engine has a set of default scopes that are used to look up\nsymbols. These scopes are created automatically when the Compute Engine\nis initialized. The default scopes include the ",(0,i.jsx)(n.strong,{children:"system"})," scope, and the ",(0,i.jsx)(n.strong,{children:"global"})," scope."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"system"})," scope contains the definitions of all the built-in functions and\noperators. The ",(0,i.jsx)(n.strong,{children:"global"})," scope is initially empty, but can be used to\nstore user-defined functions and symbols."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"global"})," scope is the default scope used when the Compute Engine is\ninitialized."]}),"\n",(0,i.jsxs)(n.p,{children:["Additional scopes can be created using the ",(0,i.jsx)(n.code,{children:"ce.pushScope()"})," method."]}),"\n",(0,i.jsx)(n.h3,{id:"creating-new-scopes",children:"Creating New Scopes"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To add a new scope"})," use ",(0,i.jsx)(n.code,{children:"ce.pushScope()"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"ce.assign('x', 100); // \"x\" is defined in the current scope\nce.pushScope();\nce.assign('x', 500); // \"x\" is defined in the new scope\nce.box('x').print(); // 500\nce.popScope();\nce.box('x').print(); // 100\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To exit a scope"})," use ",(0,i.jsx)(n.code,{children:"ce.popScope()"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This will invalidate any definitions associated with the scope, and restore the\nsymbol table from previous scopes that may have been shadowed by the current\nscope."}),"\n",(0,i.jsx)(n.h2,{id:"evaluation-loop",children:"Evaluation Loop"}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"This is an advanced topic. You don't need to know the details of how the\nevaluation loop works, unless you're interested in extending the standard\nlibrary and providing your own function definitions."})}),"\n",(0,i.jsxs)(n.p,{children:["Each symbol is ",(0,i.jsx)(n.strong,{children:"bound"})," to a definition within a ",(0,i.jsx)(n.strong,{children:"lexical scope"})," during\ncanonicalization. This usually happens when calling ",(0,i.jsx)(n.code,{children:"ce.box()"})," or ",(0,i.jsx)(n.code,{children:"ce.parse()"}),",\nor if accessing the ",(0,i.jsx)(n.code,{children:".canonical"})," property of a\nnon-canonical expression."]}),"\n",(0,i.jsx)(n.p,{children:"When a function is evaluated, the following steps are followed:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If the expression is not canonical, it cannot be evaluated and an error is\nthrown. The expression must be canonicalized first."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Each argument of the function are evaluated, left to right, unless the\nfunction has a ",(0,i.jsx)(n.code,{children:"lazy"})," flag. If the function is lazy, the arguments are not\nevaluated."]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["An argument can be ",(0,i.jsx)(n.strong,{children:"held"}),", in which case it is not evaluated. Held\narguments can be useful when you need to pass a symbolic expression to a\nfunction. If it wasn't held, the result of evaluating the expression would\nbe used, not the symbolic expression."]}),"\n",(0,i.jsxs)(n.p,{children:["Alternatively, using the ",(0,i.jsx)(n.code,{children:"Hold"})," function will prevent its argument from\nbeing evaluated. Conversely, the ",(0,i.jsx)(n.code,{children:"ReleaseHold"})," function will force an\nevaluation."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["If an argument is a ",(0,i.jsx)(n.code,{children:'["Sequence"]'})," expression, treat each argument of the\nsequence expression as if it was an argument of the function. If the\nsequence is empty, ignore the argument."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If the function is associative, flatten its arguments as necessary. \\[\nf(f(a, b), c) \\to f(a, b, c) \\]"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Apply the function to the arguments"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Return the result in canonical form."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var s=t(6540);const i={},o=s.createContext(i);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);