"use strict";(self.webpackChunkcortexjs_io=self.webpackChunkcortexjs_io||[]).push([[138],{1596:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"compute-engine/guide-canonical-form","title":"Canonical Form","description":"Many mathematical objects can be represented by several equivalent expressions.","source":"@site/docs/compute-engine/05-guide-canonical-form.md","sourceDirName":"compute-engine","slug":"/compute-engine/guides/canonical-form/","permalink":"/compute-engine/guides/canonical-form/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1744999580000,"sidebarPosition":5,"frontMatter":{"title":"Canonical Form","slug":"/compute-engine/guides/canonical-form/","layout":"single","date":"Last Modified","sidebar":[{"nav":"universal"}],"toc":true,"render_math_in_document":true},"sidebar":"docSidebar","previous":{"title":"Numeric Evaluation","permalink":"/compute-engine/guides/numeric-evaluation/"},"next":{"title":"Symbols","permalink":"/compute-engine/guides/symbols/"}}');var s=i(4848),r=i(8453);const a={title:"Canonical Form",slug:"/compute-engine/guides/canonical-form/",layout:"single",date:"Last Modified",sidebar:[{nav:"universal"}],toc:!0,render_math_in_document:!0},c=void 0,t={},l=[{value:"Canonical Form and Validity",id:"canonical-form-and-validity",level:2},{value:"Canonical Form Transformations",id:"canonical-form-transformations",level:2},{value:"Custom Canonical Forms",id:"custom-canonical-forms",level:2}];function d(e){const n={a:"a",code:"code","code-playground":"code-playground",div:"div",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components},i=n["code-playground"],{Intro:o}=n;return o||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Intro",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o,{children:(0,s.jsxs)(n.p,{children:["Many mathematical objects can be represented by several equivalent expressions.\nA ",(0,s.jsx)(n.strong,{children:"canonical form"})," is a unique representation of an object that is chosen as the\nstandard representation."]})}),"\n",(0,s.jsx)(n.p,{children:"For example, the expressions in each row below represent the same mathematical\nobject:"}),"\n",(0,s.jsx)("div",{className:"equal-width-columns",children:(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"center"}}),(0,s.jsx)(n.th,{style:{textAlign:"center"}}),(0,s.jsx)(n.th,{style:{textAlign:"center"}})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\\(215.3465\\)"}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\\(2.15346\\operatorname{e}2\\)"}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\\(2.15346 \\times 10^2\\)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\\(1 - x\\)"}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\\(-x + 1\\)"}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\\(1 + (-x)\\)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\\(-2x^{-1}\\)"}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\\(-\\frac{2}{x}\\)"}),(0,s.jsx)(n.td,{style:{textAlign:"center"},children:"\\(\\frac{-2}{x}\\)"})]})]})]})}),"\n",(0,s.jsx)(n.p,{children:"The Compute Engine stores expressions internally in a canonical form to make\nit easier to work with symbolic expressions."}),"\n",(0,s.jsx)(n.p,{children:"The canonical form is intended to be \u201cstable\u201d, that is it does not depend on\nthe values of non-constant symbols or on assumptions about a symbol or\nexpression."}),"\n",(0,s.jsxs)(n.p,{children:["The type of symbols ",(0,s.jsx)(n.em,{children:"can"})," be used during canonicalization of expressions\nreferencing the symbol, as the type can only be narrowed later and thus would\nnot change the result of the canonicalization. The value of variables\n(non-constant symbols) is never used during canonicalization as\nit could be changed later."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'ce.assign("x", -2);\nconsole.info(ce.parse("\\\\frac{10}{x}").json);\n// \u2794 ["Rational", 10, "x"]\n// and not `["Rational", -10, ["Negate", "x"]]` or `5`\n'})}),"\n",(0,s.jsx)(n.p,{children:"Future versions of the Compute Engine could have different canonical forms,\nhowever a given version of the Compute Engine will always produce the same\ncanonical form for a given expression, given the same type information about\nsymbols and the same dictionary."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"To check if an expression is canonical"})," use ",(0,s.jsx)(n.code,{children:"expr.isCanonical"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"To obtain the canonical representation of a non-canonical expression"}),", use\nthe ",(0,s.jsx)(n.code,{children:"expr.canonical"})," property."]}),"\n",(0,s.jsxs)(n.p,{children:["If the expression is already canonical, ",(0,s.jsx)(n.code,{children:"expr.canonical"})," immediately returns\n",(0,s.jsx)(n.code,{children:"expr"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The return value of ",(0,s.jsx)(n.code,{children:"expr.simplify()"}),", ",(0,s.jsx)(n.code,{children:"expr.evaluate()"})," and ",(0,s.jsx)(n.code,{children:"expr.N()"})," are\ncanonical expressions."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ce.box()"})," and ",(0,s.jsx)(n.code,{children:"ce.parse()"})," functions return a canonical expression by\ndefault, which is the desirable behavior in most cases."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"To get a non-canonical version of an expression"})," use\nof ",(0,s.jsx)(n.code,{children:"ce.parse(s, {canonical: false})"})," or ",(0,s.jsx)(n.code,{children:"ce.box(expr, {canonical: false})"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["You can further customize the canonical form of an expression by using the\n",(0,s.jsx)(n.a,{href:"/compute-engine/reference/core/#CanonicalForm",children:(0,s.jsx)(n.code,{children:'["CanonicalForm"]'})})," function\nor by specifying the form you want to use. See ",(0,s.jsx)(n.a,{href:"#custom-canonical-form",children:"below"})," for more details."]}),"\n",(0,s.jsx)(n.p,{children:'The non-canonical version will be closer to the literal LaTeX input, which may\nbe desirable to compare a "raw" user input with an expected answer.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'console.info(ce.parse(\'\\\\frac{30}{-50}\').json);\n// \u2794 ["Rational", -3, 5]\n// The canonical version moves the sign to the numerator \n// and reduces the numerator and denominator\n\nconsole.info(ce.parse(\'\\\\frac{30}{-50}\', { canonical: false }).json);\n// \u2794 ["Divide", 30, -50]\n// The non-canonical version does not change the arguments,\n// so this is interpreted as a regular fraction ("Divide"), \n// not as a rational number.\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The value of ",(0,s.jsx)(n.code,{children:"expr.json"}),' (the plain JSON representation of an expression) may\nnot be in canonical form: some "sugaring" is applied to the internal\nrepresentation before being returned, for example ',(0,s.jsx)(n.code,{children:'["Power", "x", 2]'})," is\nreturned as ",(0,s.jsx)(n.code,{children:'["Square", "x"]'}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"To customize how an expression is serialized to plain JSON"})," use\n",(0,s.jsx)(n.code,{children:"expr.toMathJson()"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const expr = ce.parse("\\\\frac{3}{5}");\nconsole.log(expr.toMathJson());\n// \u2794 ["Rational", 3, 5]\n\nconsole.log(expr.expr.toMathJson({ exclude: ["Rational"] }));\n// \u2794 ["Divide", 3, 5]\n// We have excluded `["Rational"]` expressions, so it \n// is interepreted as a division instead.\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const expr = ce.parse("\\\\frac{10}{30}", { canonical: false });\nconsole.log(expr.json);\n// \u2794 ["Divide", 10, 30]\n\nconsole.log(expr.isCanonical);\n// \u2794 false\n\nconsole.log(expr.canonical.json);\n// \u2794 ["Rational", 1, 3]\n'})}),"\n",(0,s.jsx)(n.h2,{id:"canonical-form-and-validity",children:"Canonical Form and Validity"}),"\n",(0,s.jsxs)(n.p,{children:["The canonical form of an expression may not be ",(0,s.jsx)(n.strong,{children:"valid"}),". A canonical expression\nmay include ",(0,s.jsx)(n.code,{children:'["Error"]'})," expressions, for example, indicating missing arguments,\nexcess arguments, or arguments of the wrong type."]}),"\n",(0,s.jsxs)(n.p,{children:["For example the canonical form of ",(0,s.jsx)(n.code,{children:'["Ln"]'})," is ",(0,s.jsx)(n.code,{children:'["Ln", ["Error", "\'missing\'"]]'}),"\nand it is not a valid expression."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"To check if an expression is valid"})," use ",(0,s.jsx)(n.code,{children:"expr.isValid"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"To get a list of errors in an expression"})," use ",(0,s.jsx)(n.code,{children:"expr.errors"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const expr = ce.parse("Ln");\nconsole.log(expr.json);\n// \u2794 ["Ln", ["Error", "\'missing\'"]]\n// The canonical form of `Ln` is not valid\n\nconsole.log(expr.isCanonical);\n// \u2794 true\n\nconsole.log(expr.isValid);\n// \u2794 false\n\nconsole.log(expr.errors);\n// \u2794 [["Error", "\'missing\'"]]\n'})}),"\n",(0,s.jsx)(n.h2,{id:"canonical-form-transformations",children:"Canonical Form Transformations"}),"\n",(0,s.jsx)(n.p,{children:'The canonical form used by the Compute Engine follows common conventions.\nHowever, it is not always "the simplest" way to represent an expression.'}),"\n",(0,s.jsxs)(n.p,{children:["Calculating the canonical form of an expression involves applying some\nrewriting rules to an expression to put sums, products, numbers, roots,\netc... in canonical form. In that sense, it is similar to simplifying an\nexpression with ",(0,s.jsx)(n.code,{children:"expr.simplify()"}),", but it is more conservative in the\ntransformations it applies."]}),"\n",(0,s.jsx)(n.p,{children:"Below is a list of some of the transformations applied to obtain the canonical\nform:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Literal Numbers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Rationals are reduced, e.g. \\( \\frac",6,4," \\to \\frac",3,2,"\\)"]}),"\n",(0,s.jsxs)(n.li,{children:["The denominator of rationals is made positive, e.g. \\(\\frac",5,-11,"\n\\to \\frac",-5,11,"\\)"]}),"\n",(0,s.jsxs)(n.li,{children:["A rational with a denominator of 1 is replaced with the numerator, e.g.\n\\(\\frac",19,1," \\to 19\\)"]}),"\n",(0,s.jsx)(n.li,{children:"Complex numbers with no imaginary component are replaced with the real component"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Add"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Literal 0 is removed"}),"\n",(0,s.jsx)(n.li,{children:"Sum of a literal and the product of a literal with the imaginary unit are\nreplaced with a complex number."}),"\n",(0,s.jsx)(n.li,{children:"Associativity is applied"}),"\n",(0,s.jsx)(n.li,{children:"Arguments are sorted"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Multiply"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Literal 1 is removed"}),"\n",(0,s.jsx)(n.li,{children:"Product of a literal and the imaginary unit are replaced with a complex\nnumber."}),"\n",(0,s.jsx)(n.li,{children:"Literal -1 multiplied by an expression is replaced with the negation of the\nexpression."}),"\n",(0,s.jsx)(n.li,{children:"Signs are simplified: (-x)(-y) -> xy"}),"\n",(0,s.jsx)(n.li,{children:"Associativity is applied"}),"\n",(0,s.jsx)(n.li,{children:"Arguments are sorted"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Negate"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Literal numbers are negated"}),"\n",(0,s.jsx)(n.li,{children:"Negate of a negation is removed"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Power"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\\(x^n)^m \\to x^{nm}\\)"}),"\n",(0,s.jsx)(n.li,{children:"\\(x^{\\tilde\\infty} \\to \\operatorname{NaN}\\)"}),"\n",(0,s.jsx)(n.li,{children:"\\(x^0 \\to 1\\)"}),"\n",(0,s.jsx)(n.li,{children:"\\(x^1 \\to x\\)"}),"\n",(0,s.jsx)(n.li,{children:"\\((\\pm 1)^{-1} \\to -1\\)"}),"\n",(0,s.jsx)(n.li,{children:"\\((\\pm\\infty)^{-1} \\to 0\\)"}),"\n",(0,s.jsx)(n.li,{children:"\\(0^{\\infty} \\to \\tilde\\infty\\)"}),"\n",(0,s.jsx)(n.li,{children:"\\((\\pm 1)^{\\pm \\infty} \\to \\operatorname{NaN}\\)"}),"\n",(0,s.jsx)(n.li,{children:"\\(\\infty^{\\infty} \\to \\infty\\)"}),"\n",(0,s.jsx)(n.li,{children:"\\(\\infty^{-\\infty} \\to 0\\)"}),"\n",(0,s.jsx)(n.li,{children:"\\((-\\infty)^{\\pm \\infty} \\to \\operatorname{NaN}\\)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Square"}),": ",(0,s.jsx)(n.code,{children:'["Power", "x", 2]'})," \\(\\to\\) ",(0,s.jsx)(n.code,{children:'["Square", "x"]'})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Sqrt"}),": ",(0,s.jsx)(n.code,{children:'["Sqrt", "x"]'})," \\(\\to\\)",(0,s.jsx)(n.code,{children:'["Power", "x", "Half"]'})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Root"}),":  ",(0,s.jsx)(n.code,{children:'["Root", "x", 3]'})," \\(\\to\\) ",(0,s.jsx)(n.code,{children:'["Power", "x", ["Rational", 1, 3]]'})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Subtract"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Replaced with addition, e.g. ",(0,s.jsx)(n.code,{children:'["Subtract", "a", "b"]'})," \\(\\to\\) ",(0,s.jsx)(n.code,{children:'["Add", ["Negate", "b"], "a"]'})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Other functions:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Simplified if idempotent: \\( f(f(x)) \\to f(x) \\)"}),"\n",(0,s.jsx)(n.li,{children:"Simplified if an involution: \\( f(f(x)) \\to x \\)"}),"\n",(0,s.jsx)(n.li,{children:"Simplified if associative: \\( f(a, f(b, c)) \\to f(a, b, c) \\)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"custom-canonical-forms",children:"Custom Canonical Forms"}),"\n",(0,s.jsx)(n.p,{children:"The full canonical form of an expression is not always the most convenient\nrepresentation for a given application. For example, if you want to check\nthe answers from a quiz, you may want to compare the user input with a\ncanonical form that is closer to the user input."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"To get the non-canonical form"}),", use ",(0,s.jsx)(n.code,{children:"ce.box(expr, { canonical: false })"})," or\n",(0,s.jsx)(n.code,{children:"ce.parse(s, { canonical: false })"}),"."]}),"\n",(0,s.jsx)(i,{children:(0,s.jsx)(n.div,{slot:"javascript",children:'console.log(ce.parse("2(0+x\\\\times x-1)", {canonical: false}).json);\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"To get the full canonical form"}),", use ",(0,s.jsx)(n.code,{children:"ce.box(expr, { canonical: true })"})," or\n",(0,s.jsx)(n.code,{children:"ce.parse(s, { canonical: true })"}),". The ",(0,s.jsx)(n.code,{children:"canonical"})," option can be omitted\nas it is ",(0,s.jsx)(n.code,{children:"true"})," by default."]}),"\n",(0,s.jsx)(i,{children:(0,s.jsxs)(n.div,{slot:"javascript",children:['console.log(ce.parse("2(0+x\\\\times x-1)", {canonical: true}).json);\n',"\n",'console.log(ce.parse("2(0+x\\\\times x-1)").json);\n']})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"To get a custom canonical form of an expression"}),", use the\n",(0,s.jsx)(n.a,{href:"/compute-engine/reference/core/#CanonicalForm",children:(0,s.jsx)(n.code,{children:'["CanonicalForm"]'})})," function\nor specify the form you want to use with the ",(0,s.jsx)(n.code,{children:"canonical"})," option of ",(0,s.jsx)(n.code,{children:"ce.box()"}),"\nand ",(0,s.jsx)(n.code,{children:"ce.parse()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"To order the arguments in a canonical order"}),", use ",(0,s.jsx)(n.code,{children:'ce.box(expr, { canonical: "Order" })'})," or ",(0,s.jsx)(n.code,{children:'ce.parse(s, { canonical: "Order" })'}),"."]}),"\n",(0,s.jsx)(i,{children:(0,s.jsxs)(n.div,{slot:"javascript",children:['ce.parse("0+1+x+2+\\\\sqrt{5}",\n',"  ",'{canonical: "Order"}\n',").print();\n"]})}),"\n",(0,s.jsxs)(n.p,{children:["Note in particular that the ",(0,s.jsx)(n.code,{children:"0"})," is preserved in the expression, which is not\nthe case in the full canonical form."]}),"\n",(0,s.jsxs)(n.p,{children:["There are other forms that can be used to customize the canonical form of an\nexpression. See the documentation of\n",(0,s.jsx)(n.a,{href:"/compute-engine/reference/core/#CanonicalForm",children:(0,s.jsx)(n.code,{children:'["CanonicalForm"]'})})," for more details."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(i,{children:(0,s.jsxs)(n.div,{slot:"javascript",children:['const latex = "3(2+x)";\n',"ce.parse(latex, {canonical: false}).print();\n","\n",'ce.parse(latex, {canonical: ["InvisibleOperator"]}).print();\n',"\n","ce.parse(latex,\n","  ",'{canonical: ["InvisibleOperator", "Add", "Order", ]}\n',").print();\n"]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>c});var o=i(6540);const s={},r=o.createContext(s);function a(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);