"use strict";(self.webpackChunkcortexjs_io=self.webpackChunkcortexjs_io||[]).push([[4292],{9132:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>x,frontMatter:()=>o,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"compute-engine/guide-expressions","title":"Expressions","description":"The Compute Engine produces and manipulates","source":"@site/docs/compute-engine/03-guide-expressions.md","sourceDirName":"compute-engine","slug":"/compute-engine/guides/expressions/","permalink":"/compute-engine/guides/expressions/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1739200348000,"sidebarPosition":3,"frontMatter":{"title":"Expressions","slug":"/compute-engine/guides/expressions/","layout":"single","date":"Last Modified","sidebar":[{"nav":"universal"}],"toc":true},"sidebar":"docSidebar","previous":{"title":"Changelog","permalink":"/compute-engine/changelog/"},"next":{"title":"Evaluation of Expressions","permalink":"/compute-engine/guides/evaluate/"}}');var i=s(4848),t=s(8453);const o={title:"Expressions",slug:"/compute-engine/guides/expressions/",layout:"single",date:"Last Modified",sidebar:[{nav:"universal"}],toc:!0},l=void 0,c={},a=[{value:"Boxing",id:"boxing",level:2},{value:"Canonical Expressions",id:"canonical-expressions",level:2},{value:"String Representation",id:"string-representation",level:2},{value:"Unboxing",id:"unboxing",level:2},{value:"Mutability",id:"mutability",level:2},{value:"Pure Expressions",id:"pure-expressions",level:2},{value:"Checking the Kind of Expression",id:"checking-the-kind-of-expression",level:2},{value:"Errors",id:"errors",level:2},{value:"Parsing Errors",id:"parsing-errors",level:3},{value:"Semantic Errors",id:"semantic-errors",level:3}];function d(e){const n={a:"a",code:"code","code-playground":"code-playground",div:"div",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components},s=n["code-playground"],{Icon:r,Intro:o,ReadMore:l}=n;return r||h("Icon",!0),o||h("Intro",!0),l||h("ReadMore",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(o,{children:(0,i.jsxs)(n.p,{children:["The Compute Engine produces and manipulates\n",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Expression_(mathematics)",children:"symbolic expressions"}),"\nsuch as numbers, constants, variables and functions."]})}),"\n",(0,i.jsxs)(n.p,{children:["In the Compute Engine, expressions are represented internally using the\n",(0,i.jsx)(n.a,{href:"/math-json/",children:"MathJSON format"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["They are wrapped in a JavaScript object, a process called ",(0,i.jsx)(n.strong,{children:"boxing"}),", and the\nresulting expressions are ",(0,i.jsx)(n.strong,{children:"Boxed Expressions"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Boxed Expressions improve performance by implementing caching to avoid\nrepetitive calculations. They also ensure that expressions are valid and in a\nstandard format."}),"\n",(0,i.jsx)(n.p,{children:"Unlike the plain data types used by JSON, Boxed Expressions allow an IDE, such\nas VSCode Studio, to provide suitable hints in the editor regarding which\nmethods and properties are available for a given expression."}),"\n",(0,i.jsx)(n.p,{children:"Boxed Expression can be created from a LaTeX string or from a raw MathJSON\nexpression."}),"\n",(0,i.jsx)(n.h2,{id:"boxing",children:"Boxing"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To create a Boxed Expression from a MathJSON expression"}),", use the ",(0,i.jsx)(n.code,{children:"ce.box()"}),"\nfunction."]}),"\n",(0,i.jsxs)(n.p,{children:["The input of ",(0,i.jsx)(n.code,{children:"ce.box()"})," can be:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["a ",(0,i.jsx)(n.a,{href:"/math-json/",children:"MathJSON expression"})]}),"\n",(0,i.jsxs)(n.li,{children:["a ",(0,i.jsx)(n.code,{children:"BoxedExpression"})," (in which case it is returned as-is)"]}),"\n",(0,i.jsxs)(n.li,{children:["a ",(0,i.jsx)(n.code,{children:"SemiBoxedExpression"}),", that is a MathJSON expression with some of its\nsubexpressions already boxed."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The result is an instance of a ",(0,i.jsx)(n.code,{children:"BoxedExpression"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'let expr = ce.box(1.729e3);\nconsole.log(expr.re);\n// \u2794 1729\n\nconsole.log(expr.isPositive);\n// \u2794 true\n\nexpr = ce.box({ num: "+Infinity" });\nconsole.log(expr.latex);\n// \u2794 "+\\infty"\n\nexpr = ce.box(["Add", 3, "x"]);\nconsole.log(expr.operator);\n// \u2794 "Add"\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To create a Boxed Expression from a LaTeX string"}),", call the ",(0,i.jsx)(n.code,{children:"ce.parse()"}),"\nfunction."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const expr = ce.parse("3 + x + y");\nconsole.log(expr.operator);\n// \u2794 "Add"\n\nconsole.log(expr.json);\n// \u2794 ["Add", 3, "x", "y"]\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To get a Boxed Expression representing the content of a mathfield"}),"\nuse the ",(0,i.jsx)(n.code,{children:"mf.expression"})," property:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const mf = document.getElementById("input");\nmf.value = "\\\\frac{10}{5}";\nconst expr = mf.expression;\nconsole.log(expr.evaluate());\n// \u2794 2\n'})}),"\n",(0,i.jsx)(n.h2,{id:"canonical-expressions",children:"Canonical Expressions"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"canonical form"})," of an expression is a conventional way of writing an\nexpression."]}),"\n",(0,i.jsx)(n.p,{children:"For example, the canonical form of a fraction of two integers is a reduced\nrational number, written as a tuple of two integers, such that the GCD of the\nnumerator and denominator is 1, and the denominator is positive."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const expr = ce.parse("\\\\frac{30}{-50}");\nconsole.log(expr.json);\n// \u2794 ["Rational", -3, 5]\n'})}),"\n",(0,i.jsx)(n.p,{children:"The canonical form of a rational with a denominator of 1 is an integer."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const expr = ce.parse("\\\\frac{17}{1}");\nconsole.log(expr.json);\n// \u2794 17\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To determine if a non-canonical expression is a reduced (canonical) rational\nnumber"})," check that the GCD of the numerator and denominator is 1."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",metastring:"example",children:'const input = ce.parse("\\\\frac{30}{50}", {canonical: false});\nconsole.info(ce.box(\n  ["GCD", ["NumeratorDenominator", input]]\n).evaluate().value === 1);\n// \u2794 false\n'})}),"\n",(0,i.jsx)(n.p,{children:"The canonical form of an addition or multiplication will have its arguments\nordered in a canonical way."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const expr = ce.parse("2+x+\\\\pi+\\\\sqrt2+1");\nconsole.log(expr.json);\n// \u2794 ["Add", "Pi", ["Sqrt", 2], "x", 1, 2]\n'})}),"\n",(0,i.jsx)(l,{path:"/compute-engine/guides/canonical-form/",children:(0,i.jsxs)(n.p,{children:["Read more about the ",(0,i.jsx)(n.strong,{children:"Canonical Form"})," ",(0,i.jsx)(r,{name:"chevron-right-bold"})]})}),"\n",(0,i.jsxs)(n.p,{children:["By default, ",(0,i.jsx)(n.code,{children:"ce.box()"})," and ",(0,i.jsx)(n.code,{children:"ce.parse()"})," produce a canonical expression."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To get a non-canonical expression instead"}),", use\n",(0,i.jsx)(n.code,{children:"ce.box(expr, {canonical: false})"})," or ",(0,i.jsx)(n.code,{children:"ce.parse(latex, {canonical: false})"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["When using ",(0,i.jsx)(n.code,{children:"ce.parse()"}),", the non-canonical form sticks closer to the original\nLaTeX input. When using ",(0,i.jsx)(n.code,{children:"ce.box()"}),", the non-canonical form matches the\ninput MathJSON."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const latex = "\\\\frac{30}{-50}";\n\nce.parse(latex);\n// canonical form \u2794 ["Rational", -3, 5]\n\nce.parse(latex, { canonical: false });\n// non-canonical form \u2794 ["Divide", 30, -50]\n\nce.box(["Divide", 30, -50], { canonical: false });\n// non-canonical form \u2794 ["Divide", 30, -50]\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To obtain the canonical representation of a non-canonical expression"}),", use\n",(0,i.jsx)(n.code,{children:"expr.canonical"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"A non-canonical expression may include errors as a result of parsing from LaTeX,\nif the LaTeX input contained LaTeX syntax errors."}),"\n",(0,i.jsxs)(n.p,{children:["A canonical expression may include additional errors compared to a non-canonical\nexpression, for example ",(0,i.jsx)(n.code,{children:'["Divide", 2, 5, 6]'})," (three arguments instead of two),\n",(0,i.jsx)(n.code,{children:'["Add", 2, "True"]'})," (mismatched argument type, expected a number but got a\nboolean)."]}),"\n",(0,i.jsxs)(n.p,{children:["The canonical form of an expression which is not valid will include one or more\n",(0,i.jsx)(n.code,{children:'["Error"]'})," expressions indicating the nature of the problem."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To check if an expression contains errors"})," use ",(0,i.jsx)(n.code,{children:"expr.isValid"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"When doing this check on a canonical expression it takes into consideration not\nonly possible syntax errors, but also semantic errors (incorrect number or\ntype of arguments, etc...)."}),"\n",(0,i.jsx)(n.h2,{id:"string-representation",children:"String Representation"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"expr.toString()"})," method returns a ",(0,i.jsx)(n.a,{href:"https://asciimath.org/",children:"AsciiMath"})," string representation of the expression."]}),"\n",(0,i.jsx)(s,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['let expr = ce.parse("3x^2+\\\\sqrt{2}");\n',"console.log(expr.toString());\n"]})}),"\n",(0,i.jsxs)(n.p,{children:["When used in a context where a string is expected, the ",(0,i.jsx)(n.code,{children:"expr.toString()"})," method\nis called automatically."]}),"\n",(0,i.jsx)(s,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['let expr = ce.parse("3x^2+\\\\sqrt{2}");\n',"console.log(expr);\n"]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To output an AsciiMath representation of the expression to the console"})," use\n",(0,i.jsx)(n.code,{children:"expr.print()"}),"."]}),"\n",(0,i.jsx)(s,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['let expr = ce.parse("\\\\frac{1+\\\\sqrt{5}}{2}");\n',"expr.print();\n"]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To obtain a LaTeX representation of the expression"})," use ",(0,i.jsx)(n.code,{children:"expr.latex"})," or\n",(0,i.jsx)(n.code,{children:"expr.toLatex()"})," for additional formatting options."]}),"\n",(0,i.jsx)(s,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['let expr = ce.parse("3x^2+\\\\sqrt{2}");\n',"console.log(expr.latex);\n"]})}),"\n",(0,i.jsx)(n.h2,{id:"unboxing",children:"Unboxing"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To access the MathJSON expression of a boxed expression as plain JSON"}),", use\nthe ",(0,i.jsx)(n.code,{children:"expr.json"}),' property. This property is an "unboxed" version of the\nexpression.']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const expr = ce.box(["Add", 3, "x"]);\nconsole.log(expr.json);\n// \u2794 ["Add", 3, "x"]\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["To customize the format of the MathJSON expression returned by ",(0,i.jsx)(n.code,{children:"expr.json"})]}),"\nuse the ",(0,i.jsx)(n.code,{children:"ce.toMathJson()"})," method."]}),"\n",(0,i.jsx)(n.p,{children:"Use this option to control:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"which metadata, if any, should be included"}),"\n",(0,i.jsx)(n.li,{children:"whether to use shorthand notation"}),"\n",(0,i.jsx)(n.li,{children:"to exclude some functions."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"/compute-engine/api#jsonserializationoptions",children:"JsonSerializationOptions"}),"\nfor more info about the formatting options available."]}),"\n",(0,i.jsx)(s,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['const expr = ce.parse("2 + \\\\frac{q}{p}");\n','console.log("expr.json:", expr.json);\n',"\n",'console.log("expr.toMathJson():", expr.toMathJson({\n',"  ",'exclude: ["Divide"], // Don\'t use `Divide` functions,\n',"  ","// use `Multiply`/`Power` instead\n","  ","shorthands: [], // Don't use any shorthands\n","}));\n"]})}),"\n",(0,i.jsx)(n.h2,{id:"mutability",children:"Mutability"}),"\n",(0,i.jsx)(n.p,{children:"Unless otherwise specified, expressions are immutable."}),"\n",(0,i.jsxs)(n.p,{children:["The functions that manipulate Boxed Expressions, such as ",(0,i.jsx)(n.code,{children:"expr.simplify()"}),",\n",(0,i.jsx)(n.code,{children:"expr.evaluate()"}),", ",(0,i.jsx)(n.code,{children:"expr.N()"})," return a new Boxed Expression, without modifying\n",(0,i.jsx)(n.code,{children:"expr"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"However, the properties of the expression may change, since some of them may\ndepend on contextual information which can change over time."}),"\n",(0,i.jsxs)(n.p,{children:["For example, ",(0,i.jsx)(n.code,{children:"ce.box('n').isPositive"})," may return ",(0,i.jsx)(n.code,{children:"undefined"})," if nothing is known\nabout the symbol ",(0,i.jsx)(n.code,{children:"n"}),". But if an assumption about the symbol is made later, or a value\nassigned to it, then ",(0,i.jsx)(n.code,{children:"ce.box('n').isPositive"})," may take a different value."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const expr = ce.box("n");\nconsole.log(expr.isPositive);\n// \u2794 undefined\n\nce.assume(ce.parse("n > 0"));\nconsole.log(expr.isPositive);\n// \u2794 true\n'})}),"\n",(0,i.jsxs)(n.p,{children:["What doesn't change is the fact that ",(0,i.jsx)(n.code,{children:"expr"})," represents the symbol ",(0,i.jsx)(n.code,{children:'"n"'}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"pure-expressions",children:"Pure Expressions"}),"\n",(0,i.jsx)(n.p,{children:"A pure expression is an expression whose value is fixed. Evaluating it produces\nno side effect."}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{className:"language-math math-inline",children:"\\sin()"})," function is pure: it evaluates to the same value when the\nsame arguments are applied to it."]}),"\n",(0,i.jsxs)(n.p,{children:["On the other hand, the ",(0,i.jsx)(n.code,{className:"language-math math-inline",children:"\\operatorname{Random}()"})," function is not pure: by\nits nature it evaluates to a different value on every evaluation."]}),"\n",(0,i.jsx)(n.p,{children:"Numbers, symbols and strings are pure. A function expression is pure if the\nfunction itself is pure, and all its arguments are pure as well."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To check if an expression is pure"}),", use ",(0,i.jsx)(n.code,{children:"expr.isPure"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"checking-the-kind-of-expression",children:"Checking the Kind of Expression"}),"\n",(0,i.jsx)(n.p,{children:"To identify if an expression is a number literal, symbol, function expression\nor string use the following boolean expressions:"}),"\n",(0,i.jsx)("div",{className:"symbols-table first-column-header",children:(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Kind"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Boolean Expression"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.strong,{children:"Number"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"expr.isNumberLiteral"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.strong,{children:"Symbol"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"expr.symbol !== null"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.strong,{children:"Function"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"expr.isFunctionExpression"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.strong,{children:"String"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"expr.string !== null"})})]})]})]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To access a the value of an expression as a JavaScript primitive"}),", use\n",(0,i.jsx)(n.code,{children:"expr.value"}),". The result is a JavaScript primitive, such as a number, string or\nboolean. When converting to a number, the result may have lost precision if the\noriginal expression had more than 15 digits of precision. Note that ",(0,i.jsx)(n.code,{children:"expr.value"}),"\nis equivalent to ",(0,i.jsx)(n.code,{children:"expr.valueOf()"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To access the value of an expression as a JavaScript number"}),", use\n",(0,i.jsx)(n.code,{children:"expr.re"}),". The result is the real part of the number, as a JavaScript number,\nor ",(0,i.jsx)(n.code,{children:"NaN"})," if the expression is not a number. Use ",(0,i.jsx)(n.code,{children:"expr.im"})," to get the imaginary part."]}),"\n",(0,i.jsx)(n.h2,{id:"errors",children:"Errors"}),"\n",(0,i.jsx)(n.p,{children:"Sometimes, things go wrong."}),"\n",(0,i.jsxs)(n.p,{children:["When something goes wrong the Compute Engine uses an\n",(0,i.jsx)(n.code,{children:'["Error", <cause>, <location>]'})," expression."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"<cause>"})," argument provides details about the nature of the problem. This\ncan be either a string or an ",(0,i.jsx)(n.code,{children:'["ErrorCode"]'})," expression if there are additional\narguments to the error."]}),"\n",(0,i.jsxs)(n.p,{children:["For example if the problem is that an argument of a function expression is a\nboolean when a number was expected, an expression such as\n",(0,i.jsx)(n.code,{children:'["Error", ["ErrorCode", "\'incompatible-type\'", "\'number\'", "\'boolean\'"]]'})," could\nbe returned."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"<location>"})," argument indicates the context of the error. This can be a\n",(0,i.jsx)(n.code,{children:'["Latex"]'})," expression when the problem occurred while parsing a LaTeX string,\nor another expression if the problem was detected later."]}),"\n",(0,i.jsx)(n.h3,{id:"parsing-errors",children:"Parsing Errors"}),"\n",(0,i.jsxs)(n.p,{children:["When parsing a LaTeX expression, the Compute Engine uses the ",(0,i.jsx)(n.strong,{children:"maximum effort"}),"\ndoctrine. That is, even partially complete expressions are parsed, and as much\nof the input as possible is reflected in the MathJSON result."]}),"\n",(0,i.jsxs)(n.p,{children:["If required operands are missing (the denominator of a fraction, for example), a\n",(0,i.jsx)(n.code,{children:'["Error", ""missing""]'})," error expression is inserted where the missing operand\nshould have been."]}),"\n",(0,i.jsxs)(n.p,{children:["Problems that occur while parsing a LaTeX string will usually indicate a LaTeX\nsyntax error or typo: missing ",(0,i.jsx)(n.code,{children:"}"}),", mistyped command name, etc..."]}),"\n",(0,i.jsx)(n.h3,{id:"semantic-errors",children:"Semantic Errors"}),"\n",(0,i.jsx)(n.p,{children:"Some errors are not caught until an expression is bound, that is until an\nattempt is made to associate its symbol or function identifiers to a definition.\nThis could include errors such as missing or mismatched arguments."}),"\n",(0,i.jsx)(n.p,{children:"Some errors that could be considered LaTeX syntax errors may not surface until\nbinding occurs."}),"\n",(0,i.jsxs)(n.p,{children:["For example ",(0,i.jsx)(n.code,{children:"\\frac{1}{2=x}"})," (instead of ",(0,i.jsx)(n.code,{children:"\\frac{1}{2}=x"}),") will be parsed as\n",(0,i.jsx)(n.code,{children:'["Divide", 1, ["Equal", 2, x]]'}),". The fact that the second argument of the\n",(0,i.jsx)(n.code,{children:'"Divide"'})," function is a boolean and not a number will not be detected until the\ndefinition for ",(0,i.jsx)(n.code,{children:'"Divide"'})," has been located."]}),"\n",(0,i.jsx)(n.p,{children:"Name binding is done lazily, not upon boxing. To force the binding to occur,\nrequest the canonical version of the expression."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["To check if an expression includes an ",(0,i.jsx)(n.code,{children:'["Error"]'})," subexpression"]})," check the\n",(0,i.jsx)(n.code,{children:"expr.isValid"})," property."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["To get the list of all the ",(0,i.jsx)(n.code,{children:'["Error"]'})," subexpression"]})," use the ",(0,i.jsx)(n.code,{children:"expr.errors"}),"\nproperty."]}),"\n",(0,i.jsx)("div",{className:"symbols-table first-column-header",style:{"--first-col-width":"26ch"},children:(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Error Code"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Meaning"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"syntax-error"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"the parsing could not continue"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"missing"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"an expression was expected"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"unexpected-argument"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"too many arguments provided"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"expected-argument"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"not enough arguments provided"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"expected-expression"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"an expression was expected inside an enclosure (parentheses)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"unexpected-command"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"the command is unknown, or not applicable in the current parsing context"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"unexpected-token"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"the character does not apply to the current parsing context"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"incompatible-type"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"the type of the provided argument does not match the expected type"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"invalid-identifier"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["the identifier cannot be used (see ",(0,i.jsx)(n.a,{href:"/math-json/#symbols",children:"MathJSON Symbols"}),")"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"expected-closing-delimiter"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["a closing ",(0,i.jsx)(n.code,{children:"}"})," was expected, but is missing"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"unexpected-closing-delimiter"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["a closing ",(0,i.jsx)(n.code,{children:"}"})," was encountered, but not expected"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"expected-environment-name"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["the name of an environment should be provided with a ",(0,i.jsx)(n.code,{children:"\\begin"})," or ",(0,i.jsx)(n.code,{children:"\\end"})," command"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"unknown-environment"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"the environment name provided cannot be parsed"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"unbalanced-environment"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["the named used with the ",(0,i.jsx)(n.code,{children:"\\begin"})," and ",(0,i.jsx)(n.code,{children:"\\end"})," commands should match"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"unexpected-operator"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"the operator does not apply to the current parsing context. Could be an infix or postfix operator without a rhs."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"unexpected-digit"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"the string included some characters outside of the range of expected digits"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"expected-string-argument"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"the argument was expected to be a string"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"unexpected-base"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"the base is outside of the expected range (2..36)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"iteration-limit-exceeded"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"a loop has reached the maximum iteration limit"})]})]})]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'console.log(ce.parse("\\\\oops").json);\n// \u2794 ["Error", ["ErrorCode","\'unexpected-command\'","\'\\\\oops\'"], ["Latex","\'\\\\oops\'"]\n\nconsole.log(ce.parse("\\\\oops{bar}+2").json);\n// \u2794  ["Add",\n//        ["Error",\n//          ["ErrorCode","\'unexpected-command\'","\'\\\\oops\'"],\n//          ["Latex","\'\\\\oops{bar}\'"]\n//        ],\n//        2\n//    ]\n\nconsole.log(ce.parse("\\\\begin{oops}\\\\end{oops}").json);\n// \u2794 ["Error",["ErrorCode","\'unknown-environment\'",""oops""],["Latex","\'\\\\\\\\begin{oops}\\\\\\\\end{oops}\'"]\n\nconsole.log(ce.parse("1+\\\\sqrt").json);\n// \u2794 ["Add", 1 ,["Sqrt", ["Error", ""missing""]]]\n\nconsole.log(ce.parse("1+\\\\frac{2}").json);\n// \u2794 ["Add", 1, ["Divide", 2, ["Error",""missing""]]]\n\nconsole.log(ce.parse("1+(2=2)+2").json);\n// \u2794 ["Add", 1, ["Delimiter", ["Equal", 2, 2]]]\n\nconsole.log(ce.parse("1+(2=2)+3").canonical.json);\n// \u2794 ["Add",\n//      1,\n//      ["Error",\n//          ["ErrorCode", "\'incompatible-domain\'", "Numbers", "Booleans"],\n//          ["Delimiter", ["Equal", 2, 2]]\n//      ],\n//      3\n//    ]\n\nconsole.log(ce.parse("\\\\times 3").json);\n// \u2794 ["Sequence", ["Error", ["ErrorCode", "\'unexpected-operator\'", "\'\\\\times\'"], ["Latex","\'\\\\times\'"]], 3]\n\nconsole.log(ce.parse("x__+1").json);\n// \u2794 ["Add", ["Subscript", "x", ["Error","\'syntax-error\'", ["Latex","\'_\'"]]], 1]\n\nconsole.log(ce.parse("x_{a").json);\n// \u2794 ["Subscript", "x", ["Error", "\'expected-closing-delimiter\'", ["Latex","\'{a\'"]]]\n\n\nconsole.log(ce.parse("x@2").json);\n// \u2794 ["Sequence", "x", ["Error", ["ErrorCode", "\'unexpected-token\'", "\'@\'"], ["Latex", "\'@2\'"]]]\n'})})]})}function x(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function h(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var r=s(6540);const i={},t=r.createContext(i);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);