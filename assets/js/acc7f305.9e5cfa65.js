"use strict";(globalThis.webpackChunkcortexjs_io=globalThis.webpackChunkcortexjs_io||[]).push([[5933],{229(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"compute-engine/guide-logic","title":"Logic and First-Order Logic","description":"This guide covers working with logical expressions and First-Order Logic (FOL)","source":"@site/docs/compute-engine/16-guide-logic.md","sourceDirName":"compute-engine","slug":"/compute-engine/guides/logic/","permalink":"/compute-engine/guides/logic/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1769664883000,"sidebarPosition":16,"frontMatter":{"title":"Logic and First-Order Logic","slug":"/compute-engine/guides/logic/"},"sidebar":"docSidebar","previous":{"title":"Patterns and Rules","permalink":"/compute-engine/guides/patterns-and-rules/"},"next":{"title":"Linear Algebra","permalink":"/compute-engine/guides/linear-algebra/"}}');var a=i(4848),r=i(8453);const l={title:"Logic and First-Order Logic",slug:"/compute-engine/guides/logic/"},t=void 0,o={},c=[{value:"Boolean Expressions",id:"boolean-expressions",level:2},{value:"Basic Logical Operators",id:"basic-logical-operators",level:3},{value:"Additional Operators",id:"additional-operators",level:3},{value:"Operator Precedence",id:"operator-precedence",level:3},{value:"Evaluating Boolean Expressions",id:"evaluating-boolean-expressions",level:3},{value:"First-Order Logic",id:"first-order-logic",level:2},{value:"Predicates",id:"predicates",level:3},{value:"Quantifiers",id:"quantifiers",level:3},{value:"Quantifier Scope",id:"quantifier-scope",level:3},{value:"Evaluating Quantifiers",id:"evaluating-quantifiers",level:2},{value:"Finite Domain Evaluation",id:"finite-domain-evaluation",level:3},{value:"Using Range Domains",id:"using-range-domains",level:3},{value:"Nested Quantifiers",id:"nested-quantifiers",level:3},{value:"Symbolic Simplification",id:"symbolic-simplification",level:3},{value:"Normal Forms",id:"normal-forms",level:2},{value:"Conjunctive Normal Form (CNF)",id:"conjunctive-normal-form-cnf",level:3},{value:"Disjunctive Normal Form (DNF)",id:"disjunctive-normal-form-dnf",level:3},{value:"How Conversion Works",id:"how-conversion-works",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Validating Logical Arguments",id:"validating-logical-arguments",level:3},{value:"Checking Properties Over Domains",id:"checking-properties-over-domains",level:3},{value:"Database-Style Queries",id:"database-style-queries",level:3},{value:"Satisfiability and Tautology Checking",id:"satisfiability-and-tautology-checking",level:2},{value:"Satisfiability",id:"satisfiability",level:3},{value:"Tautology Checking",id:"tautology-checking",level:3},{value:"Truth Table Generation",id:"truth-table-generation",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"This guide covers working with logical expressions and First-Order Logic (FOL)\nin the Compute Engine. You'll learn how to parse, manipulate, evaluate, and\ntransform Boolean and quantified expressions."}),"\n",(0,a.jsx)(n.h2,{id:"boolean-expressions",children:"Boolean Expressions"}),"\n",(0,a.jsx)(n.h3,{id:"basic-logical-operators",children:"Basic Logical Operators"}),"\n",(0,a.jsx)(n.p,{children:"The Compute Engine supports standard logical operators:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:'const ce = new ComputeEngine();\n\n// Conjunction (AND)\nce.parse(\'p \\\\land q\');           // \u2192 ["And", "p", "q"]\n\n// Disjunction (OR)\nce.parse(\'p \\\\lor q\');            // \u2192 ["Or", "p", "q"]\n\n// Negation (NOT)\nce.parse(\'\\\\lnot p\');             // \u2192 ["Not", "p"]\n\n// Implication (multiple notations supported)\nce.parse(\'p \\\\implies q\');        // \u2192 ["Implies", "p", "q"]\nce.parse(\'p \\\\Rightarrow q\');     // \u2192 ["Implies", "p", "q"]\nce.parse(\'p \\\\rightarrow q\');     // \u2192 ["Implies", "p", "q"]\n\n// Equivalence (biconditional, multiple notations)\nce.parse(\'p \\\\iff q\');            // \u2192 ["Equivalent", "p", "q"]\nce.parse(\'p \\\\Leftrightarrow q\'); // \u2192 ["Equivalent", "p", "q"]\nce.parse(\'p \\\\leftrightarrow q\'); // \u2192 ["Equivalent", "p", "q"]\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Note:"})," ",(0,a.jsx)(n.code,{children:"\\to"})," is reserved for function/set mapping notation (e.g., ",(0,a.jsx)(n.code,{children:"f: A \\to B"}),")\nand parses as ",(0,a.jsx)(n.code,{children:"To"}),", not ",(0,a.jsx)(n.code,{children:"Implies"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"additional-operators",children:"Additional Operators"}),"\n",(0,a.jsx)(n.p,{children:"The Compute Engine also supports exclusive OR, NAND, and NOR:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:'// Exclusive OR (XOR)\nce.parse(\'p \\\\veebar q\');         // \u2192 ["Xor", "p", "q"]\n\n// NAND (Not AND)\nce.parse(\'p \\\\barwedge q\');       // \u2192 ["Nand", "p", "q"]\n'})}),"\n",(0,a.jsx)(n.p,{children:"These operators support any number of arguments:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:"// N-ary XOR: true when an odd number of arguments are true\nce.box(['Xor', 'True', 'True', 'True']).evaluate();   // \u2192 True (3 is odd)\nce.box(['Xor', 'True', 'True', 'False']).evaluate();  // \u2192 False (2 is even)\n\n// N-ary NAND: NOT(AND(a, b, c, ...))\nce.box(['Nand', 'True', 'True', 'False']).evaluate(); // \u2192 True\n\n// N-ary NOR: NOT(OR(a, b, c, ...))\nce.box(['Nor', 'False', 'False', 'False']).evaluate(); // \u2192 True\n"})}),"\n",(0,a.jsx)(n.h3,{id:"operator-precedence",children:"Operator Precedence"}),"\n",(0,a.jsx)(n.p,{children:"Logical operators are designed to work naturally with comparison operators.\nComparisons bind tighter than logical operators, so you can write compound\nconditions without parentheses:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:'// Comparisons bind tighter than Or\nce.parse(\'x = 1 \\\\lor y = 2\');\n// \u2192 ["Or", ["Equal", "x", 1], ["Equal", "y", 2]]\n\n// And binds tighter than Or\nce.parse(\'a \\\\land b \\\\lor c\');\n// \u2192 ["Or", ["And", "a", "b"], "c"]\n\n// Or binds tighter than Implies\nce.parse(\'p \\\\lor q \\\\implies r\');\n// \u2192 ["Implies", ["Or", "p", "q"], "r"]\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Important:"})," ",(0,a.jsx)(n.code,{children:"Not"})," (",(0,a.jsx)(n.code,{children:"\\lnot"}),", ",(0,a.jsx)(n.code,{children:"\\neg"}),") has very high precedence and only applies\nto the immediately following atom. This matches standard mathematical convention:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:'// \\lnot only applies to p, not the whole expression\nce.parse(\'\\\\lnot p \\\\land q\');\n// \u2192 ["And", ["Not", "p"], "q"]\n\n// Use parentheses to negate compound expressions\nce.parse(\'\\\\lnot(p \\\\land q)\');\n// \u2192 ["Not", ["And", "p", "q"]]\n\n// Similarly for comparisons\nce.parse(\'\\\\lnot x = 1\');\n// \u2192 ["Equal", ["Not", "x"], 1]  -- probably not what you want!\n\nce.parse(\'\\\\lnot(x = 1)\');\n// \u2192 ["Not", ["Equal", "x", 1]]  -- correct way to negate a comparison\n'})}),"\n",(0,a.jsx)(n.h3,{id:"evaluating-boolean-expressions",children:"Evaluating Boolean Expressions"}),"\n",(0,a.jsxs)(n.p,{children:["Boolean expressions with concrete ",(0,a.jsx)(n.code,{children:"True"}),"/",(0,a.jsx)(n.code,{children:"False"})," values evaluate to their\nlogical result:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:"ce.box(['And', 'True', 'False']).evaluate();     // \u2192 False\nce.box(['Or', 'True', 'False']).evaluate();      // \u2192 True\nce.box(['Not', 'False']).evaluate();             // \u2192 True\nce.box(['Implies', 'True', 'False']).evaluate(); // \u2192 False\nce.box(['Implies', 'False', 'True']).evaluate(); // \u2192 True\nce.box(['Xor', 'True', 'False']).evaluate();     // \u2192 True\nce.box(['Nand', 'True', 'True']).evaluate();     // \u2192 False\nce.box(['Nor', 'False', 'False']).evaluate();    // \u2192 True\n"})}),"\n",(0,a.jsx)(n.h2,{id:"first-order-logic",children:"First-Order Logic"}),"\n",(0,a.jsx)(n.p,{children:"First-Order Logic extends propositional logic with quantifiers and predicates,\nallowing you to make statements about objects in a domain."}),"\n",(0,a.jsx)(n.h3,{id:"predicates",children:"Predicates"}),"\n",(0,a.jsx)(n.p,{children:"In FOL, predicates are functions that return Boolean values. They are typically\nwritten as uppercase letters followed by arguments."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Inside quantifier scopes"}),", predicates are wrapped in a ",(0,a.jsx)(n.code,{children:"Predicate"})," expression\nto distinguish them from regular function applications:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:'ce.parse(\'\\\\forall x, P(x)\');\n// \u2192 ["ForAll", "x", ["Predicate", "P", "x"]]\n\nce.parse(\'\\\\exists x, Q(x, y)\');\n// \u2192 ["Exists", "x", ["Predicate", "Q", "x", "y"]]\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Outside quantifier scopes"}),", single uppercase letters followed by parentheses\nare parsed as regular function applications to maintain backward compatibility:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:'ce.parse(\'P(x)\');           // \u2192 ["P", "x"]\nce.parse(\'Q(a, b)\');        // \u2192 ["Q", "a", "b"]\n'})}),"\n",(0,a.jsx)(n.p,{children:"For multi-letter predicate names, declare them explicitly:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:"ce.declare('Loves', { signature: '(value, value) -> boolean' });\nce.parse('Loves(x, y)');    // \u2192 [\"Loves\", \"x\", \"y\"]\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["Note about ",(0,a.jsx)(n.code,{children:"D(f, x)"})," and ",(0,a.jsx)(n.code,{children:"N(x)"}),":"]})," These notations in LaTeX are ",(0,a.jsx)(n.strong,{children:"not"}),"\ninterpreted as their library function equivalents:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"D(f, x)"})," parses as ",(0,a.jsx)(n.code,{children:'["Predicate", "D", "f", "x"]'})," (not the derivative)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"N(x)"})," parses as ",(0,a.jsx)(n.code,{children:'["Predicate", "N", "x"]'})," (not numeric evaluation)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Use Leibniz notation (",(0,a.jsx)(n.code,{children:"\\frac{d}{dx}f"}),") for derivatives, or construct directly in\nMathJSON. For numeric evaluation, use the ",(0,a.jsx)(n.code,{children:".N()"})," method on expressions."]}),"\n",(0,a.jsx)(n.h3,{id:"quantifiers",children:"Quantifiers"}),"\n",(0,a.jsx)(n.p,{children:"The Compute Engine supports universal and existential quantifiers:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:'// Universal quantifier: "for all x"\nce.parse(\'\\\\forall x, P(x)\');\n// \u2192 ["ForAll", "x", ["Predicate", "P", "x"]]\n\n// Existential quantifier: "there exists x"\nce.parse(\'\\\\exists x, P(x)\');\n// \u2192 ["Exists", "x", ["Predicate", "P", "x"]]\n\n// Unique existential: "there exists exactly one x"\nce.parse(\'\\\\exists! x, P(x)\');\n// \u2192 ["ExistsUnique", "x", ["Predicate", "P", "x"]]\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Negated quantifiers are also supported: ",(0,a.jsx)(n.code,{children:"NotForAll"})," and ",(0,a.jsx)(n.code,{children:"NotExists"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Quantifiers can also specify a domain using set membership:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:'ce.parse(\'\\\\forall x \\\\in \\\\R, x^2 \\\\geq 0\');\n// \u2192 ["ForAll", ["Element", "x", "RealNumbers"], ["GreaterEqual", ["Square", "x"], 0]]\n'})}),"\n",(0,a.jsx)(n.h3,{id:"quantifier-scope",children:"Quantifier Scope"}),"\n",(0,a.jsxs)(n.p,{children:["By default, quantifiers use ",(0,a.jsx)(n.strong,{children:"tight binding"})," following standard FOL conventions.\nThe scope extends only to the immediately following formula:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:'ce.parse(\'\\\\forall x. P(x) \\\\implies Q(x)\');\n// Parses as: (\u2200x. P(x)) \u2192 Q(x)\n// \u2192 ["Implies", ["ForAll", "x", ["Predicate", "P", "x"]], ["Q", "x"]]\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Note that ",(0,a.jsx)(n.code,{children:"P(x)"})," inside the quantifier becomes ",(0,a.jsx)(n.code,{children:'["Predicate", "P", "x"]'}),", while\n",(0,a.jsx)(n.code,{children:"Q(x)"})," outside the quantifier scope becomes ",(0,a.jsx)(n.code,{children:'["Q", "x"]'}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Use parentheses to extend the quantifier's scope:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:'ce.parse(\'\\\\forall x. (P(x) \\\\implies Q(x))\');\n// Parses as: \u2200x. (P(x) \u2192 Q(x))\n// \u2192 ["ForAll", "x", ["Delimiter", ["Implies", ["Predicate", "P", "x"], ["Predicate", "Q", "x"]]]]\n'})}),"\n",(0,a.jsxs)(n.p,{children:["You can change this behavior with the ",(0,a.jsx)(n.code,{children:"quantifierScope"})," option:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:'// Loose binding - scope extends to end of expression\nce.parse(\'\\\\forall x. P(x) \\\\implies Q(x)\', { quantifierScope: \'loose\' });\n// \u2192 ["ForAll", "x", ["Implies", ["Predicate", "P", "x"], ["Predicate", "Q", "x"]]]\n'})}),"\n",(0,a.jsx)(n.h2,{id:"evaluating-quantifiers",children:"Evaluating Quantifiers"}),"\n",(0,a.jsx)(n.p,{children:"Quantifiers can be evaluated to Boolean values when the bound variable is\nconstrained to a finite domain."}),"\n",(0,a.jsx)(n.h3,{id:"finite-domain-evaluation",children:"Finite Domain Evaluation"}),"\n",(0,a.jsxs)(n.p,{children:["Specify a finite domain using ",(0,a.jsx)(n.code,{children:"Element"})," with a ",(0,a.jsx)(n.code,{children:"Set"}),", ",(0,a.jsx)(n.code,{children:"List"}),", ",(0,a.jsx)(n.code,{children:"Range"}),", or\n",(0,a.jsx)(n.code,{children:"Interval"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:"// Universal: all elements satisfy the predicate\nce.box(['ForAll',\n  ['Element', 'x', ['Set', 1, 2, 3]],\n  ['Greater', 'x', 0]\n]).evaluate();\n// \u2192 True (1 > 0, 2 > 0, 3 > 0 all hold)\n\n// Existential: at least one element satisfies the predicate\nce.box(['Exists',\n  ['Element', 'x', ['Set', 1, 2, 3]],\n  ['Greater', 'x', 2]\n]).evaluate();\n// \u2192 True (3 > 2 holds)\n\n// Unique existential: exactly one element satisfies the predicate\nce.box(['ExistsUnique',\n  ['Element', 'x', ['Set', 1, 2, 3]],\n  ['Equal', 'x', 2]\n]).evaluate();\n// \u2192 True (only 2 equals 2)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"using-range-domains",children:"Using Range Domains"}),"\n",(0,a.jsxs)(n.p,{children:["For integer ranges, use ",(0,a.jsx)(n.code,{children:"Range"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:"// All integers from 1 to 100 are positive\nce.box(['ForAll',\n  ['Element', 'n', ['Range', 1, 100]],\n  ['Greater', 'n', 0]\n]).evaluate();\n// \u2192 True\n\n// Some integer from 1 to 10 is a perfect square greater than 5\nce.box(['Exists',\n  ['Element', 'n', ['Range', 1, 10]],\n  ['And', ['Greater', 'n', 5], ['Equal', ['Sqrt', 'n'], ['Floor', ['Sqrt', 'n']]]]\n]).evaluate();\n// \u2192 True (9 is a perfect square > 5)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"nested-quantifiers",children:"Nested Quantifiers"}),"\n",(0,a.jsx)(n.p,{children:"Nested quantifiers are evaluated over the Cartesian product of their domains:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:"// For all pairs (x, y) in {1,2} \xd7 {1,2}: x + y > 0\nce.box(['ForAll', ['Element', 'x', ['Set', 1, 2]],\n  ['ForAll', ['Element', 'y', ['Set', 1, 2]],\n    ['Greater', ['Add', 'x', 'y'], 0]\n  ]\n]).evaluate();\n// \u2192 True (checks all 4 pairs: (1,1), (1,2), (2,1), (2,2))\n\n// There exist x, y in {1,2,3} such that x + y = 5\nce.box(['Exists', ['Element', 'x', ['Set', 1, 2, 3]],\n  ['Exists', ['Element', 'y', ['Set', 1, 2, 3]],\n    ['Equal', ['Add', 'x', 'y'], 5]\n  ]\n]).evaluate();\n// \u2192 True (x=2, y=3 or x=3, y=2)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"symbolic-simplification",children:"Symbolic Simplification"}),"\n",(0,a.jsx)(n.p,{children:"Quantifiers simplify automatically in certain cases:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:"// Constant body\nce.box(['ForAll', 'x', 'True']).evaluate();   // \u2192 True\nce.box(['ForAll', 'x', 'False']).evaluate();  // \u2192 False\nce.box(['Exists', 'x', 'True']).evaluate();   // \u2192 True\nce.box(['Exists', 'x', 'False']).evaluate();  // \u2192 False\n\n// Body doesn't contain the quantified variable\nce.box(['ForAll', 'x', ['Greater', 'y', 0]]).evaluate();\n// \u2192 y > 0 (the quantifier is eliminated)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"normal-forms",children:"Normal Forms"}),"\n",(0,a.jsx)(n.p,{children:"The Compute Engine can convert Boolean expressions to standard normal forms,\nuseful for automated reasoning and satisfiability checking."}),"\n",(0,a.jsx)(n.h3,{id:"conjunctive-normal-form-cnf",children:"Conjunctive Normal Form (CNF)"}),"\n",(0,a.jsx)(n.p,{children:"CNF is a conjunction (AND) of disjunctions (OR) of literals:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:"// Convert (A \u2227 B) \u2228 C to CNF\nce.box(['ToCNF', ['Or', ['And', 'A', 'B'], 'C']]).evaluate();\n// \u2192 (A \u2228 C) \u2227 (B \u2228 C)\n\n// Convert implication to CNF\nce.box(['ToCNF', ['Implies', 'A', 'B']]).evaluate();\n// \u2192 \xacA \u2228 B\n\n// De Morgan's law is applied automatically\nce.box(['ToCNF', ['Not', ['And', 'A', 'B']]]).evaluate();\n// \u2192 \xacA \u2228 \xacB\n"})}),"\n",(0,a.jsx)(n.h3,{id:"disjunctive-normal-form-dnf",children:"Disjunctive Normal Form (DNF)"}),"\n",(0,a.jsx)(n.p,{children:"DNF is a disjunction (OR) of conjunctions (AND) of literals:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:"// Convert (A \u2228 B) \u2227 C to DNF\nce.box(['ToDNF', ['And', ['Or', 'A', 'B'], 'C']]).evaluate();\n// \u2192 (A \u2227 C) \u2228 (B \u2227 C)\n\n// De Morgan's law\nce.box(['ToDNF', ['Not', ['Or', 'A', 'B']]]).evaluate();\n// \u2192 \xacA \u2227 \xacB\n"})}),"\n",(0,a.jsx)(n.h3,{id:"how-conversion-works",children:"How Conversion Works"}),"\n",(0,a.jsx)(n.p,{children:"The conversion process:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Eliminate implications"}),": ",(0,a.jsx)(n.code,{children:"A \u2192 B"})," becomes ",(0,a.jsx)(n.code,{children:"\xacA \u2228 B"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Eliminate equivalences"}),": ",(0,a.jsx)(n.code,{children:"A \u2194 B"})," becomes ",(0,a.jsx)(n.code,{children:"(\xacA \u2228 B) \u2227 (\xacB \u2228 A)"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Push negations inward"})," (De Morgan's laws): ",(0,a.jsx)(n.code,{children:"\xac(A \u2227 B)"})," becomes ",(0,a.jsx)(n.code,{children:"\xacA \u2228 \xacB"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Distribute"})," to get the target form:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"For CNF: distribute OR over AND"}),"\n",(0,a.jsx)(n.li,{children:"For DNF: distribute AND over OR"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,a.jsx)(n.h3,{id:"validating-logical-arguments",children:"Validating Logical Arguments"}),"\n",(0,a.jsx)(n.p,{children:"Check if an argument is valid by verifying the conclusion follows from premises:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:"// Modus Ponens: If P \u2192 Q and P, then Q\n// Check: for all truth values, (P \u2192 Q) \u2227 P \u2192 Q is a tautology\n\nce.box(['ForAll', ['Element', 'p', ['Set', 'True', 'False']],\n  ['ForAll', ['Element', 'q', ['Set', 'True', 'False']],\n    ['Implies',\n      ['And', ['Implies', 'p', 'q'], 'p'],\n      'q'\n    ]\n  ]\n]).evaluate();\n// \u2192 True (Modus Ponens is valid)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"checking-properties-over-domains",children:"Checking Properties Over Domains"}),"\n",(0,a.jsx)(n.p,{children:"Verify mathematical properties:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:"// Commutativity of addition for small integers\nce.box(['ForAll', ['Element', 'a', ['Range', -5, 5]],\n  ['ForAll', ['Element', 'b', ['Range', -5, 5]],\n    ['Equal', ['Add', 'a', 'b'], ['Add', 'b', 'a']]\n  ]\n]).evaluate();\n// \u2192 True\n\n// Check if a function is injective over a domain\n// f(x) = x\xb2 is not injective on {-2, -1, 0, 1, 2}\nce.box(['Exists', ['Element', 'x', ['Set', -2, -1, 0, 1, 2]],\n  ['Exists', ['Element', 'y', ['Set', -2, -1, 0, 1, 2]],\n    ['And',\n      ['NotEqual', 'x', 'y'],\n      ['Equal', ['Square', 'x'], ['Square', 'y']]\n    ]\n  ]\n]).evaluate();\n// \u2192 True (x=-1, y=1 both give 1)\n"})}),"\n",(0,a.jsx)(n.h3,{id:"database-style-queries",children:"Database-Style Queries"}),"\n",(0,a.jsx)(n.p,{children:"Use quantifiers for set-based queries:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:"// Define a \"database\" of people and their ages\nconst people = ['Set',\n  ['List', 'Alice', 25],\n  ['List', 'Bob', 30],\n  ['List', 'Carol', 22]\n];\n\n// Check if someone is over 28\nce.box(['Exists', ['Element', 'person', people],\n  ['Greater', ['At', 'person', 2], 28]\n]).evaluate();\n// \u2192 True (Bob is 30)\n"})}),"\n",(0,a.jsx)(n.h2,{id:"satisfiability-and-tautology-checking",children:"Satisfiability and Tautology Checking"}),"\n",(0,a.jsx)(n.p,{children:"The Compute Engine can check whether Boolean formulas are satisfiable (can be\nmade true) or are tautologies (always true)."}),"\n",(0,a.jsx)(n.h3,{id:"satisfiability",children:"Satisfiability"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"IsSatisfiable"})," to check if there exists an assignment of truth values that\nmakes the expression true:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:"// A contradiction is not satisfiable\nce.box(['IsSatisfiable', ['And', 'A', ['Not', 'A']]]).evaluate();\n// \u2192 False\n\n// Most formulas are satisfiable\nce.box(['IsSatisfiable', ['And', 'A', 'B']]).evaluate();\n// \u2192 True (set A=True, B=True)\n\n// A tautology is satisfiable\nce.box(['IsSatisfiable', ['Or', 'A', ['Not', 'A']]]).evaluate();\n// \u2192 True\n"})}),"\n",(0,a.jsx)(n.h3,{id:"tautology-checking",children:"Tautology Checking"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"IsTautology"})," to check if an expression is true for all possible assignments:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:"// Law of excluded middle\nce.box(['IsTautology', ['Or', 'A', ['Not', 'A']]]).evaluate();\n// \u2192 True\n\n// Double negation\nce.box(['IsTautology', ['Equivalent', ['Not', ['Not', 'A']], 'A']]).evaluate();\n// \u2192 True\n\n// De Morgan's law\nce.box(['IsTautology', ['Equivalent',\n  ['Not', ['And', 'A', 'B']],\n  ['Or', ['Not', 'A'], ['Not', 'B']]\n]]).evaluate();\n// \u2192 True\n\n// Modus Ponens\nce.box(['IsTautology', ['Implies',\n  ['And', ['Implies', 'A', 'B'], 'A'],\n  'B'\n]]).evaluate();\n// \u2192 True\n\n// A simple conjunction is not a tautology\nce.box(['IsTautology', ['And', 'A', 'B']]).evaluate();\n// \u2192 False\n"})}),"\n",(0,a.jsx)(n.h2,{id:"truth-table-generation",children:"Truth Table Generation"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"TruthTable"})," to generate a complete truth table for any Boolean expression:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",metastring:"example",children:'// Truth table for AND\nce.box([\'TruthTable\', [\'And\', \'A\', \'B\']]).evaluate();\n// \u2192 [["A", "B", "Result"],\n//    ["False", "False", "False"],\n//    ["False", "True", "False"],\n//    ["True", "False", "False"],\n//    ["True", "True", "True"]]\n\n// Truth table for implication\nce.box([\'TruthTable\', [\'Implies\', \'P\', \'Q\']]).evaluate();\n// \u2192 [["P", "Q", "Result"],\n//    ["False", "False", "True"],\n//    ["False", "True", "True"],\n//    ["True", "False", "False"],\n//    ["True", "True", "True"]]\n'})}),"\n",(0,a.jsx)(n.p,{children:"Truth tables are limited to 10 variables (1024 rows) to prevent excessive output."}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Domain size"}),": Evaluation iterates through all domain elements. Keep domains\nunder 1000 elements."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Nested quantifiers"}),": With n quantifiers over domains of size k, evaluation\nchecks k^n combinations. Use sparingly."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Short-circuit evaluation"}),": ",(0,a.jsx)(n.code,{children:"ForAll"})," stops at the first ",(0,a.jsx)(n.code,{children:"False"}),", ",(0,a.jsx)(n.code,{children:"Exists"}),"\nstops at the first ",(0,a.jsx)(n.code,{children:"True"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Satisfiability/Tautology"}),": These check all 2^n truth assignments for n\nvariables. Limited to 20 variables."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/compute-engine/reference/logic/",children:"Logic Reference"})," - Complete list of logic\noperators and their signatures"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/compute-engine/reference/sets/",children:"Sets Reference"})," - Working with sets and\nset operations"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>l,x:()=>t});var s=i(6540);const a={},r=s.createContext(a);function l(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);