"use strict";(self.webpackChunkcortexjs_io=self.webpackChunkcortexjs_io||[]).push([[6494],{2184:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"compute-engine/guide-assumptions","title":"Assumptions","description":"Assumptions are statements about symbols that are assumed to be true. For","source":"@site/docs/compute-engine/14-guide-assumptions.md","sourceDirName":"compute-engine","slug":"/compute-engine/guides/assumptions/","permalink":"/compute-engine/guides/assumptions/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1737867004000,"sidebarPosition":14,"frontMatter":{"title":"Assumptions","slug":"/compute-engine/guides/assumptions/"},"sidebar":"docSidebar","previous":{"title":"Compiling Expressions","permalink":"/compute-engine/guides/compiling/"},"next":{"title":"Patterns and Rules","permalink":"/compute-engine/guides/patterns-and-rules/"}}');var i=n(4848),l=n(8453);const r={title:"Assumptions",slug:"/compute-engine/guides/assumptions/"},o=void 0,a={},c=[{value:"Defining New Assumptions",id:"defining-new-assumptions",level:2},{value:"Multivariate Assumptions",id:"multivariate-assumptions",level:3},{value:"Default Assumptions",id:"default-assumptions",level:3},{value:"Verifyinf Assumptions",id:"verifyinf-assumptions",level:2},{value:"Forgetting Assumptions",id:"forgetting-assumptions",level:2},{value:"Scoped Assumptions",id:"scoped-assumptions",level:2}];function d(e){const s={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components},{Icon:n,Intro:t,ReadMore:r}=s;return n||u("Icon",!0),t||u("Intro",!0),r||u("ReadMore",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t,{children:(0,i.jsx)(s.p,{children:"Assumptions are statements about symbols that are assumed to be true. For\nexample, the assumption that \\(x\\) is a positive real number is used to simplify\n\\(|x|\\) to \\(x\\)."})}),"\n",(0,i.jsx)(s.p,{children:"When declaring a symbol, it is possible to specify its type. For example, the\nsymbol \\(x\\) can be declared to be a real number:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'ce.declare("x", "real");\n'})}),"\n",(0,i.jsx)(s.p,{children:"However, assumptions can be used to describe more complex properties of symbols.\nFor example, the assumption that \\(x\\) is positive is used to simplify\n\\(\\sqrt{x^2}\\) to \\(x\\)."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'ce.assume(["Greater", "x", 2]);\n'})}),"\n",(0,i.jsx)(s.p,{children:"Assumptions can also describe the relationship between two symbols, for example\nthat \\(x\\) is greater than \\(y\\):"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'ce.assume(["Greater", "x", "y"]);\n'})}),"\n",(0,i.jsx)(s.p,{children:"This knowledge base is used by the Compute Engine to simplify\nexpressions."}),"\n",(0,i.jsx)(r,{path:"/compute-engine/guides/simplify/",children:(0,i.jsxs)(s.p,{children:["Read more about ",(0,i.jsx)(s.strong,{children:"Simplifying Expressions"})," ",(0,i.jsx)(n,{name:"chevron-right-bold"})]})}),"\n",(0,i.jsx)(s.p,{children:"In general, assumptions are not used when evaluating expressions."}),"\n",(0,i.jsx)(s.h2,{id:"defining-new-assumptions",children:"Defining New Assumptions"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"To make an assumption about a symbol"}),", use the ",(0,i.jsx)(s.code,{children:"ce.assume()"})," function."]}),"\n",(0,i.jsx)(s.p,{children:"For example, to indicate \\(\\beta \\in \\R\\):"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'ce.assume(ce.parse("\\\\beta \\\\in \\\\R"));\n\n// or:\n\nce.assume(["Element", "Beta", "RealNumbers"]);\n'})}),"\n",(0,i.jsx)(s.p,{children:"In this case, this would be equivalent to declaring a type for the symbol\n\\(\\beta\\):"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'ce.declare("Beta", "real");\n'})}),"\n",(0,i.jsx)(s.p,{children:"The head of the proposition can be one of the following:"}),"\n",(0,i.jsx)("div",{className:"symbols-table",children:(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{style:{textAlign:"left"},children:"Head"}),(0,i.jsx)(s.th,{style:{textAlign:"left"}})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,i.jsx)(s.code,{children:"Element"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"NotElement"})]}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:"Indicate the domain of a symbol"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,i.jsx)(s.code,{children:"Less"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"LessEqual"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"Greater"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"GreaterEqual"})]}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["Inequality. Both sides are assumed to be ",(0,i.jsx)(s.code,{children:"RealNumbers"})]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,i.jsx)(s.code,{children:"Equal"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"NotEqual"})]}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:"Equality"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,i.jsx)(s.code,{children:"And"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"Or"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"Not"})]}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["Boolean expression. Using ",(0,i.jsx)(s.code,{children:"And"})," is equivalent to using multiple ",(0,i.jsx)(s.code,{children:"assume()"})," for each term of the boolean expression."]})]})]})]})}),"\n",(0,i.jsxs)(s.p,{children:["If the ",(0,i.jsx)(s.code,{children:"assume()"})," function is invoked with two arguments, it is equivalent to\n",(0,i.jsx)(s.code,{children:'ce.assume(["Element", <arg1>, <arg2>])'}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:"example",children:'ce.assume(["Element", "x", "RealNumbers"); // same as ce.assume(["Element", "x", "RealNumbers"])\n'})}),"\n",(0,i.jsxs)(s.p,{children:["The argument to the ",(0,i.jsx)(s.code,{children:"assume()"})," function is a ",(0,i.jsx)(s.strong,{children:"proposition"}),". That proposition\nis analyzed and the fact it describes are recorded in the Compute Engine\nassumptions knowledge base. Some propositions can be described in several\ndifferent but equivalent ways. You can use whichever form you prefer. Similarly,\nwhen querying the knowledge base later, you can use any form you'd like."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:"example",children:'ce.assume(["Element", "x", "PositiveNumbers"]);\n\n// Equivalent to...\nce.assume(["Greater", "x", 0]);\n\n// ... or ...\nce.assume(["Element", "x", ["Interval", ["Open", 0], "Infinity"]]);\n'})}),"\n",(0,i.jsx)(s.h3,{id:"multivariate-assumptions",children:"Multivariate Assumptions"}),"\n",(0,i.jsx)(s.p,{children:"Assumptions frequently describe the property of a symbol. However, it is\nalso possible to describe relationships betwen symbols."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:"ce.assume(ce.parse('xy + 1 = 0'))'\n"})}),"\n",(0,i.jsx)(s.h3,{id:"default-assumptions",children:"Default Assumptions"}),"\n",(0,i.jsx)(s.p,{children:"When creating an instance of a Compute Engine, the following assumptions are\nmade:"}),"\n",(0,i.jsx)("div",{className:"symbols-table",children:(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{style:{textAlign:"left"},children:"Symbol"}),(0,i.jsx)(s.th,{style:{textAlign:"left"},children:"Type"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,i.jsx)(s.code,{children:"a"})," ",(0,i.jsx)(s.code,{children:"b"})," ",(0,i.jsx)(s.code,{children:"c"})," ",(0,i.jsx)(s.code,{children:"d"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"i"})," ",(0,i.jsx)(s.code,{children:"j"})," ",(0,i.jsx)(s.code,{children:"k"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"r"})," ",(0,i.jsx)(s.code,{children:"t"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"x"})," ",(0,i.jsx)(s.code,{children:"y"})]}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.code,{children:"real"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,i.jsx)(s.code,{children:"f"})," ",(0,i.jsx)(s.code,{children:"g"})," ",(0,i.jsx)(s.code,{children:"h"})]}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.code,{children:"function"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,i.jsx)(s.code,{children:"m"})," ",(0,i.jsx)(s.code,{children:"n"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"p"})," ",(0,i.jsx)(s.code,{children:"q"})]}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.code,{children:"integer"})})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,i.jsx)(s.code,{children:"w"})," ",(0,i.jsx)(s.code,{children:"z"})]}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:(0,i.jsx)(s.code,{children:"complex"})})]})]})]})}),"\n",(0,i.jsxs)(s.p,{children:["This list of assumptions make it possible to immediately use common symbols such\nas ",(0,i.jsx)(s.code,{children:"x"})," or ",(0,i.jsx)(s.code,{children:"y"})," without having to declare them explicitly."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"To specify a different list of assumptions"}),", use the ",(0,i.jsx)(s.code,{children:"assumptions"})," option\nwhen creating a Compute Engine instance:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'const ce = new ComputeEngine({\n  assumptions: [\n    ["Element", "x", "Integers"],\n    ["Element", "y", "Integers"],\n  ],\n});\n'})}),"\n",(0,i.jsxs)(s.p,{children:["To have no assumptions at all, set the ",(0,i.jsx)(s.code,{children:"assumptions"})," option to ",(0,i.jsx)(s.code,{children:"null"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:"const ce = new ComputeEngine({ assumptions: null });\n"})}),"\n",(0,i.jsx)(s.h2,{id:"verifyinf-assumptions",children:"Verifyinf Assumptions"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"To test if a particular assumption is valid"}),", call the ",(0,i.jsx)(s.code,{children:"ce.verify()"})," function."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'ce.verify(["Element", "x", "RealNumbers"]);\n'})}),"\n",(0,i.jsxs)(s.p,{children:["The function ",(0,i.jsx)(s.code,{children:"ce.verify()"})," return ",(0,i.jsx)(s.code,{children:"true"})," if the assumption is true, ",(0,i.jsx)(s.code,{children:"false"})," if it is\nnot, and ",(0,i.jsx)(s.code,{children:"undefined"})," if it cannot be determined."]}),"\n",(0,i.jsxs)(s.p,{children:["While ",(0,i.jsx)(s.code,{children:"ce.verify()"})," is appropriate to get boolean answers, more complex queries can\nalso be made."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"To query the assumptions knowledge base"})," call the ",(0,i.jsx)(s.code,{children:"ce.ask()"})," function."]}),"\n",(0,i.jsxs)(s.p,{children:["The argument of ",(0,i.jsx)(s.code,{children:"ask()"})," can be a pattern, and it returns an array of matches as\n",(0,i.jsx)(s.code,{children:"Substitution"})," objects."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'// "x is a positive integer"\nce.assume(["Element", "x", "PositiveIntegers"]);\n\n// "What is x greater than?"\nce.ask(["Greater", "x", "_val"]);\n\n//  -> [{"val": 0}] "It is greater than 0"\n'})}),"\n",(0,i.jsx)(r,{path:"/compute-engine/guides/patterns-and-rules/",children:(0,i.jsxs)(s.p,{children:["Read more about ",(0,i.jsx)(s.strong,{children:"Patterns and Rules"}),(0,i.jsx)(n,{name:"chevron-right-bold"})]})}),"\n",(0,i.jsx)(s.h2,{id:"forgetting-assumptions",children:"Forgetting Assumptions"}),"\n",(0,i.jsxs)(s.p,{children:["Each call to ",(0,i.jsx)(s.code,{children:"ce.assume()"})," is additive: the previous assumptions are preserved."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"To remove previous assumptions"}),", use ",(0,i.jsx)(s.code,{children:"ce.forget()"}),"."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Calling ",(0,i.jsx)(s.code,{children:"ce.forget()"})," with no arguments will remove all assumptions."]}),"\n",(0,i.jsx)(s.li,{children:"Passing an array of symbol names will remove assumptions about each of the\nsymbols."}),"\n",(0,i.jsx)(s.li,{children:"Passing a symbol name will only remove assumptions about that particular\nsymbol."}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'ce.assume(["Element", "\\\\alpha", "RealNumbers"]);\nce.is(["Element", "\\\\alpha", "RealNumbers"]);\n// \u2794  true\n\nce.forget("\\\\alpha");\n\nce.is(["Element", "\\\\alpha", "RealNumbers"]);\n// \u2794  undefined\n'})}),"\n",(0,i.jsx)(s.h2,{id:"scoped-assumptions",children:"Scoped Assumptions"}),"\n",(0,i.jsx)(s.p,{children:'When an assumption is made, it is applicable to the current scope and all\nsubsequent scopes. Scopes "inherit" assumptions from their parent scopes.'}),"\n",(0,i.jsxs)(s.p,{children:["When exiting a scope, with ",(0,i.jsx)(s.code,{children:"ce.popScope()"}),", all assumptions made in that scope\nare forgotten."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"To temporarily define a series of assumptions"}),", create a new scope."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'ce.is(["Element", "\\\\alpha", "RealNumbers"]);\n// \u2794 undefined\n\nce.pushScope();\n\nce.assume(["Element", "\\\\alpha", "RealNumbers"]);\nce.is(["Element", "\\\\alpha", "RealNumbers"]);\n// \u2794  true\n\nce.popScope(); // all assumptions made in the current scope are forgotten\n\nce.is(["Element", "\\\\alpha", "RealNumbers"]);\n// \u2794  undefined\n'})})]})}function h(e={}){const{wrapper:s}={...(0,l.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function u(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>o});var t=n(6540);const i={},l=t.createContext(i);function r(e){const s=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(l.Provider,{value:s},e.children)}}}]);