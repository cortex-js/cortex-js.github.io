"use strict";(globalThis.webpackChunkcortexjs_io=globalThis.webpackChunkcortexjs_io||[]).push([[4246],{4859(e,n,l){l.r(n),l.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>x,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"compute-engine/reference-logic","title":"Logic","description":"Constants","source":"@site/docs/compute-engine/89-reference-logic.md","sourceDirName":"compute-engine","slug":"/compute-engine/reference/logic/","permalink":"/compute-engine/reference/logic/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1769648952000,"sidebarPosition":89,"frontMatter":{"title":"Logic","slug":"/compute-engine/reference/logic/","date":"Last Modified"},"sidebar":"docSidebar","previous":{"title":"Linear Algebra","permalink":"/compute-engine/reference/linear-algebra/"},"next":{"title":"Sets","permalink":"/compute-engine/reference/sets/"}}');var s=l(4848),i=l(8453);const r={title:"Logic",slug:"/compute-engine/reference/logic/",date:"Last Modified"},a=void 0,d={},c=[{value:"Constants",id:"constants",level:2},{value:"Logical Operators",id:"logical-operators",level:2},{value:"Quantifiers",id:"quantifiers",level:2},{value:"First-Order Logic",id:"first-order-logic",level:2},{value:"Predicates",id:"predicates",level:3},{value:"Quantifier Scope",id:"quantifier-scope",level:3},{value:"Quantifier Scope Option",id:"quantifier-scope-option",level:3},{value:"Negated Quantifiers",id:"negated-quantifiers",level:3},{value:"Quantifier Evaluation",id:"quantifier-evaluation",level:3},{value:"Normal Forms",id:"normal-forms",level:2},{value:"Satisfiability and Tautology",id:"satisfiability-and-tautology",level:2}];function o(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components},{FunctionDefinition:l,Latex:t,Signature:r}=n;return l||h("FunctionDefinition",!0),t||h("Latex",!0),r||h("Signature",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"constants",children:"Constants"}),"\n",(0,s.jsx)("div",{className:"symbols-table first-column-header",style:{"--first-col-width":"12ch"},children:(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Symbol"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"LaTeX"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Notation"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"True"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"\\top"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:"\\top"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"True"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"\\mathsf{T}"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:" \\mathsf{T}"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"True"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"\\operatorname{True}"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:" \\operatorname{True}"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"False"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"\\bot"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:"\\bot"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"False"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"\\mathsf{F}"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:" \\mathsf{F}"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"False"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"\\operatorname{False}"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:" \\operatorname{False}"})})]})]})]})}),"\n",(0,s.jsx)(n.h2,{id:"logical-operators",children:"Logical Operators"}),"\n",(0,s.jsx)("div",{className:"symbols-table first-column-header",style:{"--first-col-width":"12ch"},children:(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Symbol"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"LaTeX"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Notation"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"And"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"p \\land q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:" p \\land q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Conjunction"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"And"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"p \\operatorname{and} q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:" p \\operatorname{and} q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"}})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Or"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"p \\lor q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:" p \\lor q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Disjunction"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Or"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"p \\operatorname{or} q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:" p \\operatorname{or} q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"}})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Xor"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"p \\veebar q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:" p \\veebar q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Exclusive OR (n-ary: true when odd count)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Nand"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"p \\barwedge q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:" p \\barwedge q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"NAND (n-ary: NOT of AND)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Nor"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:'p \\char"22BD q'})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:' p \\char"22BD q'})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"NOR (n-ary: NOT of OR)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Not"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"\\lnot p"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:" \\lnot p"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Negation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Not"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"\\operatorname{not} p"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:" \\operatorname{not} p"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"}})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Equivalent"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"p \\iff q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:" p \\iff q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Equivalence"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Equivalent"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"p \\Leftrightarrow q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:" p \\Leftrightarrow q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"}})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Implies"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"p \\implies q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:"p \\implies q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Implication"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Implies"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"p \\Rightarrow q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:"p \\Rightarrow q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"}})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Proves"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"p \\vdash q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:"p \\vdash q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Provability"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Entails"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"p \\vDash q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:"p \\vDash q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Entailment"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"Satisfies"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"p \\models q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:"p \\models q"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Satisfaction"})]})]})]})}),"\n",(0,s.jsx)(n.h2,{id:"quantifiers",children:"Quantifiers"}),"\n",(0,s.jsxs)(l,{name:"ForAll",children:[(0,s.jsxs)(r,{name:"ForAll",children:[(0,s.jsx)(n.em,{children:"condition"}),", ",(0,s.jsx)(n.em,{children:"predicate"})]}),(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ForAll"})," function represents the ",(0,s.jsx)(n.strong,{children:"universal quantifier"}),"."]}),(0,s.jsx)(n.p,{children:"The condition is the variable (or variables) being quantified over, or the set\nof elements that the variable can take."}),(0,s.jsx)(n.p,{children:"The predicate is the statement that is being quantified."}),(0,s.jsx)(n.p,{children:"The condition and the predicate are separated by a comma, a colon, or a vertical\nbar. The predicate can also be enclosed in parentheses after the condition."}),(0,s.jsx)(t,{value:"\\forall x, x + 1 > x"}),(0,s.jsx)(t,{value:"\\forall x: x + 1 > x"}),(0,s.jsx)(t,{value:"\\forall x\\mid x + 1 > x"}),(0,s.jsx)(t,{value:"\\forall x( x + 1 > x)"}),(0,s.jsx)(t,{value:"\\forall x \\in \\R, x + 1 > x"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"example",children:'["ForAll", "x", ["Greater", ["Add", "x", 1], "x"]]\n\n["ForAll", ["Element", "x", "RealNumbers"], ["Greater", ["Square", "x"], 0]]\n'})})]}),"\n",(0,s.jsxs)(l,{name:"Exists",children:[(0,s.jsxs)(r,{name:"Exists",children:[(0,s.jsx)(n.em,{children:"condition"}),", ",(0,s.jsx)(n.em,{children:"predicate"})]}),(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Exists"})," function represents the ",(0,s.jsx)(n.strong,{children:"existential quantifier"}),"."]}),(0,s.jsx)(n.p,{children:"The condition is the variable (or variables) being quantified over, and the\npredicate is the statement that is being quantified."}),(0,s.jsx)(n.p,{children:"The condition and the predicate are separated by a comma, a colon, or a vertical\nbar. The predicate can also be enclosed in parentheses after the condition."}),(0,s.jsx)(t,{value:"\\exists x, x^2 = 1"}),(0,s.jsx)(t,{value:"\\exists x: x^2 = 1"}),(0,s.jsx)(t,{value:"\\exists x\\mid x^2 = 1"}),(0,s.jsx)(t,{value:"\\exists x( x^2 = 1)"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"example",children:'["Exists", "x", ["Equal", ["Square", "x"], 1]]\n\n["Exists", ["Element", "x", "RealNumbers"], ["Equal", ["Square", "x"], 1]]\n'})})]}),"\n",(0,s.jsxs)(l,{name:"ExistsUnique",children:[(0,s.jsxs)(r,{name:"ExistsUnique",children:[(0,s.jsx)(n.em,{children:"condition"}),", ",(0,s.jsx)(n.em,{children:"predicate"})]}),(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ExistsUnique"})," function represents the ",(0,s.jsx)(n.strong,{children:"unique existential quantifier"}),"."]}),(0,s.jsx)(t,{value:"\\exists! x, x^2 = 1"})]}),"\n",(0,s.jsx)(n.h2,{id:"first-order-logic",children:"First-Order Logic"}),"\n",(0,s.jsx)(n.p,{children:"When working with First-Order Logic (FOL) expressions, there are several features\nto be aware of:"}),"\n",(0,s.jsx)(n.h3,{id:"predicates",children:"Predicates"}),"\n",(0,s.jsxs)(n.p,{children:["In FOL, predicates are typically represented as uppercase letters followed by\narguments in parentheses, such as ",(0,s.jsx)(n.code,{children:"P(x)"})," or ",(0,s.jsx)(n.code,{children:"Q(a, b)"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Single uppercase letters followed by parentheses are ",(0,s.jsx)(n.strong,{children:"automatically recognized"}),"\nas function/predicate applications:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'ce.parse(\'P(x)\')           // \u2192 ["P", "x"]\nce.parse(\'Q(a, b)\')        // \u2192 ["Q", "a", "b"]\n'})}),"\n",(0,s.jsx)(n.p,{children:"For multi-letter predicate names or lowercase predicates, you should declare\nthem explicitly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"ce.declare('Loves', { signature: '(value, value) -> boolean' });\nce.parse('Loves(x, y)')    // \u2192 [\"Loves\", \"x\", \"y\"]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"quantifier-scope",children:"Quantifier Scope"}),"\n",(0,s.jsxs)(n.p,{children:["By default, quantifiers use ",(0,s.jsx)(n.strong,{children:"tight binding"}),", following standard FOL conventions.\nThe quantifier scope extends only to the immediately following well-formed formula,\nstopping at logical connectives."]}),"\n",(0,s.jsx)(t,{value:"\\forall x. P(x) \\implies Q(x)"}),"\n",(0,s.jsxs)(n.p,{children:["This parses as ",(0,s.jsx)(n.code,{children:"(\u2200x. P(x)) \u21d2 Q(x)"}),", not ",(0,s.jsx)(n.code,{children:"\u2200x. (P(x) \u21d2 Q(x))"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"example",children:'["Implies", ["ForAll", "x", ["P", "x"]], ["Q", "x"]]\n'})}),"\n",(0,s.jsx)(n.p,{children:"To include the connective in the quantifier's scope, use explicit parentheses:"}),"\n",(0,s.jsx)(t,{value:"\\forall x. (P(x) \\implies Q(x))"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:"example",children:'["ForAll", "x", ["Delimiter", ["Implies", ["P", "x"], ["Q", "x"]]]]\n'})}),"\n",(0,s.jsx)(n.h3,{id:"quantifier-scope-option",children:"Quantifier Scope Option"}),"\n",(0,s.jsxs)(n.p,{children:["You can control the quantifier scope behavior with the ",(0,s.jsx)(n.code,{children:"quantifierScope"})," parsing\noption:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Tight binding (default) - quantifier binds only the next formula\nce.parse(\'\\\\forall x. P(x) \\\\implies Q(x)\', { quantifierScope: \'tight\' })\n// \u2192 ["Implies", ["ForAll", "x", ["P", "x"]], ["Q", "x"]]\n\n// Loose binding - quantifier scope extends to end of expression\nce.parse(\'\\\\forall x. P(x) \\\\implies Q(x)\', { quantifierScope: \'loose\' })\n// \u2192 ["ForAll", "x", ["Implies", ["P", "x"], ["Q", "x"]]]\n'})}),"\n",(0,s.jsx)(n.h3,{id:"negated-quantifiers",children:"Negated Quantifiers"}),"\n",(0,s.jsxs)(n.p,{children:["The negated quantifiers ",(0,s.jsx)(n.code,{children:"NotForAll"})," and ",(0,s.jsx)(n.code,{children:"NotExists"})," are also supported:"]}),"\n",(0,s.jsx)("div",{className:"symbols-table first-column-header",style:{"--first-col-width":"14ch"},children:(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Symbol"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"LaTeX"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Notation"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"NotForAll"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"\\lnot\\forall x, P(x)"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:"\\lnot\\forall x, P(x)"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"NotExists"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{children:"\\lnot\\exists x, P(x)"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.code,{className:"language-math math-inline",children:"\\lnot\\exists x, P(x)"})})]})]})]})}),"\n",(0,s.jsx)(n.h3,{id:"quantifier-evaluation",children:"Quantifier Evaluation"}),"\n",(0,s.jsxs)(n.p,{children:["Quantifiers can be evaluated to Boolean values when the bound variable is\nconstrained to a finite domain using an ",(0,s.jsx)(n.code,{children:"Element"})," condition."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Supported domains:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Set"})," - explicit finite sets: ",(0,s.jsx)(n.code,{children:'["Element", "x", ["Set", 1, 2, 3]]'})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"List"})," - explicit finite lists: ",(0,s.jsx)(n.code,{children:'["Element", "x", ["List", 1, 2, 3]]'})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Range"})," - integer ranges: ",(0,s.jsx)(n.code,{children:'["Element", "n", ["Range", 1, 10]]'})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Interval"})," - integer intervals: ",(0,s.jsx)(n.code,{children:'["Element", "n", ["Interval", 1, 10]]'})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Domains are limited to 1000 elements maximum."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// All elements in {1, 2, 3} are greater than 0\nce.box(['ForAll', ['Element', 'x', ['Set', 1, 2, 3]], ['Greater', 'x', 0]]).evaluate()\n// \u2192 True\n\n// Some element in {1, 2, 3} is greater than 2\nce.box(['Exists', ['Element', 'x', ['Set', 1, 2, 3]], ['Greater', 'x', 2]]).evaluate()\n// \u2192 True (x = 3 satisfies the condition)\n\n// Exactly one element equals 2\nce.box(['ExistsUnique', ['Element', 'x', ['Set', 1, 2, 3]], ['Equal', 'x', 2]]).evaluate()\n// \u2192 True\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Nested quantifiers"})," are evaluated over the Cartesian product of domains:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// For all (x, y) in {1, 2} \xd7 {1, 2}: x + y > 0\nce.box(['ForAll', ['Element', 'x', ['Set', 1, 2]],\n  ['ForAll', ['Element', 'y', ['Set', 1, 2]],\n    ['Greater', ['Add', 'x', 'y'], 0]]]).evaluate()\n// \u2192 True\n\n// Some (x, y) in {1, 2} \xd7 {1, 2} satisfies x + y = 4\nce.box(['Exists', ['Element', 'x', ['Set', 1, 2]],\n  ['Exists', ['Element', 'y', ['Set', 1, 2]],\n    ['Equal', ['Add', 'x', 'y'], 4]]]).evaluate()\n// \u2192 True (x = 2, y = 2)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Symbolic simplifications"})," are applied when possible:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"\u2200x. True"})," \u2192 ",(0,s.jsx)(n.code,{children:"True"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"\u2200x. False"})," \u2192 ",(0,s.jsx)(n.code,{children:"False"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"\u2203x. True"})," \u2192 ",(0,s.jsx)(n.code,{children:"True"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"\u2203x. False"})," \u2192 ",(0,s.jsx)(n.code,{children:"False"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"\u2200x. P"})," (where P doesn't contain x) \u2192 ",(0,s.jsx)(n.code,{children:"P"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"\u2203x. P"})," (where P doesn't contain x) \u2192 ",(0,s.jsx)(n.code,{children:"P"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"normal-forms",children:"Normal Forms"}),"\n",(0,s.jsxs)(l,{name:"ToCNF",children:[(0,s.jsx)(r,{name:"ToCNF",children:(0,s.jsx)(n.em,{children:"expression"})}),(0,s.jsxs)(n.p,{children:["Converts a boolean expression to ",(0,s.jsx)(n.strong,{children:"Conjunctive Normal Form"})," (CNF)."]}),(0,s.jsx)(n.p,{children:"CNF is a conjunction (And) of disjunctions (Or) of literals. A literal is\neither a variable or its negation."}),(0,s.jsxs)(n.p,{children:["Example: ",(0,s.jsx)(n.code,{className:"language-math math-inline",children:"(A \\lor B) \\land (\\lnot A \\lor C)"})]}),(0,s.jsx)(n.p,{children:"The conversion applies:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["De Morgan's laws: ",(0,s.jsx)(n.code,{className:"language-math math-inline",children:"\\lnot(A \\land B) \\equiv \\lnot A \\lor \\lnot B"})]}),"\n",(0,s.jsxs)(n.li,{children:["Distribution: ",(0,s.jsx)(n.code,{className:"language-math math-inline",children:"(A \\land B) \\lor C \\equiv (A \\lor C) \\land (B \\lor C)"})]}),"\n",(0,s.jsxs)(n.li,{children:["Implication elimination: ",(0,s.jsx)(n.code,{className:"language-math math-inline",children:"A \\to B \\equiv \\lnot A \\lor B"})]}),"\n",(0,s.jsxs)(n.li,{children:["Equivalence elimination: ",(0,s.jsx)(n.code,{className:"language-math math-inline",children:"A \\leftrightarrow B \\equiv (\\lnot A \\lor B) \\land (\\lnot B \\lor A)"})]}),"\n"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"ce.box(['ToCNF', ['Or', ['And', 'A', 'B'], 'C']]).evaluate()\n// \u2192 (A \u2228 C) \u2227 (B \u2228 C)\n\nce.box(['ToCNF', ['Implies', 'A', 'B']]).evaluate()\n// \u2192 \xacA \u2228 B\n\nce.box(['ToCNF', ['Not', ['And', 'A', 'B']]]).evaluate()\n// \u2192 \xacA \u2228 \xacB  (De Morgan's law)\n"})})]}),"\n",(0,s.jsxs)(l,{name:"ToDNF",children:[(0,s.jsx)(r,{name:"ToDNF",children:(0,s.jsx)(n.em,{children:"expression"})}),(0,s.jsxs)(n.p,{children:["Converts a boolean expression to ",(0,s.jsx)(n.strong,{children:"Disjunctive Normal Form"})," (DNF)."]}),(0,s.jsx)(n.p,{children:"DNF is a disjunction (Or) of conjunctions (And) of literals. A literal is\neither a variable or its negation."}),(0,s.jsxs)(n.p,{children:["Example: ",(0,s.jsx)(n.code,{className:"language-math math-inline",children:"(A \\land B) \\lor (\\lnot A \\land C)"})]}),(0,s.jsx)(n.p,{children:"The conversion applies:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["De Morgan's laws: ",(0,s.jsx)(n.code,{className:"language-math math-inline",children:"\\lnot(A \\lor B) \\equiv \\lnot A \\land \\lnot B"})]}),"\n",(0,s.jsxs)(n.li,{children:["Distribution: ",(0,s.jsx)(n.code,{className:"language-math math-inline",children:"(A \\lor B) \\land C \\equiv (A \\land C) \\lor (B \\land C)"})]}),"\n",(0,s.jsx)(n.li,{children:"Implication and equivalence elimination (same as CNF)"}),"\n"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"ce.box(['ToDNF', ['And', ['Or', 'A', 'B'], 'C']]).evaluate()\n// \u2192 (A \u2227 C) \u2228 (B \u2227 C)\n\nce.box(['ToDNF', ['Not', ['Or', 'A', 'B']]]).evaluate()\n// \u2192 \xacA \u2227 \xacB  (De Morgan's law)\n"})})]}),"\n",(0,s.jsx)(n.h2,{id:"satisfiability-and-tautology",children:"Satisfiability and Tautology"}),"\n",(0,s.jsxs)(l,{name:"IsSatisfiable",children:[(0,s.jsx)(r,{name:"IsSatisfiable",children:(0,s.jsx)(n.em,{children:"expression"})}),(0,s.jsxs)(n.p,{children:["Checks if a Boolean expression is ",(0,s.jsx)(n.strong,{children:"satisfiable"})," \u2014 that is, whether there exists\nan assignment of truth values to variables that makes the expression true."]}),(0,s.jsxs)(n.p,{children:["Returns ",(0,s.jsx)(n.code,{children:"True"})," if the expression is satisfiable, ",(0,s.jsx)(n.code,{children:"False"})," otherwise."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// A contradiction is not satisfiable\nce.box(['IsSatisfiable', ['And', 'A', ['Not', 'A']]]).evaluate()\n// \u2192 False\n\n// Most formulas are satisfiable\nce.box(['IsSatisfiable', ['Or', 'A', 'B']]).evaluate()\n// \u2192 True\n\n// A tautology is also satisfiable\nce.box(['IsSatisfiable', ['Or', 'A', ['Not', 'A']]]).evaluate()\n// \u2192 True\n"})}),(0,s.jsx)(n.p,{children:"Limited to expressions with at most 20 variables (2^20 = 1,048,576 combinations)."})]}),"\n",(0,s.jsxs)(l,{name:"IsTautology",children:[(0,s.jsx)(r,{name:"IsTautology",children:(0,s.jsx)(n.em,{children:"expression"})}),(0,s.jsxs)(n.p,{children:["Checks if a Boolean expression is a ",(0,s.jsx)(n.strong,{children:"tautology"})," \u2014 that is, whether it is true\nfor all possible assignments of truth values to variables."]}),(0,s.jsxs)(n.p,{children:["Returns ",(0,s.jsx)(n.code,{children:"True"})," if the expression is a tautology, ",(0,s.jsx)(n.code,{children:"False"})," otherwise."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Law of excluded middle\nce.box(['IsTautology', ['Or', 'A', ['Not', 'A']]]).evaluate()\n// \u2192 True\n\n// Double negation elimination\nce.box(['IsTautology', ['Equivalent', ['Not', ['Not', 'A']], 'A']]).evaluate()\n// \u2192 True\n\n// De Morgan's law\nce.box(['IsTautology', ['Equivalent',\n  ['Not', ['And', 'A', 'B']],\n  ['Or', ['Not', 'A'], ['Not', 'B']]\n]]).evaluate()\n// \u2192 True\n\n// A simple variable is not a tautology\nce.box(['IsTautology', 'A']).evaluate()\n// \u2192 False\n"})}),(0,s.jsx)(n.p,{children:"Limited to expressions with at most 20 variables."})]}),"\n",(0,s.jsxs)(l,{name:"TruthTable",children:[(0,s.jsx)(r,{name:"TruthTable",children:(0,s.jsx)(n.em,{children:"expression"})}),(0,s.jsxs)(n.p,{children:["Generates a complete ",(0,s.jsx)(n.strong,{children:"truth table"})," for a Boolean expression."]}),(0,s.jsxs)(n.p,{children:["Returns a ",(0,s.jsx)(n.code,{children:"List"})," of ",(0,s.jsx)(n.code,{children:"List"}),'s, where the first row contains the variable names\nfollowed by "Result", and subsequent rows contain the truth values for each\ncombination of inputs.']}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'ce.box([\'TruthTable\', [\'And\', \'A\', \'B\']]).evaluate()\n// \u2192 [["A", "B", "Result"],\n//    ["False", "False", "False"],\n//    ["False", "True", "False"],\n//    ["True", "False", "False"],\n//    ["True", "True", "True"]]\n\nce.box([\'TruthTable\', [\'Xor\', \'P\', \'Q\']]).evaluate()\n// \u2192 [["P", "Q", "Result"],\n//    ["False", "False", "False"],\n//    ["False", "True", "True"],\n//    ["True", "False", "True"],\n//    ["True", "True", "False"]]\n'})}),(0,s.jsx)(n.p,{children:"Limited to expressions with at most 10 variables (1024 rows)."})]})]})}function x(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}function h(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453(e,n,l){l.d(n,{R:()=>r,x:()=>a});var t=l(6540);const s={},i=t.createContext(s);function r(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);