"use strict";(self.webpackChunkcortexjs_io=self.webpackChunkcortexjs_io||[]).push([[2296],{1249:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"compute-engine/guide-evaluate","title":"Evaluation of Expressions","description":"Evaluating an expression is the process of determining the value of the","source":"@site/docs/compute-engine/10-guide-evaluate.md","sourceDirName":"compute-engine","slug":"/compute-engine/guides/evaluate/","permalink":"/compute-engine/guides/evaluate/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1738088002000,"sidebarPosition":10,"frontMatter":{"title":"Evaluation of Expressions","slug":"/compute-engine/guides/evaluate/","preamble":null},"sidebar":"docSidebar","previous":{"title":"Expressions","permalink":"/compute-engine/guides/expressions/"},"next":{"title":"Symbolic Computing","permalink":"/compute-engine/guides/symbolic-computing/"}}');var o=i(4848),s=i(8453);const r={title:"Evaluation of Expressions",slug:"/compute-engine/guides/evaluate/",preamble:null},a="Evaluation",l={},d=[{value:"Evaluation Methods",id:"evaluation-methods",level:2},{value:"Numeric Approximation",id:"numeric-approximation",level:3},{value:"Compilation",id:"compilation",level:3},{value:"Asynchronous Evaluation",id:"asynchronous-evaluation",level:2},{value:"Scopes",id:"scopes",level:2},{value:"Binding",id:"binding",level:2},{value:"Evaluation Loop",id:"evaluation-loop",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code","code-playground":"code-playground",div:"div",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components},i=n["code-playground"],{Icon:t,Intro:r,ReadMore:a}=n;return t||h("Icon",!0),r||h("Intro",!0),a||h("ReadMore",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"evaluation",children:"Evaluation"})}),"\n",(0,o.jsx)(r,{children:(0,o.jsx)(n.p,{children:"Evaluating an expression is the process of determining the value of the\nexpression. This involves looking up the definitions of symbols and functions,\nevaluating the arguments of functions, and applying the function to the\narguments."})}),"\n",(0,o.jsx)(n.h2,{id:"evaluation-methods",children:"Evaluation Methods"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"To evaluate an expression"}),", use the ",(0,o.jsx)(n.code,{children:"expr.evaluate()"})," method."]}),"\n",(0,o.jsx)(i,{children:(0,o.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,o.jsx)(n.h3,{id:"numeric-approximation",children:"Numeric Approximation"}),"\n",(0,o.jsxs)(n.p,{children:["By default, ",(0,o.jsx)(n.code,{children:"expr.evaluate()"})," preserves ",(0,o.jsx)(n.a,{href:"/compute-engine/guides/numeric-evaluation/#exact-evaluation",children:"exact values"})," in the result.\nTo force ",(0,o.jsx)(n.a,{href:"/compute-engine/guides/numeric-evaluation/",children:"numeric evaluation"})," use the ",(0,o.jsx)(n.code,{children:"numericApproximation"})," option."]}),"\n",(0,o.jsx)(i,{children:(0,o.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"expr.N()"})," method is a shorthand for ",(0,o.jsx)(n.code,{children:"expr.evaluate({numericApproximation: true})"}),"."]}),"\n",(0,o.jsx)(i,{children:(0,o.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,o.jsx)(n.h3,{id:"compilation",children:"Compilation"}),"\n",(0,o.jsxs)(n.p,{children:["An expression can be evaluated by compiling it to JavaScript using the ",(0,o.jsx)(n.code,{children:"expr.compile()"})," method."]}),"\n",(0,o.jsx)(a,{path:"/compute-engine/guides/compiling/",children:(0,o.jsxs)(n.p,{children:["Read more about ",(0,o.jsx)(n.strong,{children:"compiling expressions"})," ",(0,o.jsx)(t,{name:"chevron-right-bold"})]})}),"\n",(0,o.jsx)(n.h2,{id:"asynchronous-evaluation",children:"Asynchronous Evaluation"}),"\n",(0,o.jsx)(n.p,{children:"Some computations can be time-consuming. For example, computing a very large\nfactorial. To prevent the browser from freezing, the Compute Engine can\nperform some operations asynchronously."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"To perform an asynchronous evaluation"}),", use the ",(0,o.jsx)(n.code,{children:"expr.evaluateAsync()"})," method."]}),"\n",(0,o.jsx)(i,{children:(0,o.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"expr.evaluateAsync()"})," method returns a ",(0,o.jsx)(n.code,{children:"Promise"})," that resolves to the result\nof the evaluation. It accepts the same ",(0,o.jsx)(n.code,{children:"numericApproximation"})," options as ",(0,o.jsx)(n.code,{children:"expr.evaluate()"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"It is also possible to interrupt an evaluation, for example by providing the user\nwith a pause/cancel button."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"To make an evaluation interruptible"}),", use an ",(0,o.jsx)(n.code,{children:"AbortController"}),"\nobject and a ",(0,o.jsx)(n.code,{children:"signal"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"For example, to interrupt an evaluation after 500ms:"}),"\n",(0,o.jsx)(i,{children:(0,o.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,o.jsxs)(i,{children:[(0,o.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]}),(0,o.jsxs)(n.div,{slot:"html",children:['<div class="stack">\n',"  ",'<div class="row">\n',"    ",'<button id="evaluate-button">Evaluate</button>\n',"    ",'<button id="cancel-button" disabled>Cancel</button>\n',"  ","</div>\n","\n","  ",'<div id="output"></div>\n',"</div>\n"]}),(0,o.jsxs)(n.div,{slot:"javascript",children:["const abort = new AbortController();\n","\n","document.getElementById('cancel-button').addEventListener('click',\n","  ","() => abort.abort()\n",");\n","\n","document.getElementById('evaluate-button').addEventListener('click', async () => {\n","  ","try {\n","    ","document.getElementById('evaluate-button').disabled = true;\n","    ","document.getElementById('cancel-button').disabled = false;\n","\n","    ","const fact = ce.parse('(70!)!');\n","    ","const factResult = await fact.evaluateAsync({ signal: abort.signal });\n","    ","document.getElementById('output').textContent = factResult.toString();\n","    ","\n","    ","document.getElementById('evaluate-button').disabled = false;\n","    ","document.getElementById('cancel-button').disabled = true;\n","  ","} catch (e) {\n","    ","document.getElementById('evaluate-button').disabled = false;\n","    ","document.getElementById('cancel-button').disabled = true;\n","    ","console.error(e);\n","  ","}\n","});\n","\n"]})]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"To set a time limit for an operation"}),", use the ",(0,o.jsx)(n.code,{children:"ce.timeLimit"})," option, which\nis a number of milliseconds."]}),"\n",(0,o.jsx)(i,{children:(0,o.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,o.jsx)(n.p,{children:"The time limit applies to both the synchronous or asynchronous evaluation."}),"\n",(0,o.jsx)(n.p,{children:"The default time limit is 2,000ms (2 seconds)."}),"\n",(0,o.jsxs)(n.p,{children:["When an operation is canceled either because of a timeout or an abort, a\n",(0,o.jsx)(n.code,{children:"CancellationError"})," is thrown."]}),"\n",(0,o.jsx)(n.h2,{id:"scopes",children:"Scopes"}),"\n",(0,o.jsxs)(n.p,{children:["The Compute Engine supports\n",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Scope_(computer_science)",children:"lexical scoping"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"A scope includes a symbol table, which is a collection of definitions for\nsymbols and functions."}),"\n",(0,o.jsxs)(n.p,{children:["Scopes are arranged in a stack, with the current (top-most) scope available with\n",(0,o.jsx)(n.code,{children:"ce.context"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"To locate the definition of an identifier, the symbol table associated with the\ncurrent (top-most) scope is searched first. If no matching definition is found,\nthe parent scope is searched, and so on until a definition is found."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"To add a new scope to the context"})," use ",(0,o.jsx)(n.code,{children:"ce.pushScope()"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"ce.pushScope();\nce.assign('x', 500); // \"x\" is defined in the new scope\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"To exit a scope"})," use ",(0,o.jsx)(n.code,{children:"ce.popScope()"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"This will invalidate any definition associated with the scope, and restore the\nsymbol table from previous scopes that may have been shadowed by the current\nscope."}),"\n",(0,o.jsx)(n.h2,{id:"binding",children:"Binding"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.strong,{children:[(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Name_binding",children:"Name Binding"})," is the process of\nassociating an identifier (the name of a function or symbol) with a\ndefinition."]})}),"\n",(0,o.jsxs)(n.p,{children:["Name Binding should not be confused with ",(0,o.jsx)(n.strong,{children:"value binding"})," with is the process\nof associating a ",(0,o.jsx)(n.strong,{children:"value"})," to a symbol."]}),"\n",(0,o.jsxs)(a,{path:"/compute-engine/guides/symbols/#scopes",children:["Read more about\n",(0,o.jsx)("strong",{children:"identifiers"})," and value binding.",(0,o.jsx)(t,{name:"chevron-right-bold"})]}),"\n",(0,o.jsx)(n.p,{children:"For symbols, the definition records contain information such as the type of\nthe symbol and its value. For functions, the definition record include the\nsignature of the function (the type of the argument it expects), and how to\nsimplify or evaluate function expressions that have this function as their head."}),"\n",(0,o.jsxs)(n.p,{children:["Name binding is done during canonicalization. If name binding failed, the\n",(0,o.jsx)(n.code,{children:"isValid"})," property of the expession is ",(0,o.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"To get a list of the errors in an expression"})," use the ",(0,o.jsx)(n.code,{children:"expr.errors"})," property."]}),"\n",(0,o.jsxs)(a,{path:"/compute-engine/guides/expressions/#errors",children:[" Read more about the\n",(0,o.jsx)("strong",{children:"errors"})," ",(0,o.jsx)(t,{name:"chevron-right-bold"})]}),"\n",(0,o.jsx)(n.h2,{id:"evaluation-loop",children:"Evaluation Loop"}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:"This is an advanced topic. You don't need to know the details of how the\nevaluation loop works, unless you're interested in extending the standard\nlibrary and providing your own function definitions."})}),"\n",(0,o.jsxs)(n.p,{children:["Each identifier (name of symbol or function) is ",(0,o.jsx)(n.strong,{children:"bound"})," to a definition within\na ",(0,o.jsx)(n.strong,{children:"scope"})," during canonicalization. This usually happens when calling\n",(0,o.jsx)(n.code,{children:"ce.box()"})," or ",(0,o.jsx)(n.code,{children:"ce.parse()"}),", but could also happen during ",(0,o.jsx)(n.code,{children:"expr.evaluate()"})," if\n",(0,o.jsx)(n.code,{children:"expr"})," was not canonical."]}),"\n",(0,o.jsx)(n.p,{children:"When a function is evaluated, the following steps are followed:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"If the expression is not canonical, it is put in canonical form"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Each argument of the function are evaluated, left to right."}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["An argument can be ",(0,o.jsx)(n.strong,{children:"held"}),", in which case it is not evaluated. Held\narguments can be useful when you need to pass a symbolic expression to a\nfunction. If it wasn't held, the result of evaluating the expression would\nbe used, not the symbolic expression."]}),"\n",(0,o.jsx)(n.p,{children:"A function definition can indicate that one or more of its arguments\nshould be held."}),"\n",(0,o.jsxs)(n.p,{children:["Alternatively, using the ",(0,o.jsx)(n.code,{children:"Hold"})," function will prevent its argument from\nbeing evaluated. Conversely, the ",(0,o.jsx)(n.code,{children:"ReleaseHold"})," function will force an\nevaluation."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["If an argument is a ",(0,o.jsx)(n.code,{children:'["Sequence"]'})," expression, treat each argument of the\nsequence expression as if it was an argument of the function. If the\nsequence is empty, ignore the argument."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"If the function is associative, flatten its arguments as necessary. \\[\nf(f(a, b), c) \\to f(a, b, c) \\]"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Apply the function to the arguments"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Return the canonical form of the result"}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}function h(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const o={},s=t.createContext(o);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);