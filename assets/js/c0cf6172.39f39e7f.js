"use strict";(globalThis.webpackChunkcortexjs_io=globalThis.webpackChunkcortexjs_io||[]).push([[4437],{1051(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"compute-engine/guide-patterns-and-rules","title":"Patterns and Rules","description":"Recognizing patterns and applying rules is a powerful symbolic computing tool to","source":"@site/docs/compute-engine/15-guide-patterns-and-rules.md","sourceDirName":"compute-engine","slug":"/compute-engine/guides/patterns-and-rules/","permalink":"/compute-engine/guides/patterns-and-rules/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1746803465000,"sidebarPosition":15,"frontMatter":{"title":"Patterns and Rules","slug":"/compute-engine/guides/patterns-and-rules/"},"sidebar":"docSidebar","previous":{"title":"Assumptions","permalink":"/compute-engine/guides/assumptions/"},"next":{"title":"MathJSON Format","permalink":"/math-json/"}}');var i=t(4848),r=t(8453);const c={title:"Patterns and Rules",slug:"/compute-engine/guides/patterns-and-rules/"},a=void 0,o={},d=[{value:"Wildcards",id:"wildcards",level:2},{value:"Patterns",id:"patterns",level:2},{value:"Matching an Expression to a Pattern",id:"matching-an-expression-to-a-pattern",level:2},{value:"Commutativity",id:"commutativity",level:3},{value:"Exact Matching",id:"exact-matching",level:3},{value:"Recursive Matching",id:"recursive-matching",level:3},{value:"Repeated Named Wildcards",id:"repeated-named-wildcards",level:3},{value:"Capturing the Head of Functions",id:"capturing-the-head-of-functions",level:3},{value:"Substitution",id:"substitution",level:2},{value:"Applying Rewrite Rules",id:"applying-rewrite-rules",level:2},{value:"Simplifying an Expression",id:"simplifying-an-expression",level:3},{value:"Substituting Symbols",id:"substituting-symbols",level:3}];function l(e){const n={code:"code","code-playground":"code-playground",div:"div",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},t=n["code-playground"];return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Recognizing patterns and applying rules is a powerful symbolic computing tool to\nidentify and manipulate the structure of expressions."}),"\n",(0,i.jsx)(n.h2,{id:"wildcards",children:"Wildcards"}),"\n",(0,i.jsxs)(n.p,{children:["Wildcards are placeholders symbols in an expression. They start with a ",(0,i.jsx)(n.code,{children:"_"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:'"_"'})," universal wildcard matches anything that is in the corresponding\nposition in an expression."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:'"__"'})," wildcard matches any sequence of 1 or more expressions in its\ncorresponding position. It is useful to capture the arguments of a function."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:'"___"'})," wildcard matches any sequence of 0 or more expressions in its\ncorresponding position."]}),"\n",(0,i.jsxs)(n.p,{children:["A wildcard symbol may include a name which is used to ",(0,i.jsx)(n.strong,{children:"capture"})," the matching\nexpression, for example ",(0,i.jsx)(n.code,{children:"_a"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["When using a named wildcard, all instances of the named wildcard must match. In contrast, an un-named wildcard\n(a universal wildcard such as ",(0,i.jsx)(n.code,{children:'"_"'})," ",(0,i.jsx)(n.code,{children:'"__"'})," or ",(0,i.jsx)(n.code,{children:'"___"'}),") can be used multiple\ntimes to match different values."]}),"\n",(0,i.jsx)(n.h2,{id:"patterns",children:"Patterns"}),"\n",(0,i.jsx)(n.p,{children:"A pattern is an expression which can include one or more placeholders in the\nform of wildcards."}),"\n",(0,i.jsx)(n.p,{children:"Patterns are similar to Regular Expressions in traditional programming languages\nbut they are tailored to deal with MathJSON expressions instead of strings."}),"\n",(0,i.jsx)(n.p,{children:"Given a pattern and an expression the goal of pattern matching is to find a\nsubstitution for all the wildcards such that the pattern becomes the expression."}),"\n",(0,i.jsxs)(n.p,{children:["An expression is said to match a pattern if there exists a set of values such\nthat replacing the wildcards with those values is equal to the expression.\nThis set of values is called a ",(0,i.jsx)(n.strong,{children:"substitution"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, the pattern ",(0,i.jsx)(n.code,{children:'["Add", 3, "_c"]'})," becomes the expression\n",(0,i.jsx)(n.code,{children:'["Add", 3, "x"]'})," by replacing the wildcard ",(0,i.jsx)(n.code,{children:'"_c"'})," with ",(0,i.jsx)(n.code,{children:'"x"'}),". The substitution\nis therefore ",(0,i.jsx)(n.code,{children:'{_c : "x"}'}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["On the other hand, the expression ",(0,i.jsx)(n.code,{children:'["Divide", "x", 2]'})," does not match the\npattern ",(0,i.jsx)(n.code,{children:'["Add", 3, "_c"]'}),": no substitution exists to transform the pattern\ninto the expression by substituting the wildcards."]}),"\n",(0,i.jsx)(n.h2,{id:"matching-an-expression-to-a-pattern",children:"Matching an Expression to a Pattern"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To check if an expression matches a pattern"}),", use the\n",(0,i.jsx)(n.code,{children:"_expression_.match(_pattern_)"})," method."]}),"\n",(0,i.jsxs)(n.p,{children:["If there is no match, the method returns ",(0,i.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["If there is a match, a ",(0,i.jsx)(n.code,{children:"Substitution"})," object literal with\nkeys corresponding to the matching named wildcards is returned."]}),"\n",(0,i.jsx)(n.p,{children:"If no named wildcards are used and there is a match, an empty object literal\nis returned."}),"\n",(0,i.jsxs)(n.p,{children:["For convenience, the ",(0,i.jsx)(n.em,{children:"pattern"})," argument can be an unboxed MathJSON expression."]}),"\n",(0,i.jsx)(n.h3,{id:"commutativity",children:"Commutativity"}),"\n",(0,i.jsx)(n.p,{children:"The commutativity of functions is taken into account when matching patterns."}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['const pattern = ce.box(["Add", "_", "x"]);\n','console.log("x+1 \u2794", ce.box(["Add", 1, "x"]).match(pattern));\n',"// \u2794 { } : the expression matches the pattern\n","\n",'console.log("x+42 \u2794", ce.box(["Add", "x", 42]).match(pattern));\n',"// \u2794 { } : the expression matches the pattern by commutativity\n","\n",'console.log("5*x \u2794", ce.box(["Multiply", 5, "x"]).match(pattern));\n',"// \u2794 null : the expression does not match the pattern\n"]})}),"\n",(0,i.jsx)(n.h3,{id:"exact-matching",children:"Exact Matching"}),"\n",(0,i.jsxs)(n.p,{children:["By default, the ",(0,i.jsx)(n.code,{children:"expr.match()"})," method will match some variants of the same\nexpression, for example ",(0,i.jsx)(n.code,{children:"x+_a"})," and ",(0,i.jsx)(n.code,{children:"x"})," are considered to match (with the\nsubstitution ",(0,i.jsx)(n.code,{children:"{_a : 0}"}),")."]}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['const pattern = ce.box(["Add", "x", "_a"]);\n','const expr = ce.box("x");\n',"\n",'console.log("x \u2794", expr.match(pattern));\n',"// \u2794 { _a: 0 } : the expression matches the pattern\n"]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To prevent the matching of variants"}),", set the ",(0,i.jsx)(n.code,{children:"exact"})," property to ",(0,i.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['const pattern = ce.box(["Add", "x", "_a"]);\n','const expr = ce.box("x");\n',"\n",'console.log("exact: x \u2794", expr.match(pattern, {exact: true}));\n',"// \u2794 null : the expression does not match the pattern\n"]})}),"\n",(0,i.jsx)(n.p,{children:"The variants can be applied to the whole expression or to sub-expressions."}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['const pattern = ce.box(["Add", ["Multiply", "_a", "x"], "_b"]);\n',"\n",'console.log("x \u2794", ce.box("x").match(pattern));\n',"// \u2794 { _a: 1, _b: 0 } : the expression matches the pattern\n"]})}),"\n",(0,i.jsx)(n.h3,{id:"recursive-matching",children:"Recursive Matching"}),"\n",(0,i.jsxs)(n.p,{children:["By default, the ",(0,i.jsx)(n.code,{children:"expr.match()"})," method does not consider sub-expressions:\nit is not recursive."]}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['const pattern = ce.box(["Add", "_", "x"]);\n','const expr = ce.box(["Multiply", 2, ["Add", 1, "x"]]);\n',"\n",'console.log("2(1+x) \u2794", expr.match(pattern));\n',"// \u2794 null : the expression does not match the pattern\n"]})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To match sub-expressions recursively"}),", set the ",(0,i.jsx)(n.code,{children:"recursive"})," property to\n",(0,i.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['const pattern = ce.box(["Add", "_", "x"]);\n','const expr = ce.box(["Multiply", 2, ["Add", 1, "x"]]);\n',"\n",'console.log("recursive: 2(1+x) \u2794", expr.match(pattern, {recursive: true}));\n',"// \u2794 { } : the expression matches the pattern\n"]})}),"\n",(0,i.jsx)(n.h3,{id:"repeated-named-wildcards",children:"Repeated Named Wildcards"}),"\n",(0,i.jsx)(n.p,{children:"If a named wildcard is referenced multiple times in a pattern, all its values\nmust match."}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['console.log(ce.box(["Add", 1, "x"]).match(ce.box(["Add", \'_a\', \'_a\'])));\n',"// \u2794 null\n","\n",'console.log(ce.box(["Add", "x", "x"]).match(ce.box(["Add", \'_a\', \'_a\'])));\n','// \u2794 { _a: "x" }\n']})}),"\n",(0,i.jsx)(n.h3,{id:"capturing-the-head-of-functions",children:"Capturing the Head of Functions"}),"\n",(0,i.jsx)(n.p,{children:"Wildcards can be used to capture the head of functions:"}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['console.log(ce.box(["Add", 1, "x"]).match(ce.box(["_f", "__args"])));\n','// \u2794 { _f: "Add", __args: ["Sequence", [1, "x"]] }\n']})}),"\n",(0,i.jsx)(n.h2,{id:"substitution",children:"Substitution"}),"\n",(0,i.jsxs)(n.p,{children:["The return value of the ",(0,i.jsx)(n.code,{children:"expr.match()"})," function is a ",(0,i.jsx)(n.code,{children:"Substitution"})," object: a\nmapping from wildcards to expressions."]}),"\n",(0,i.jsxs)(n.p,{children:["If there is no match, ",(0,i.jsx)(n.code,{children:"expr.match()"})," returns ",(0,i.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To apply a substitution to a pattern"}),", and therefore recover the expression\nit was derived from, use the ",(0,i.jsx)(n.code,{children:"subs()"})," function."]}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['const expr = ce.box(["Add", 1, "x"]);\n','const pattern = ce.box(["Add", 1, "_a"]);\n',"const subs = expr.match(pattern);\n","console.log(subs);\n",'// \u2794 { _a: "x" }\n',"\n","pattern.subs(subs).print();\n",'// \u2794 ["Add", 1, "x"]\n']})}),"\n",(0,i.jsx)(n.h2,{id:"applying-rewrite-rules",children:"Applying Rewrite Rules"}),"\n",(0,i.jsx)(n.p,{children:"A rewrite rule is an object with three properties:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"match"}),": a matching pattern"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"replace"}),": a substitution pattern"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"condition"}),": an optional condition predicate"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To apply a set of rules to an expression"}),", call the ",(0,i.jsx)(n.code,{children:"expr.replace()"}),"\nfunction."]}),"\n",(0,i.jsx)(n.p,{children:"Each rule in the ruleset is applied to the expression in turn. If a rule\nmatches, the expression is replaced by the substitution pattern of the rule."}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:["const squareRule = {\n","  ",'match: ["Multiply", "_x", "_x"],\n',"  ",'replace: ["Square", "_x"],\n',"};\n","\n",'const expr = ce.box(["Multiply", 7, 7], { canonical: false });\n',"(expr.replace(squareRule) ?? expr).print();\n",'// \u2794 ["Square", 7]\n']})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"expr.replace()"})," function continues applying all the rules in the ruleset\nuntil no rules are applicable."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"expr"})," is not canonical, the result of the replace operation is not\ncanonical either."]}),"\n",(0,i.jsx)(n.h3,{id:"simplifying-an-expression",children:"Simplifying an Expression"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"expr.simplify()"})," function applies a collection of built-in rewrite rules."]}),"\n",(0,i.jsxs)(n.p,{children:["You can define your own rules and apply them using ",(0,i.jsx)(n.code,{children:"expr.replace()"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"substituting-symbols",children:"Substituting Symbols"}),"\n",(0,i.jsxs)(n.p,{children:["If a pattern does not contain any named wildcards and only symbols, the\n",(0,i.jsx)(n.code,{children:"expr.subs()"})," function can be used to replace all occurrences of matching symbols."]}),"\n",(0,i.jsx)(t,{children:(0,i.jsxs)(n.div,{slot:"javascript",children:['const expr = ce.box(["Add", ["Multiply", "a", "x"], "b"]);\n',"\n","expr.replace([\n","    ",'{ match: "a", replace: 2 },\n',"    ",'{ match: "b", replace: 3 }\n',"  ","],\n","  ","{ recursive: true }\n",")?.print();\n","// \u2794 2x + 3\n","\n",'expr.subs({"a": 2, "b": 3}).print();\n',"// \u2794 2x + 3\n"]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453(e,n,t){t.d(n,{R:()=>c,x:()=>a});var s=t(6540);const i={},r=s.createContext(i);function c(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);