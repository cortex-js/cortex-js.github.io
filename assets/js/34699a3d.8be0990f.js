"use strict";(globalThis.webpackChunkcortexjs_io=globalThis.webpackChunkcortexjs_io||[]).push([[1354],{5983(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>t});const i=JSON.parse('{"id":"compute-engine/api","title":"Compute Engine API Reference","description":"Compute Engine","source":"@site/docs/compute-engine/api.md","sourceDirName":"compute-engine","slug":"/compute-engine/api/","permalink":"/compute-engine/api/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1769648952000,"frontMatter":{"title":"Compute Engine API Reference","sidebar_label":"API Reference","slug":"/compute-engine/api/","toc_max_heading_level":3},"sidebar":"docSidebar","previous":{"title":"MathJSON Format","permalink":"/math-json/"},"next":{"title":"MathJSON Standard Library","permalink":"/compute-engine/standard-library/"}}');var r=s(4848),l=s(8453);s(6540);var d=s(7471);const a={title:"Compute Engine API Reference",sidebar_label:"API Reference",slug:"/compute-engine/api/",toc_max_heading_level:3},o="Compute Engine API Reference",c={},t=[{value:"Compute Engine",id:"compute-engine",level:2},{value:"AngularUnit",id:"angularunit",level:3},{value:"AssignValue",id:"assignvalue",level:3},{value:"EvalContext",id:"evalcontext",level:3},{value:"Boxed Expression",id:"boxed-expression",level:2},{value:"BoxedExpression",id:"boxedexpression",level:3},{value:"<code>ce.box()</code> and <code>ce.parse()</code>",id:"cebox-and-ceparse",level:4},{value:"<code>ce.function()</code>",id:"cefunction",level:4},{value:"Algebraic methods (<code>expr.add()</code>, <code>expr.mul()</code>, etc...)",id:"algebraic-methods-expradd-exprmul-etc",level:4},{value:"<code>ce._fn()</code>",id:"ce_fn",level:4},{value:"Canonical Handlers",id:"canonical-handlers",level:4},{value:"Function Expression",id:"function-expression",level:4},{value:"BoxedExpression.isFunctionExpression",id:"boxedexpressionisfunctionexpression",level:5},{value:"BoxedExpression.operator",id:"boxedexpressionoperator",level:5},{value:"BoxedExpression.ops",id:"boxedexpressionops",level:5},{value:"BoxedExpression.nops",id:"boxedexpressionnops",level:5},{value:"BoxedExpression.op1",id:"boxedexpressionop1",level:5},{value:"BoxedExpression.op2",id:"boxedexpressionop2",level:5},{value:"BoxedExpression.op3",id:"boxedexpressionop3",level:5},{value:"Numeric Expression",id:"numeric-expression",level:4},{value:"BoxedExpression.isNumberLiteral",id:"boxedexpressionisnumberliteral",level:5},{value:"BoxedExpression.numericValue",id:"boxedexpressionnumericvalue",level:5},{value:"BoxedExpression.isEven",id:"boxedexpressioniseven",level:5},{value:"BoxedExpression.isOdd",id:"boxedexpressionisodd",level:5},{value:"BoxedExpression.re",id:"boxedexpressionre",level:5},{value:"BoxedExpression.im",id:"boxedexpressionim",level:5},{value:"BoxedExpression.bignumRe",id:"boxedexpressionbignumre",level:5},{value:"BoxedExpression.bignumIm",id:"boxedexpressionbignumim",level:5},{value:"BoxedExpression.sgn",id:"boxedexpressionsgn",level:5},{value:"BoxedExpression.isPositive",id:"boxedexpressionispositive",level:5},{value:"BoxedExpression.isNonNegative",id:"boxedexpressionisnonnegative",level:5},{value:"BoxedExpression.isNegative",id:"boxedexpressionisnegative",level:5},{value:"BoxedExpression.isNonPositive",id:"boxedexpressionisnonpositive",level:5},{value:"BoxedExpression.isNaN",id:"boxedexpressionisnan",level:5},{value:"BoxedExpression.isInfinity",id:"boxedexpressionisinfinity",level:5},{value:"BoxedExpression.isFinite",id:"boxedexpressionisfinite",level:5},{value:"Other",id:"other",level:4},{value:"BoxedExpression.engine",id:"boxedexpressionengine",level:5},{value:"BoxedExpression.toLatex()",id:"boxedexpressiontolatex",level:5},{value:"BoxedExpression.latex",id:"boxedexpressionlatex",level:5},{value:"BoxedExpression.toMathJson()",id:"boxedexpressiontomathjson",level:5},{value:"BoxedExpression.json",id:"boxedexpressionjson",level:5},{value:"BoxedExpression.print()",id:"boxedexpressionprint",level:5},{value:"BoxedExpression.verbatimLatex?",id:"boxedexpressionverbatimlatex",level:5},{value:"BoxedExpression.isCanonical",id:"boxedexpressioniscanonical",level:5},{value:"BoxedExpression.isStructural",id:"boxedexpressionisstructural",level:5},{value:"BoxedExpression.canonical",id:"boxedexpressioncanonical",level:5},{value:"BoxedExpression.structural",id:"boxedexpressionstructural",level:5},{value:"BoxedExpression.isValid",id:"boxedexpressionisvalid",level:5},{value:"BoxedExpression.isPure",id:"boxedexpressionispure",level:5},{value:"BoxedExpression.isConstant",id:"boxedexpressionisconstant",level:5},{value:"BoxedExpression.errors",id:"boxedexpressionerrors",level:5},{value:"BoxedExpression.getSubexpressions()",id:"boxedexpressiongetsubexpressions",level:5},{value:"BoxedExpression.subexpressions",id:"boxedexpressionsubexpressions",level:5},{value:"BoxedExpression.symbols",id:"boxedexpressionsymbols",level:5},{value:"BoxedExpression.unknowns",id:"boxedexpressionunknowns",level:5},{value:"BoxedExpression.toNumericValue()",id:"boxedexpressiontonumericvalue",level:5},{value:"BoxedExpression.neg()",id:"boxedexpressionneg",level:5},{value:"BoxedExpression.inv()",id:"boxedexpressioninv",level:5},{value:"BoxedExpression.abs()",id:"boxedexpressionabs",level:5},{value:"BoxedExpression.add()",id:"boxedexpressionadd",level:5},{value:"BoxedExpression.sub()",id:"boxedexpressionsub",level:5},{value:"BoxedExpression.mul()",id:"boxedexpressionmul",level:5},{value:"BoxedExpression.div()",id:"boxedexpressiondiv",level:5},{value:"BoxedExpression.pow()",id:"boxedexpressionpow",level:5},{value:"BoxedExpression.root()",id:"boxedexpressionroot",level:5},{value:"BoxedExpression.sqrt()",id:"boxedexpressionsqrt",level:5},{value:"BoxedExpression.ln()",id:"boxedexpressionln",level:5},{value:"BoxedExpression.numerator",id:"boxedexpressionnumerator",level:5},{value:"BoxedExpression.denominator",id:"boxedexpressiondenominator",level:5},{value:"BoxedExpression.numeratorDenominator",id:"boxedexpressionnumeratordenominator",level:5},{value:"BoxedExpression.isScoped",id:"boxedexpressionisscoped",level:5},{value:"BoxedExpression.localScope",id:"boxedexpressionlocalscope",level:5},{value:"BoxedExpression.subs()",id:"boxedexpressionsubs",level:5},{value:"BoxedExpression.map()",id:"boxedexpressionmap",level:5},{value:"BoxedExpression.replace()",id:"boxedexpressionreplace",level:5},{value:"BoxedExpression.has()",id:"boxedexpressionhas",level:5},{value:"BoxedExpression.match()",id:"boxedexpressionmatch",level:5},{value:"BoxedExpression.wikidata",id:"boxedexpressionwikidata",level:5},{value:"BoxedExpression.description",id:"boxedexpressiondescription",level:5},{value:"BoxedExpression.url",id:"boxedexpressionurl",level:5},{value:"BoxedExpression.complexity",id:"boxedexpressioncomplexity",level:5},{value:"BoxedExpression.baseDefinition",id:"boxedexpressionbasedefinition",level:5},{value:"BoxedExpression.operatorDefinition",id:"boxedexpressionoperatordefinition",level:5},{value:"BoxedExpression.valueDefinition",id:"boxedexpressionvaluedefinition",level:5},{value:"BoxedExpression.simplify()",id:"boxedexpressionsimplify",level:5},{value:"BoxedExpression.expand()",id:"boxedexpressionexpand",level:5},{value:"BoxedExpression.evaluate()",id:"boxedexpressionevaluate",level:5},{value:"BoxedExpression.evaluateAsync()",id:"boxedexpressionevaluateasync",level:5},{value:"BoxedExpression.N()",id:"boxedexpressionn",level:5},{value:"BoxedExpression.compile()",id:"boxedexpressioncompile",level:5},{value:"BoxedExpression.solve()",id:"boxedexpressionsolve",level:5},{value:"BoxedExpression.value",id:"boxedexpressionvalue",level:5},{value:"BoxedExpression.isCollection",id:"boxedexpressioniscollection",level:5},{value:"BoxedExpression.isIndexedCollection",id:"boxedexpressionisindexedcollection",level:5},{value:"BoxedExpression.isLazyCollection",id:"boxedexpressionislazycollection",level:5},{value:"BoxedExpression.each()",id:"boxedexpressioneach",level:5},{value:"BoxedExpression.contains()",id:"boxedexpressioncontains",level:5},{value:"BoxedExpression.subsetOf()",id:"boxedexpressionsubsetof",level:5},{value:"BoxedExpression.count",id:"boxedexpressioncount",level:5},{value:"BoxedExpression.isFiniteCollection",id:"boxedexpressionisfinitecollection",level:5},{value:"BoxedExpression.isEmptyCollection",id:"boxedexpressionisemptycollection",level:5},{value:"BoxedExpression.at()",id:"boxedexpressionat",level:5},{value:"BoxedExpression.get()",id:"boxedexpressionget",level:5},{value:"BoxedExpression.indexWhere()",id:"boxedexpressionindexwhere",level:5},{value:"Primitive Methods",id:"primitive-methods",level:4},{value:"BoxedExpression.valueOf()",id:"boxedexpressionvalueof",level:5},{value:"BoxedExpression.[toPrimitive]()",id:"boxedexpressiontoprimitive",level:5},{value:"BoxedExpression.toString()",id:"boxedexpressiontostring",level:5},{value:"BoxedExpression.toJSON()",id:"boxedexpressiontojson",level:5},{value:"BoxedExpression.is()",id:"boxedexpressionis",level:5},{value:"Relational Operator",id:"relational-operator",level:4},{value:"BoxedExpression.isSame()",id:"boxedexpressionissame",level:5},{value:"BoxedExpression.isLess()",id:"boxedexpressionisless",level:5},{value:"BoxedExpression.isLessEqual()",id:"boxedexpressionislessequal",level:5},{value:"BoxedExpression.isGreater()",id:"boxedexpressionisgreater",level:5},{value:"BoxedExpression.isGreaterEqual()",id:"boxedexpressionisgreaterequal",level:5},{value:"BoxedExpression.isEqual()",id:"boxedexpressionisequal",level:5},{value:"String Expression",id:"string-expression",level:4},{value:"BoxedExpression.string",id:"boxedexpressionstring",level:5},{value:"Symbol Expression",id:"symbol-expression",level:4},{value:"BoxedExpression.symbol",id:"boxedexpressionsymbol",level:5},{value:"Tensor Expression",id:"tensor-expression",level:4},{value:"BoxedExpression.tensor",id:"boxedexpressiontensor",level:5},{value:"BoxedExpression.shape",id:"boxedexpressionshape",level:5},{value:"BoxedExpression.rank",id:"boxedexpressionrank",level:5},{value:"Type Properties",id:"type-properties",level:4},{value:"BoxedExpression.type",id:"boxedexpressiontype",level:5},{value:"BoxedExpression.isNumber",id:"boxedexpressionisnumber",level:5},{value:"BoxedExpression.isInteger",id:"boxedexpressionisinteger",level:5},{value:"BoxedExpression.isRational",id:"boxedexpressionisrational",level:5},{value:"BoxedExpression.isReal",id:"boxedexpressionisreal",level:5},{value:"SemiBoxedExpression",id:"semiboxedexpression",level:3},{value:"ReplaceOptions",id:"replaceoptions",level:3},{value:"SimplifyOptions",id:"simplifyoptions",level:3},{value:"CanonicalForm",id:"canonicalform",level:3},{value:"CanonicalOptions",id:"canonicaloptions",level:3},{value:"EvaluateOptions",id:"evaluateoptions",level:3},{value:"Metadata",id:"metadata",level:3},{value:"Pattern Matching",id:"pattern-matching",level:2},{value:"PatternMatchOptions",id:"patternmatchoptions",level:3},{value:"Wildcards",id:"wildcards",level:3},{value:"Options",id:"options",level:3},{value:"Substitution",id:"substitution",level:3},{value:"Type Parameters",id:"type-parameters",level:4},{value:"BoxedSubstitution",id:"boxedsubstitution",level:3},{value:"Rules",id:"rules",level:2},{value:"RuleReplaceFunction()",id:"rulereplacefunction",level:3},{value:"RuleConditionFunction()",id:"ruleconditionfunction",level:3},{value:"RuleFunction()",id:"rulefunction",level:3},{value:"RuleStep",id:"rulestep",level:3},{value:"RuleSteps",id:"rulesteps",level:3},{value:"Rule",id:"rule",level:3},{value:"BoxedRule",id:"boxedrule",level:3},{value:"BoxedRuleSet",id:"boxedruleset",level:3},{value:"Assumptions",id:"assumptions",level:2},{value:"Assumption",id:"assumption",level:3},{value:"Assumption.isPositive",id:"assumptionispositive",level:5},{value:"Assumption.isNonNegative",id:"assumptionisnonnegative",level:5},{value:"Assumption.isNegative",id:"assumptionisnegative",level:5},{value:"Assumption.isNonPositive",id:"assumptionisnonpositive",level:5},{value:"Assumption.isNumber",id:"assumptionisnumber",level:5},{value:"Assumption.isInteger",id:"assumptionisinteger",level:5},{value:"Assumption.isRational",id:"assumptionisrational",level:5},{value:"Assumption.isReal",id:"assumptionisreal",level:5},{value:"Assumption.isComplex",id:"assumptioniscomplex",level:5},{value:"Assumption.isImaginary",id:"assumptionisimaginary",level:5},{value:"Assumption.isFinite",id:"assumptionisfinite",level:5},{value:"Assumption.isInfinite",id:"assumptionisinfinite",level:5},{value:"Assumption.isNaN",id:"assumptionisnan",level:5},{value:"Assumption.isZero",id:"assumptioniszero",level:5},{value:"Assumption.matches()",id:"assumptionmatches",level:5},{value:"Assumption.isGreater()",id:"assumptionisgreater",level:5},{value:"Assumption.isGreaterEqual()",id:"assumptionisgreaterequal",level:5},{value:"Assumption.isLess()",id:"assumptionisless",level:5},{value:"Assumption.isLessEqual()",id:"assumptionislessequal",level:5},{value:"Assumption.isEqual()",id:"assumptionisequal",level:5},{value:"Assumption.toExpression()",id:"assumptiontoexpression",level:5},{value:"ExpressionMapInterface",id:"expressionmapinterface",level:3},{value:"ExpressionMapInterface.has()",id:"expressionmapinterfacehas",level:5},{value:"ExpressionMapInterface.get()",id:"expressionmapinterfaceget",level:5},{value:"ExpressionMapInterface.set()",id:"expressionmapinterfaceset",level:5},{value:"ExpressionMapInterface.delete()",id:"expressionmapinterfacedelete",level:5},{value:"ExpressionMapInterface.clear()",id:"expressionmapinterfaceclear",level:5},{value:"ExpressionMapInterface.[iterator]()",id:"expressionmapinterfaceiterator",level:5},{value:"ExpressionMapInterface.entries()",id:"expressionmapinterfaceentries",level:5},{value:"AssumeResult",id:"assumeresult",level:3},{value:"Compiling",id:"compiling",level:2},{value:"CompiledType",id:"compiledtype",level:3},{value:"JSSource",id:"jssource",level:3},{value:"CompiledExpression",id:"compiledexpression",level:3},{value:"Definitions",id:"definitions",level:2},{value:"EqHandlers",id:"eqhandlers",level:3},{value:"EqHandlers.eq()",id:"eqhandlerseq",level:5},{value:"EqHandlers.neq()",id:"eqhandlersneq",level:5},{value:"Hold",id:"hold",level:3},{value:"ValueDefinition",id:"valuedefinition",level:3},{value:"ValueDefinition.inferred",id:"valuedefinitioninferred",level:4},{value:"ValueDefinition.value",id:"valuedefinitionvalue",level:4},{value:"OperatorDefinition",id:"operatordefinition",level:3},{value:"OperatorDefinition.signature?",id:"operatordefinitionsignature",level:4},{value:"OperatorDefinition.type()?",id:"operatordefinitiontype",level:4},{value:"OperatorDefinition.sgn()?",id:"operatordefinitionsgn",level:4},{value:"OperatorDefinition.isPositive?",id:"operatordefinitionispositive",level:4},{value:"OperatorDefinition.isNonNegative?",id:"operatordefinitionisnonnegative",level:4},{value:"OperatorDefinition.isNegative?",id:"operatordefinitionisnegative",level:4},{value:"OperatorDefinition.isNonPositive?",id:"operatordefinitionisnonpositive",level:4},{value:"OperatorDefinition.even()?",id:"operatordefinitioneven",level:4},{value:"OperatorDefinition.complexity?",id:"operatordefinitioncomplexity",level:4},{value:"OperatorDefinition.canonical()?",id:"operatordefinitioncanonical",level:4},{value:"OperatorDefinition.evaluate?",id:"operatordefinitionevaluate",level:4},{value:"OperatorDefinition.evaluateAsync()?",id:"operatordefinitionevaluateasync",level:4},{value:"OperatorDefinition.evalDimension()?",id:"operatordefinitionevaldimension",level:4},{value:"OperatorDefinition.xcompile()?",id:"operatordefinitionxcompile",level:4},{value:"BaseDefinition",id:"basedefinition",level:3},{value:"BaseDefinition.description",id:"basedefinitiondescription",level:5},{value:"BaseDefinition.examples",id:"basedefinitionexamples",level:5},{value:"BaseDefinition.url",id:"basedefinitionurl",level:5},{value:"BaseDefinition.wikidata",id:"basedefinitionwikidata",level:5},{value:"BaseDefinition.isConstant?",id:"basedefinitionisconstant",level:5},{value:"SymbolDefinition",id:"symboldefinition",level:3},{value:"SymbolDefinitions",id:"symboldefinitions",level:3},{value:"BaseCollectionHandlers",id:"basecollectionhandlers",level:3},{value:"Definitions",id:"definitions-1",level:4},{value:"BaseCollectionHandlers.iterator()",id:"basecollectionhandlersiterator",level:5},{value:"Other",id:"other-1",level:4},{value:"BaseCollectionHandlers.count()",id:"basecollectionhandlerscount",level:5},{value:"BaseCollectionHandlers.isEmpty()?",id:"basecollectionhandlersisempty",level:5},{value:"BaseCollectionHandlers.isFinite()?",id:"basecollectionhandlersisfinite",level:5},{value:"BaseCollectionHandlers.isLazy()?",id:"basecollectionhandlersislazy",level:5},{value:"BaseCollectionHandlers.contains()?",id:"basecollectionhandlerscontains",level:5},{value:"BaseCollectionHandlers.subsetOf()?",id:"basecollectionhandlerssubsetof",level:5},{value:"BaseCollectionHandlers.eltsgn()?",id:"basecollectionhandlerseltsgn",level:5},{value:"BaseCollectionHandlers.elttype()?",id:"basecollectionhandlerselttype",level:5},{value:"IndexedCollectionHandlers",id:"indexedcollectionhandlers",level:3},{value:"IndexedCollectionHandlers.at()",id:"indexedcollectionhandlersat",level:5},{value:"IndexedCollectionHandlers.indexWhere()",id:"indexedcollectionhandlersindexwhere",level:5},{value:"CollectionHandlers",id:"collectionhandlers",level:3},{value:"TaggedValueDefinition",id:"taggedvaluedefinition",level:3},{value:"TaggedOperatorDefinition",id:"taggedoperatordefinition",level:3},{value:"BoxedDefinition",id:"boxeddefinition",level:3},{value:"BoxedBaseDefinition",id:"boxedbasedefinition",level:3},{value:"Extends",id:"extends",level:4},{value:"Extended by",id:"extended-by",level:4},{value:"BoxedBaseDefinition.collection?",id:"boxedbasedefinitioncollection",level:5},{value:"BoxedValueDefinition",id:"boxedvaluedefinition",level:3},{value:"Extends",id:"extends-1",level:4},{value:"BoxedValueDefinition.holdUntil",id:"boxedvaluedefinitionholduntil",level:5},{value:"BoxedValueDefinition.value",id:"boxedvaluedefinitionvalue",level:5},{value:"BoxedValueDefinition.eq()?",id:"boxedvaluedefinitioneq",level:5},{value:"BoxedValueDefinition.neq()?",id:"boxedvaluedefinitionneq",level:5},{value:"BoxedValueDefinition.cmp()?",id:"boxedvaluedefinitioncmp",level:5},{value:"BoxedValueDefinition.inferredType",id:"boxedvaluedefinitioninferredtype",level:5},{value:"BoxedValueDefinition.type",id:"boxedvaluedefinitiontype",level:5},{value:"OperatorDefinitionFlags",id:"operatordefinitionflags",level:3},{value:"BoxedOperatorDefinition",id:"boxedoperatordefinition",level:3},{value:"Extends",id:"extends-2",level:4},{value:"BoxedOperatorDefinition.complexity",id:"boxedoperatordefinitioncomplexity",level:5},{value:"BoxedOperatorDefinition.inferredSignature",id:"boxedoperatordefinitioninferredsignature",level:5},{value:"BoxedOperatorDefinition.signature",id:"boxedoperatordefinitionsignature",level:5},{value:"BoxedOperatorDefinition.type()?",id:"boxedoperatordefinitiontype",level:5},{value:"BoxedOperatorDefinition.sgn()?",id:"boxedoperatordefinitionsgn",level:5},{value:"BoxedOperatorDefinition.eq()?",id:"boxedoperatordefinitioneq",level:5},{value:"BoxedOperatorDefinition.neq()?",id:"boxedoperatordefinitionneq",level:5},{value:"BoxedOperatorDefinition.canonical()?",id:"boxedoperatordefinitioncanonical",level:5},{value:"BoxedOperatorDefinition.evaluate()?",id:"boxedoperatordefinitionevaluate",level:5},{value:"BoxedOperatorDefinition.evaluateAsync()?",id:"boxedoperatordefinitionevaluateasync",level:5},{value:"BoxedOperatorDefinition.evalDimension()?",id:"boxedoperatordefinitionevaldimension",level:5},{value:"BoxedOperatorDefinition.compile()?",id:"boxedoperatordefinitioncompile",level:5},{value:"Scope",id:"scope",level:3},{value:"Latex Parsing and Serialization",id:"latex-parsing-and-serialization",level:2},{value:"LatexToken",id:"latextoken",level:3},{value:"LatexString",id:"latexstring",level:3},{value:"Delimiter",id:"delimiter",level:3},{value:"DelimiterScale",id:"delimiterscale",level:3},{value:"LibraryCategory",id:"librarycategory",level:3},{value:"Precedence",id:"precedence",level:3},{value:"Operator Precedence Table",id:"operator-precedence-table",level:3},{value:"Key Relationships",id:"key-relationships",level:3},{value:"Terminator",id:"terminator",level:3},{value:"ParseHandler",id:"parsehandler",level:3},{value:"ExpressionParseHandler()",id:"expressionparsehandler",level:3},{value:"PrefixParseHandler()",id:"prefixparsehandler",level:3},{value:"SymbolParseHandler()",id:"symbolparsehandler",level:3},{value:"FunctionParseHandler()",id:"functionparsehandler",level:3},{value:"EnvironmentParseHandler()",id:"environmentparsehandler",level:3},{value:"PostfixParseHandler()",id:"postfixparsehandler",level:3},{value:"InfixParseHandler()",id:"infixparsehandler",level:3},{value:"MatchfixParseHandler()",id:"matchfixparsehandler",level:3},{value:"LatexArgumentType",id:"latexargumenttype",level:3},{value:"Trigger",id:"trigger",level:3},{value:"BaseEntry",id:"baseentry",level:3},{value:"DefaultEntry",id:"defaultentry",level:3},{value:"ExpressionEntry",id:"expressionentry",level:3},{value:"MatchfixEntry",id:"matchfixentry",level:3},{value:"MatchfixEntry.openTrigger",id:"matchfixentryopentrigger",level:4},{value:"MatchfixEntry.parse?",id:"matchfixentryparse",level:4},{value:"InfixEntry",id:"infixentry",level:3},{value:"InfixEntry.kind",id:"infixentrykind",level:4},{value:"InfixEntry.associativity?",id:"infixentryassociativity",level:4},{value:"PostfixEntry",id:"postfixentry",level:3},{value:"PostfixEntry.kind",id:"postfixentrykind",level:4},{value:"PrefixEntry",id:"prefixentry",level:3},{value:"PrefixEntry.kind",id:"prefixentrykind",level:4},{value:"EnvironmentEntry",id:"environmententry",level:3},{value:"SymbolEntry",id:"symbolentry",level:3},{value:"SymbolEntry.precedence?",id:"symbolentryprecedence",level:4},{value:"FunctionEntry",id:"functionentry",level:3},{value:"LatexDictionaryEntry",id:"latexdictionaryentry",level:3},{value:"ParseLatexOptions",id:"parselatexoptions",level:3},{value:"ParseLatexOptions.skipSpace",id:"parselatexoptionsskipspace",level:4},{value:"ParseLatexOptions.parseNumbers",id:"parselatexoptionsparsenumbers",level:4},{value:"ParseLatexOptions.getSymbolType()",id:"parselatexoptionsgetsymboltype",level:4},{value:"ParseLatexOptions.parseUnexpectedToken()",id:"parselatexoptionsparseunexpectedtoken",level:4},{value:"ParseLatexOptions.preserveLatex",id:"parselatexoptionspreservelatex",level:4},{value:"ParseLatexOptions.quantifierScope",id:"parselatexoptionsquantifierscope",level:4},{value:"Example",id:"example",level:5},{value:"Parser",id:"parser",level:3},{value:"Parser.options",id:"parseroptions",level:5},{value:"Parser.index",id:"parserindex",level:5},{value:"Parser.atEnd",id:"parseratend",level:5},{value:"Parser.peek",id:"parserpeek",level:5},{value:"Parser.atBoundary",id:"parseratboundary",level:5},{value:"Parser.getSymbolType()",id:"parsergetsymboltype",level:5},{value:"Parser.pushSymbolTable()",id:"parserpushsymboltable",level:5},{value:"Parser.popSymbolTable()",id:"parserpopsymboltable",level:5},{value:"Parser.addSymbol()",id:"parseraddsymbol",level:5},{value:"Parser.atTerminator()",id:"parseratterminator",level:5},{value:"Parser.nextToken()",id:"parsernexttoken",level:5},{value:"Parser.latex()",id:"parserlatex",level:5},{value:"Parser.error()",id:"parsererror",level:5},{value:"Parser.skipSpace()",id:"parserskipspace",level:5},{value:"Parser.skipVisualSpace()",id:"parserskipvisualspace",level:5},{value:"Parser.match()",id:"parsermatch",level:5},{value:"Parser.matchAll()",id:"parsermatchall",level:5},{value:"Parser.matchAny()",id:"parsermatchany",level:5},{value:"Parser.parseChar()",id:"parserparsechar",level:5},{value:"Parser.parseGroup()",id:"parserparsegroup",level:5},{value:"Parser.parseToken()",id:"parserparsetoken",level:5},{value:"Parser.parseOptionalGroup()",id:"parserparseoptionalgroup",level:5},{value:"Parser.parseEnclosure()",id:"parserparseenclosure",level:5},{value:"Parser.parseStringGroup()",id:"parserparsestringgroup",level:5},{value:"Parser.parseSymbol()",id:"parserparsesymbol",level:5},{value:"Parser.parseTabular()",id:"parserparsetabular",level:5},{value:"Parser.parseArguments()",id:"parserparsearguments",level:5},{value:"Parser.parsePostfixOperator()",id:"parserparsepostfixoperator",level:5},{value:"Parser.parseExpression()",id:"parserparseexpression",level:5},{value:"Parser.parseNumber()",id:"parserparsenumber",level:5},{value:"Parser.addBoundary()",id:"parseraddboundary",level:5},{value:"Parser.removeBoundary()",id:"parserremoveboundary",level:5},{value:"Parser.matchBoundary()",id:"parsermatchboundary",level:5},{value:"Parser.boundaryError()",id:"parserboundaryerror",level:5},{value:"SerializeLatexOptions",id:"serializelatexoptions",level:3},{value:"SerializeLatexOptions.prettify",id:"serializelatexoptionsprettify",level:4},{value:"SerializeLatexOptions.materialization",id:"serializelatexoptionsmaterialization",level:4},{value:"SerializeLatexOptions.invisibleMultiply",id:"serializelatexoptionsinvisiblemultiply",level:4},{value:"SerializeLatexOptions.invisiblePlus",id:"serializelatexoptionsinvisibleplus",level:4},{value:"SerializeLatexOptions.multiply",id:"serializelatexoptionsmultiply",level:4},{value:"SerializeLatexOptions.missingSymbol",id:"serializelatexoptionsmissingsymbol",level:4},{value:"Serializer",id:"serializer",level:3},{value:"Serializer.options",id:"serializeroptions",level:5},{value:"Serializer.dictionary",id:"serializerdictionary",level:5},{value:"Serializer.level",id:"serializerlevel",level:5},{value:"Serializer.serialize()",id:"serializerserialize",level:5},{value:"Serializer.wrap()",id:"serializerwrap",level:5},{value:"Serializer.applyFunctionStyle()",id:"serializerapplyfunctionstyle",level:5},{value:"Serializer.groupStyle()",id:"serializergroupstyle",level:5},{value:"Serializer.rootStyle()",id:"serializerrootstyle",level:5},{value:"Serializer.fractionStyle()",id:"serializerfractionstyle",level:5},{value:"Serializer.logicStyle()",id:"serializerlogicstyle",level:5},{value:"Serializer.powerStyle()",id:"serializerpowerstyle",level:5},{value:"Serializer.numericSetStyle()",id:"serializernumericsetstyle",level:5},{value:"Serializer.serializeFunction()",id:"serializerserializefunction",level:5},{value:"Serializer.serializeSymbol()",id:"serializerserializesymbol",level:5},{value:"Serializer.wrapString()",id:"serializerwrapstring",level:5},{value:"Serializer.wrapArguments()",id:"serializerwraparguments",level:5},{value:"Serializer.wrapShort()",id:"serializerwrapshort",level:5},{value:"SerializeHandler()",id:"serializehandler",level:3},{value:"Numerics",id:"numerics",level:2},{value:"Sign",id:"sign",level:3},{value:"ExactNumericValueData",id:"exactnumericvaluedata",level:3},{value:"NumericValueData",id:"numericvaluedata",level:3},{value:"NumericValueFactory()",id:"numericvaluefactory",level:3},{value:"<code>abstract</code> NumericValue",id:"abstract-numericvalue",level:3},{value:"new NumericValue()",id:"new-numericvalue",level:5},{value:"NumericValue.im",id:"numericvalueim",level:5},{value:"NumericValue.type",id:"numericvaluetype",level:5},{value:"NumericValue.isExact",id:"numericvalueisexact",level:5},{value:"NumericValue.asExact",id:"numericvalueasexact",level:5},{value:"NumericValue.re",id:"numericvaluere",level:5},{value:"NumericValue.bignumRe",id:"numericvaluebignumre",level:5},{value:"NumericValue.bignumIm",id:"numericvaluebignumim",level:5},{value:"NumericValue.numerator",id:"numericvaluenumerator",level:5},{value:"NumericValue.denominator",id:"numericvaluedenominator",level:5},{value:"NumericValue.isNaN",id:"numericvalueisnan",level:5},{value:"NumericValue.isPositiveInfinity",id:"numericvalueispositiveinfinity",level:5},{value:"NumericValue.isNegativeInfinity",id:"numericvalueisnegativeinfinity",level:5},{value:"NumericValue.isComplexInfinity",id:"numericvalueiscomplexinfinity",level:5},{value:"NumericValue.isZero",id:"numericvalueiszero",level:5},{value:"NumericValue.isOne",id:"numericvalueisone",level:5},{value:"NumericValue.isNegativeOne",id:"numericvalueisnegativeone",level:5},{value:"NumericValue.isZeroWithTolerance()",id:"numericvalueiszerowithtolerance",level:5},{value:"NumericValue.sgn()",id:"numericvaluesgn",level:5},{value:"NumericValue.N()",id:"numericvaluen",level:5},{value:"NumericValue.neg()",id:"numericvalueneg",level:5},{value:"NumericValue.inv()",id:"numericvalueinv",level:5},{value:"NumericValue.add()",id:"numericvalueadd",level:5},{value:"NumericValue.sub()",id:"numericvaluesub",level:5},{value:"NumericValue.mul()",id:"numericvaluemul",level:5},{value:"NumericValue.div()",id:"numericvaluediv",level:5},{value:"NumericValue.pow()",id:"numericvaluepow",level:5},{value:"NumericValue.root()",id:"numericvalueroot",level:5},{value:"NumericValue.sqrt()",id:"numericvaluesqrt",level:5},{value:"NumericValue.gcd()",id:"numericvaluegcd",level:5},{value:"NumericValue.abs()",id:"numericvalueabs",level:5},{value:"NumericValue.ln()",id:"numericvalueln",level:5},{value:"NumericValue.exp()",id:"numericvalueexp",level:5},{value:"NumericValue.floor()",id:"numericvaluefloor",level:5},{value:"NumericValue.ceil()",id:"numericvalueceil",level:5},{value:"NumericValue.round()",id:"numericvalueround",level:5},{value:"NumericValue.eq()",id:"numericvalueeq",level:5},{value:"NumericValue.lt()",id:"numericvaluelt",level:5},{value:"NumericValue.lte()",id:"numericvaluelte",level:5},{value:"NumericValue.gt()",id:"numericvaluegt",level:5},{value:"NumericValue.gte()",id:"numericvaluegte",level:5},{value:"NumericValue.valueOf()",id:"numericvaluevalueof",level:5},{value:"NumericValue.[toPrimitive]()",id:"numericvaluetoprimitive",level:5},{value:"NumericValue.toJSON()",id:"numericvaluetojson",level:5},{value:"NumericValue.print()",id:"numericvalueprint",level:5},{value:"SmallInteger",id:"smallinteger",level:3},{value:"Rational",id:"rational",level:3},{value:"BigNum",id:"bignum",level:3},{value:"IBigNum",id:"ibignum",level:3},{value:"IBigNum._BIGNUM_NAN",id:"ibignum_bignum_nan",level:5},{value:"IBigNum._BIGNUM_ZERO",id:"ibignum_bignum_zero",level:5},{value:"IBigNum._BIGNUM_ONE",id:"ibignum_bignum_one",level:5},{value:"IBigNum._BIGNUM_TWO",id:"ibignum_bignum_two",level:5},{value:"IBigNum._BIGNUM_HALF",id:"ibignum_bignum_half",level:5},{value:"IBigNum._BIGNUM_PI",id:"ibignum_bignum_pi",level:5},{value:"IBigNum._BIGNUM_NEGATIVE_ONE",id:"ibignum_bignum_negative_one",level:5},{value:"IBigNum.bignum()",id:"ibignumbignum",level:5},{value:"Other",id:"other-2",level:2},{value:"DictionaryInterface",id:"dictionaryinterface",level:3},{value:"DictionaryInterface.keys",id:"dictionaryinterfacekeys",level:5},{value:"DictionaryInterface.entries",id:"dictionaryinterfaceentries",level:5},{value:"DictionaryInterface.values",id:"dictionaryinterfacevalues",level:5},{value:"DictionaryInterface.get()",id:"dictionaryinterfaceget",level:5},{value:"DictionaryInterface.has()",id:"dictionaryinterfacehas",level:5},{value:"SymbolTable",id:"symboltable",level:3},{value:"BigNumFactory()",id:"bignumfactory",level:3},{value:"Serialization",id:"serialization",level:2},{value:"JsonSerializationOptions",id:"jsonserializationoptions",level:3},{value:"NumberFormat",id:"numberformat",level:3},{value:"NumberSerializationFormat",id:"numberserializationformat",level:3},{value:"NumberSerializationFormat.fractionalDigits",id:"numberserializationformatfractionaldigits",level:4},{value:"Tensors",id:"tensors",level:2},{value:"DataTypeMap",id:"datatypemap",level:3},{value:"TensorDataType",id:"tensordatatype",level:3},{value:"TensorData",id:"tensordata",level:3},{value:"Extended by",id:"extended-by-1",level:4},{value:"TensorData.dtype",id:"tensordatadtype",level:5},{value:"TensorData.shape",id:"tensordatashape",level:5},{value:"TensorData.rank?",id:"tensordatarank",level:5},{value:"TensorData.data",id:"tensordatadata",level:5},{value:"TensorField",id:"tensorfield",level:3},{value:"TensorField.one",id:"tensorfieldone",level:5},{value:"TensorField.zero",id:"tensorfieldzero",level:5},{value:"TensorField.nan",id:"tensorfieldnan",level:5},{value:"TensorField.cast()",id:"tensorfieldcast",level:5},{value:"cast(x, dtype)",id:"castx-dtype",level:6},{value:"cast(x, dtype)",id:"castx-dtype-1",level:6},{value:"cast(x, dtype)",id:"castx-dtype-2",level:6},{value:"cast(x, dtype)",id:"castx-dtype-3",level:6},{value:"cast(x, dtype)",id:"castx-dtype-4",level:6},{value:"cast(x, dtype)",id:"castx-dtype-5",level:6},{value:"cast(x, dtype)",id:"castx-dtype-6",level:6},{value:"cast(x, dtype)",id:"castx-dtype-7",level:6},{value:"cast(x, dtype)",id:"castx-dtype-8",level:6},{value:"cast(x, dtype)",id:"castx-dtype-9",level:6},{value:"cast(x, dtype)",id:"castx-dtype-10",level:6},{value:"cast(x, dtype)",id:"castx-dtype-11",level:6},{value:"cast(x, dtype)",id:"castx-dtype-12",level:6},{value:"cast(x, dtype)",id:"castx-dtype-13",level:6},{value:"cast(x, dtype)",id:"castx-dtype-14",level:6},{value:"cast(x, dtype)",id:"castx-dtype-15",level:6},{value:"cast(x, dtype)",id:"castx-dtype-16",level:6},{value:"TensorField.expression()",id:"tensorfieldexpression",level:5},{value:"TensorField.isZero()",id:"tensorfieldiszero",level:5},{value:"TensorField.isOne()",id:"tensorfieldisone",level:5},{value:"TensorField.equals()",id:"tensorfieldequals",level:5},{value:"TensorField.add()",id:"tensorfieldadd",level:5},{value:"TensorField.addn()",id:"tensorfieldaddn",level:5},{value:"TensorField.neg()",id:"tensorfieldneg",level:5},{value:"TensorField.sub()",id:"tensorfieldsub",level:5},{value:"TensorField.mul()",id:"tensorfieldmul",level:5},{value:"TensorField.muln()",id:"tensorfieldmuln",level:5},{value:"TensorField.div()",id:"tensorfielddiv",level:5},{value:"TensorField.pow()",id:"tensorfieldpow",level:5},{value:"TensorField.conjugate()",id:"tensorfieldconjugate",level:5},{value:"Tensor",id:"tensor",level:3},{value:"Extends",id:"extends-3",level:4},{value:"Tensor.dtype",id:"tensordtype",level:5},{value:"Tensor.shape",id:"tensorshape",level:5},{value:"Tensor.rank",id:"tensorrank",level:5},{value:"Tensor.data",id:"tensordata-1",level:5},{value:"Tensor.field",id:"tensorfield-1",level:5},{value:"Tensor.expression",id:"tensorexpression",level:5},{value:"Tensor.array",id:"tensorarray",level:5},{value:"Tensor.isSquare",id:"tensorissquare",level:5},{value:"Tensor.isSymmetric",id:"tensorissymmetric",level:5},{value:"Tensor.isSkewSymmetric",id:"tensorisskewsymmetric",level:5},{value:"Tensor.isDiagonal",id:"tensorisdiagonal",level:5},{value:"Tensor.isUpperTriangular",id:"tensorisuppertriangular",level:5},{value:"Tensor.isLowerTriangular",id:"tensorislowertriangular",level:5},{value:"Tensor.isTriangular",id:"tensoristriangular",level:5},{value:"Tensor.isIdentity",id:"tensorisidentity",level:5},{value:"Tensor.isZero",id:"tensoriszero",level:5},{value:"Tensor.at()",id:"tensorat",level:5},{value:"Tensor.diagonal()",id:"tensordiagonal",level:5},{value:"Tensor.trace()",id:"tensortrace",level:5},{value:"Tensor.reshape()",id:"tensorreshape",level:5},{value:"Tensor.slice()",id:"tensorslice",level:5},{value:"Tensor.flatten()",id:"tensorflatten",level:5},{value:"Tensor.upcast()",id:"tensorupcast",level:5},{value:"Tensor.transpose()",id:"tensortranspose",level:5},{value:"Tensor.conjugateTranspose()",id:"tensorconjugatetranspose",level:5},{value:"Tensor.determinant()",id:"tensordeterminant",level:5},{value:"Tensor.inverse()",id:"tensorinverse",level:5},{value:"Tensor.pseudoInverse()",id:"tensorpseudoinverse",level:5},{value:"Tensor.adjugateMatrix()",id:"tensoradjugatematrix",level:5},{value:"Tensor.minor()",id:"tensorminor",level:5},{value:"Tensor.map1()",id:"tensormap1",level:5},{value:"Tensor.map2()",id:"tensormap2",level:5},{value:"Tensor.add()",id:"tensoradd",level:5},{value:"Tensor.subtract()",id:"tensorsubtract",level:5},{value:"Tensor.multiply()",id:"tensormultiply",level:5},{value:"Tensor.divide()",id:"tensordivide",level:5},{value:"Tensor.power()",id:"tensorpower",level:5},{value:"Tensor.equals()",id:"tensorequals",level:5},{value:"Type",id:"type",level:2},{value:"BoxedType",id:"boxedtype",level:3},{value:"new BoxedType()",id:"new-boxedtype",level:5},{value:"BoxedType.unknown",id:"boxedtypeunknown",level:5},{value:"BoxedType.number",id:"boxedtypenumber",level:5},{value:"BoxedType.non_finite_number",id:"boxedtypenon_finite_number",level:5},{value:"BoxedType.finite_number",id:"boxedtypefinite_number",level:5},{value:"BoxedType.finite_integer",id:"boxedtypefinite_integer",level:5},{value:"BoxedType.finite_real",id:"boxedtypefinite_real",level:5},{value:"BoxedType.string",id:"boxedtypestring",level:5},{value:"BoxedType.dictionary",id:"boxedtypedictionary",level:5},{value:"BoxedType.setNumber",id:"boxedtypesetnumber",level:5},{value:"BoxedType.setComplex",id:"boxedtypesetcomplex",level:5},{value:"BoxedType.setImaginary",id:"boxedtypesetimaginary",level:5},{value:"BoxedType.setReal",id:"boxedtypesetreal",level:5},{value:"BoxedType.setRational",id:"boxedtypesetrational",level:5},{value:"BoxedType.setFiniteInteger",id:"boxedtypesetfiniteinteger",level:5},{value:"BoxedType.setInteger",id:"boxedtypesetinteger",level:5},{value:"BoxedType.type",id:"boxedtypetype",level:5},{value:"BoxedType.isUnknown",id:"boxedtypeisunknown",level:5},{value:"BoxedType.widen()",id:"boxedtypewiden",level:5},{value:"BoxedType.narrow()",id:"boxedtypenarrow",level:5},{value:"BoxedType.matches()",id:"boxedtypematches",level:5},{value:"BoxedType.is()",id:"boxedtypeis",level:5},{value:"BoxedType.toString()",id:"boxedtypetostring",level:5},{value:"BoxedType.toJSON()",id:"boxedtypetojson",level:5},{value:"BoxedType.[toPrimitive]()",id:"boxedtypetoprimitive",level:5},{value:"BoxedType.valueOf()",id:"boxedtypevalueof",level:5},{value:"MathJSON",id:"mathjson",level:2},{value:"MathJsonAttributes",id:"mathjsonattributes",level:3},{value:"MathJsonSymbol",id:"mathjsonsymbol",level:3},{value:"MathJsonNumberObject",id:"mathjsonnumberobject",level:3},{value:"MathJsonSymbolObject",id:"mathjsonsymbolobject",level:3},{value:"MathJsonStringObject",id:"mathjsonstringobject",level:3},{value:"MathJsonFunctionObject",id:"mathjsonfunctionobject",level:3},{value:"DictionaryValue",id:"dictionaryvalue",level:3},{value:"MathJsonDictionaryObject",id:"mathjsondictionaryobject",level:3},{value:"ExpressionObject",id:"expressionobject",level:3},{value:"Expression",id:"expression",level:3},{value:"Type",id:"type-1",level:2},{value:"PrimitiveType",id:"primitivetype",level:3},{value:"NumericPrimitiveType",id:"numericprimitivetype",level:3},{value:"NamedElement",id:"namedelement",level:3},{value:"FunctionSignature",id:"functionsignature",level:3},{value:"AlgebraicType",id:"algebraictype",level:3},{value:"NegationType",id:"negationtype",level:3},{value:"ValueType",id:"valuetype",level:3},{value:"RecordType",id:"recordtype",level:3},{value:"DictionaryType",id:"dictionarytype",level:3},{value:"CollectionType",id:"collectiontype",level:3},{value:"ListType",id:"listtype",level:3},{value:"SymbolType",id:"symboltype",level:3},{value:"ExpressionType",id:"expressiontype",level:3},{value:"NumericType",id:"numerictype",level:3},{value:"SetType",id:"settype",level:3},{value:"TupleType",id:"tupletype",level:3},{value:"TypeReference",id:"typereference",level:3},{value:"Type",id:"type-2",level:3},{value:"TypeString",id:"typestring",level:3},{value:"TypeCompatibility",id:"typecompatibility",level:3},{value:"TypeResolver",id:"typeresolver",level:3}];function x(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",h6:"h6",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"compute-engine-api-reference",children:"Compute Engine API Reference"})}),"\n",(0,r.jsx)(n.h2,{id:"compute-engine",children:"Compute Engine"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"angularunit",children:"AngularUnit"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type AngularUnit = "rad" | "deg" | "grad" | "turn";\n'})}),(0,r.jsx)(n.p,{children:"When a unitless value is passed to or returned from a trigonometric function,\nthe angular unit of the value."}),(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{style:{textAlign:"left"},children:"Angular Unit"}),(0,r.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"rad"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:"radians, 2\u03c0 radians is a full circle"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"deg"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:"degrees, 360 degrees is a full circle"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"grad"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:"gradians, 400 gradians is a full circle"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"turn"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:"turns, 1 turn is a full circle"})]})]})]}),(0,r.jsx)(n.p,{children:"To change the angular unit used by the Compute Engine, use:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"ce.angularUnit = 'deg';\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"assignvalue",children:"AssignValue"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type AssignValue = \n  | boolean\n  | number\n  | bigint\n  | SemiBoxedExpression\n  | (args, options) => BoxedExpression\n  | undefined;\n"})}),(0,r.jsxs)(n.p,{children:["The argument of ",(0,r.jsx)(n.code,{children:"ce.assign()"})," is a value that can be assigned to a variable.\nIt can be a primitive value, a boxed expression, or a function that\ntakes a list of arguments and returns a boxed expression."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"evalcontext",children:"EvalContext"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type EvalContext = {\n  lexicalScope: Scope;\n  assumptions: ExpressionMapInterface<boolean>;\n  values: Record<string, BoxedExpression | undefined>;\n  name: undefined | string;\n};\n"})}),(0,r.jsx)(n.p,{children:"An evaluation context is a set of bindings mapping symbols to their\nvalues. It also includes a reference to the lexical scope of the\ncontext, as well as a set of assumptions about the values of the\nsymbols."}),(0,r.jsx)(n.p,{children:"Eval contexts are arranged in a stack structure. When a new context is\ncreated, it is pushed on the top of the stack."}),(0,r.jsx)(n.p,{children:'A new eval context is created when a function expression that needs to track\nits own local variables and named arguments is evaluated. This kind of\nfunction is a "scoped" function, meaning that it has its own local variables\nand named arguments.'}),(0,r.jsxs)(n.p,{children:["For example, the ",(0,r.jsx)(n.code,{children:"Sum"})," function creates a new eval context to track the local\nvariable used as the index of the sum."]}),(0,r.jsx)(n.p,{children:"The eval context stack is used to resolve the value of symbols."}),(0,r.jsx)(n.p,{children:"When a scoped recursive function is called, a new context is created for each\nrecursive call."}),(0,r.jsx)(n.p,{children:"In contrast, the lexical scope is used to resolve the metadata about\nsymbols, such as their type, whether they are constant, etc... A new\nscope is not created for recursive calls, since the metadata\ndoes not change, only the values of the symbols change."}),(0,r.jsx)(n.p,{children:'The name of the eval context is used to print a "stack trace" for\ndebugging.'})]}),"\n",(0,r.jsx)(n.h2,{id:"boxed-expression",children:"Boxed Expression"}),"\n",(0,r.jsx)(n.h3,{id:"boxedexpression",children:"BoxedExpression"}),"\n",(0,r.jsxs)(n.admonition,{title:"THEORY OF OPERATIONS",type:"info",children:[(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"BoxedExpression"})," interface includes the methods and properties\napplicable to all kinds of expression. For example it includes ",(0,r.jsx)(n.code,{children:"expr.symbol"}),"\nwhich only applies to symbols or ",(0,r.jsx)(n.code,{children:"expr.ops"})," which only applies to\nfunction expressions."]}),(0,r.jsxs)(n.p,{children:["When a property is not applicable to this ",(0,r.jsx)(n.code,{children:"BoxedExpression"})," its value is\n",(0,r.jsx)(n.code,{children:"null"}),". For example ",(0,r.jsx)(n.code,{children:"expr.symbol"})," for a ",(0,r.jsx)(n.code,{children:"BoxedNumber"})," is ",(0,r.jsx)(n.code,{children:"null"}),"."]}),(0,r.jsx)(n.p,{children:"This convention makes it convenient to manipulate expressions without\nhaving to check what kind of instance they are before manipulating them."})]}),"\n",(0,r.jsxs)(n.admonition,{title:"THEORY OF OPERATIONS",type:"info",children:[(0,r.jsxs)(n.p,{children:['A boxed expression can represent a canonical or a non-canonical\nexpression. A non-canonical expression is a "raw" form of the\nexpression. For example, the non-canonical representation of ',(0,r.jsx)(n.code,{children:"\\frac{10}{20}"}),"\nis ",(0,r.jsx)(n.code,{children:'["Divide", 10, 20]'}),". The canonical representation of the same\nexpression is the boxed number ",(0,r.jsx)(n.code,{children:"1/2"}),"."]}),(0,r.jsx)(n.p,{children:"The canonical representation of symbols and function expressions are\nbound to a definition. The definition contains metadata about the symbol\nor function operator, such as its type, its signature, and other attributes.\nThe value of symbols are tracked in a separate table for each\nevaluation context."}),(0,r.jsx)(n.p,{children:"The binding only occurs when the expression is constructed, if it is created\nas a canonical expression. If the expression is constructed as a\nnon-canonical expression, no binding is done."})]}),"\n",(0,r.jsxs)(n.admonition,{title:"THEORY OF OPERATIONS",type:"info",children:[(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"value"})," of an expression is a number, a string, a boolean or a tensor."]}),(0,r.jsx)(n.p,{children:"The value of number literals and strings are themselves."}),(0,r.jsx)(n.p,{children:"A symbol can have a value associated with it, in which case the value\nof the symbol is the value associated with it."}),(0,r.jsx)(n.p,{children:"Some symbols (unknowns) are purely symbolic and have no value associated\nwith them."}),(0,r.jsxs)(n.p,{children:["Function expressions do not have a value associated with them.\nFor example, ",(0,r.jsx)(n.code,{children:'["Add", 2, 3]'})," has no value associated with it, it is a\nsymbolic expression."]}),(0,r.jsxs)(n.p,{children:["Some properties of a Boxed Expression are only applicable if the expression\nhas a value associated with it. For example, ",(0,r.jsx)(n.code,{children:"expr.isNumber"})," is only\napplicable if the value of the expression is a number, that is if the\nexpression is a number literal or a symbol with a numeric value."]}),(0,r.jsx)(n.p,{children:"The following properties are applicable to expressions with a value:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"expr.isNumber"})}),"\n"]})]}),"\n",(0,r.jsx)(n.p,{children:"To create a boxed expression:"}),"\n",(0,r.jsxs)(n.h4,{id:"cebox-and-ceparse",children:[(0,r.jsx)(n.code,{children:"ce.box()"})," and ",(0,r.jsx)(n.code,{children:"ce.parse()"})]}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"ce.box()"})," or ",(0,r.jsx)(n.code,{children:"ce.parse()"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"ce.parse()"})," to get a boxed expression from a LaTeX string.\nUse ",(0,r.jsx)(n.code,{children:"ce.box()"})," to get a boxed expression from a MathJSON expression."]}),"\n",(0,r.jsx)(n.p,{children:"By default, the result of these methods is a canonical expression. For\nexample, if it is a rational literal, it is reduced to its canonical form.\nIf it is a function expression:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"the arguments are put in canonical form"}),"\n",(0,r.jsx)(n.li,{children:"the arguments of commutative functions are sorted"}),"\n",(0,r.jsx)(n.li,{children:"invisible operators are made explicit"}),"\n",(0,r.jsx)(n.li,{children:"a limited number of core simplifications are applied,\nfor example rationals are reduced"}),"\n",(0,r.jsxs)(n.li,{children:["sequences are flattened: ",(0,r.jsx)(n.code,{children:'["Add", 1, ["Sequence", 2, 3]]'})," is\ntransformed to ",(0,r.jsx)(n.code,{children:'["Add", 1, 2, 3]'})]}),"\n",(0,r.jsxs)(n.li,{children:["associative functions are flattened: ",(0,r.jsx)(n.code,{children:'["Add", 1, ["Add", 2, 3]]'})," is\ntransformed to ",(0,r.jsx)(n.code,{children:'["Add", 1, 2, 3]'})]}),"\n",(0,r.jsxs)(n.li,{children:["symbols are ",(0,r.jsx)(n.strong,{children:"not"})," replaced with their values (unless they have\na ",(0,r.jsx)(n.code,{children:"holdUntil"})," flag set to ",(0,r.jsx)(n.code,{children:"never"}),")."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"cefunction",children:(0,r.jsx)(n.code,{children:"ce.function()"})}),"\n",(0,r.jsxs)(n.p,{children:["This is a specialized version of ",(0,r.jsx)(n.code,{children:"ce.box()"})," for creating a new function\nexpression."]}),"\n",(0,r.jsx)(n.p,{children:"The canonical handler of the operator is called."}),"\n",(0,r.jsxs)(n.h4,{id:"algebraic-methods-expradd-exprmul-etc",children:["Algebraic methods (",(0,r.jsx)(n.code,{children:"expr.add()"}),", ",(0,r.jsx)(n.code,{children:"expr.mul()"}),", etc...)"]}),"\n",(0,r.jsxs)(n.p,{children:["The boxed expression have some algebraic methods, i.e. ",(0,r.jsx)(n.code,{children:"add()"}),", ",(0,r.jsx)(n.code,{children:"mul()"}),",\n",(0,r.jsx)(n.code,{children:"div()"}),", ",(0,r.jsx)(n.code,{children:"pow()"}),", etc. These methods are suitable for\ninternal calculations, although they may be used as part of the public\nAPI as well."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"a runtime error is thrown if the expression is not canonical"}),"\n",(0,r.jsx)(n.li,{children:"the arguments are not evaluated"}),"\n",(0,r.jsx)(n.li,{children:"the canonical handler (of the corresponding operation) is not called"}),"\n",(0,r.jsxs)(n.li,{children:["some additional simplifications over canonicalization are applied.\nFor example number literals are combined.\nHowever, the result is exact, and no approximation is made. Use ",(0,r.jsx)(n.code,{children:".N()"}),"\nto get an approximate value.\nThis is equivalent to calling ",(0,r.jsx)(n.code,{children:"simplify()"})," on the expression (but\nwithout simplifying the arguments)."]}),"\n",(0,r.jsx)(n.li,{children:"sequences were already flattened as part of the canonicalization process"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For 'add()' and 'mul()', which take multiple arguments, separate functions\nare provided that take an array of arguments. They are equivalent\nto calling the boxed algebraic method, i.e. ",(0,r.jsx)(n.code,{children:"ce.Zero.add(1, 2, 3)"})," and\n",(0,r.jsx)(n.code,{children:"add(1, 2, 3)"})," are equivalent."]}),"\n",(0,r.jsxs)(n.p,{children:["These methods are not equivalent to calling ",(0,r.jsx)(n.code,{children:"expr.evaluate()"})," on the\nexpression: evaluate will replace symbols with their values, and\nevaluate the expression."]}),"\n",(0,r.jsxs)(n.p,{children:["For algebraic functions (",(0,r.jsx)(n.code,{children:"add()"}),", ",(0,r.jsx)(n.code,{children:"mul()"}),", etc..), use the corresponding\ncanonicalization function, i.e. ",(0,r.jsx)(n.code,{children:"canonicalAdd(a, b)"})," instead of\n",(0,r.jsx)(n.code,{children:"ce.function('Add', [a, b])"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Another option is to use the algebraic methods directly, i.e. ",(0,r.jsx)(n.code,{children:"a.add(b)"}),"\ninstead of ",(0,r.jsx)(n.code,{children:"ce.function('Add', [a, b])"}),". However, the algebraic methods will\napply further simplifications which may or may not be desirable. For\nexample, number literals will be combined."]}),"\n",(0,r.jsx)(n.h4,{id:"ce_fn",children:(0,r.jsx)(n.code,{children:"ce._fn()"})}),"\n",(0,r.jsx)(n.p,{children:"This method is a low level method to create a new function expression which\nis typically invoked in the canonical handler of an operator definition."}),"\n",(0,r.jsxs)(n.p,{children:["The arguments are not modified. The expression is not put in canonical\nform. The canonical handler is ",(0,r.jsx)(n.em,{children:"not"})," called."]}),"\n",(0,r.jsx)(n.p,{children:"A canonical flag can be set when calling this method, but it only\nasserts that the function expression is canonical. The caller is responsible\nfor ensuring that is the case."}),"\n",(0,r.jsx)(n.h4,{id:"canonical-handlers",children:"Canonical Handlers"}),"\n",(0,r.jsx)(n.p,{children:"Canonical handlers are responsible for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"validating the signature: this can involve checking the\nnumber of arguments. It is recommended to avoid checking the\ntype of non-literal arguments, since the type of symbols or\nfunction expressions may change. Similarly, the canonicalization\nprocess should not rely on the value of or assumptions about non-literal\narguments."}),"\n",(0,r.jsx)(n.li,{children:"flattening sequences"}),"\n",(0,r.jsx)(n.li,{children:"flattening arguments if the function is associative"}),"\n",(0,r.jsx)(n.li,{children:"sort the arguments (if the function is commutative)"}),"\n",(0,r.jsxs)(n.li,{children:["calling ",(0,r.jsx)(n.code,{children:"ce._fn()"})," to create a new function expression"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["When the canonical handler is invoked, the arguments have been put in\ncanonical form unless the ",(0,r.jsx)(n.code,{children:"lazy"})," flag is set to ",(0,r.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Note that the result of a canonical handler should be a canonical expression,\nbut not all arguments need to be canonical. For example, the arguments of\n",(0,r.jsx)(n.code,{children:'["Declare", "x", 2]'})," are not canonical, since ",(0,r.jsx)(n.code,{children:"x"})," refers to the name\nof the symbol, not its value."]}),"\n",(0,r.jsx)(n.h4,{id:"function-expression",children:"Function Expression"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisfunctionexpression",children:"BoxedExpression.isFunctionExpression"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isFunctionExpression: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["Return ",(0,r.jsx)(n.code,{children:"true"})," if this expression is a function expression."]}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"true"}),", ",(0,r.jsx)(n.code,{children:"expr.ops"})," is not ",(0,r.jsx)(n.code,{children:"null"}),", and ",(0,r.jsx)(n.code,{children:"expr.operator"})," is the name\nof the function."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionoperator",children:"BoxedExpression.operator"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly operator: string;\n"})}),(0,r.jsx)(n.p,{children:"The name of the operator of the expression."}),(0,r.jsxs)(n.p,{children:["For example, the name of the operator of ",(0,r.jsx)(n.code,{children:'["Add", 2, 3]'})," is ",(0,r.jsx)(n.code,{children:'"Add"'}),"."]}),(0,r.jsxs)(n.p,{children:["A string literal has a ",(0,r.jsx)(n.code,{children:'"String"'})," operator."]}),(0,r.jsxs)(n.p,{children:["A symbol has a ",(0,r.jsx)(n.code,{children:'"Symbol"'})," operator."]}),(0,r.jsxs)(n.p,{children:["A number has a ",(0,r.jsx)(n.code,{children:'"Number"'}),", ",(0,r.jsx)(n.code,{children:'"Real"'}),", ",(0,r.jsx)(n.code,{children:'"Rational"'})," or ",(0,r.jsx)(n.code,{children:'"Integer"'})," operator; amongst some others.\nPractically speaking, for fully canonical and valid expressions, all of these are likely to\ncollapse to ",(0,r.jsx)(n.code,{children:'"Number"'}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionops",children:"BoxedExpression.ops"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly ops: readonly BoxedExpression[];\n"})}),(0,r.jsx)(n.p,{children:"The list of operands of the function."}),(0,r.jsxs)(n.p,{children:["If the expression is not a function, return ",(0,r.jsx)(n.code,{children:"null"}),"."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionnops",children:"BoxedExpression.nops"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly nops: number;\n"})}),(0,r.jsx)(n.p,{children:"If this expression is a function, the number of operands, otherwise 0."}),(0,r.jsxs)(n.p,{children:["Note that a function can have 0 operands, so to check if this expression\nis a function, check if ",(0,r.jsx)(n.code,{children:"this.ops !== null"})," instead."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionop1",children:"BoxedExpression.op1"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly op1: BoxedExpression;\n"})}),(0,r.jsxs)(n.p,{children:["First operand, i.e.",(0,r.jsx)(n.code,{children:"this.ops[0]"}),"."]}),(0,r.jsxs)(n.p,{children:["If there is no first operand, return the symbol ",(0,r.jsx)(n.code,{children:"Nothing"}),"."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionop2",children:"BoxedExpression.op2"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly op2: BoxedExpression;\n"})}),(0,r.jsxs)(n.p,{children:["Second operand, i.e.",(0,r.jsx)(n.code,{children:"this.ops[1]"})]}),(0,r.jsxs)(n.p,{children:["If there is no second operand, return the symbol ",(0,r.jsx)(n.code,{children:"Nothing"}),"."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionop3",children:"BoxedExpression.op3"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly op3: BoxedExpression;\n"})}),(0,r.jsxs)(n.p,{children:["Third operand, i.e. ",(0,r.jsx)(n.code,{children:"this.ops[2]"})]}),(0,r.jsxs)(n.p,{children:["If there is no third operand, return the symbol ",(0,r.jsx)(n.code,{children:"Nothing"}),"."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})})]}),"\n",(0,r.jsx)(n.h4,{id:"numeric-expression",children:"Numeric Expression"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisnumberliteral",children:"BoxedExpression.isNumberLiteral"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isNumberLiteral: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["Return ",(0,r.jsx)(n.code,{children:"true"})," if this expression is a number literal, for example\n",(0,r.jsx)(n.code,{children:"2"}),", ",(0,r.jsx)(n.code,{children:"3.14"}),", ",(0,r.jsx)(n.code,{children:"1/2"}),", ",(0,r.jsx)(n.code,{children:"\u221a2"})," etc."]}),(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"true"}),", ",(0,r.jsx)(n.code,{children:"expr.numericValue"})," is not ",(0,r.jsx)(n.code,{children:"null"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionnumericvalue",children:"BoxedExpression.numericValue"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly numericValue: number | NumericValue;\n"})}),(0,r.jsx)(n.p,{children:"Return the value of this expression, if a number literal."}),(0,r.jsxs)(n.p,{children:["Note it is possible for ",(0,r.jsx)(n.code,{children:"expr.numericValue"})," to be ",(0,r.jsx)(n.code,{children:"null"}),", and for\n",(0,r.jsx)(n.code,{children:"expr.isNotZero"})," to be true. For example, when a symbol has been\ndefined with an assumption."]}),(0,r.jsxs)(n.p,{children:["Conversely, ",(0,r.jsx)(n.code,{children:"expr.isNumber"})," may be true even if ",(0,r.jsx)(n.code,{children:"expr.numericValue"})," is\n",(0,r.jsx)(n.code,{children:"null"}),", for example the symbol ",(0,r.jsx)(n.code,{children:"Pi"})," return ",(0,r.jsx)(n.code,{children:"true"})," for ",(0,r.jsx)(n.code,{children:"isNumber"})," but\n",(0,r.jsx)(n.code,{children:"expr.numericValue"})," is ",(0,r.jsx)(n.code,{children:"null"})," (it's a symbol, not a number literal).\nIts value can be accessed with ",(0,r.jsx)(n.code,{children:"expr.value"}),"."]}),(0,r.jsxs)(n.p,{children:["To check if an expression is a number literal, use ",(0,r.jsx)(n.code,{children:"expr.isNumberLiteral"}),".\nIf ",(0,r.jsx)(n.code,{children:"expr.isNumberLiteral"})," is ",(0,r.jsx)(n.code,{children:"true"}),", ",(0,r.jsx)(n.code,{children:"expr.numericValue"})," is not ",(0,r.jsx)(n.code,{children:"null"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressioniseven",children:"BoxedExpression.isEven"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isEven: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["If the value of this expression is not an ",(0,r.jsx)(n.strong,{children:"integer"})," return ",(0,r.jsx)(n.code,{children:"undefined"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisodd",children:"BoxedExpression.isOdd"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isOdd: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["If the value of this expression is not an ",(0,r.jsx)(n.strong,{children:"integer"})," return ",(0,r.jsx)(n.code,{children:"undefined"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionre",children:"BoxedExpression.re"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly re: number;\n"})}),(0,r.jsx)(n.p,{children:"Return the real part of the value of this expression, if a number."}),(0,r.jsxs)(n.p,{children:["Otherwise, return ",(0,r.jsx)(n.code,{children:"NaN"})," (not a number)."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionim",children:"BoxedExpression.im"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly im: number;\n"})}),(0,r.jsx)(n.p,{children:"If value of this expression is a number, return the imaginary part of the\nvalue. If the value is a real number, the imaginary part is 0."}),(0,r.jsxs)(n.p,{children:["Otherwise, return ",(0,r.jsx)(n.code,{children:"NaN"})," (not a number)."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionbignumre",children:"BoxedExpression.bignumRe"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly bignumRe: Decimal;\n"})}),(0,r.jsxs)(n.p,{children:["If the value of this expression is a number, return the real part of the\nvalue as a ",(0,r.jsx)(n.code,{children:"BigNum"}),"."]}),(0,r.jsxs)(n.p,{children:["If the value is not available as a bignum return ",(0,r.jsx)(n.code,{children:"undefined"}),". That is,\nthe value is not upconverted to a bignum."]}),(0,r.jsxs)(n.p,{children:["To get the real value either as a bignum or a number, use\n",(0,r.jsx)(n.code,{children:"expr.bignumRe ?? expr.re"}),"."]}),(0,r.jsxs)(n.p,{children:["When using this pattern, the value is returned as a bignum if available,\notherwise as a number or ",(0,r.jsx)(n.code,{children:"NaN"})," if the value is not a number."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionbignumim",children:"BoxedExpression.bignumIm"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly bignumIm: Decimal;\n"})}),(0,r.jsxs)(n.p,{children:["If the value of this expression is a number, return the imaginary part as\na ",(0,r.jsx)(n.code,{children:"BigNum"}),"."]}),(0,r.jsx)(n.p,{children:"It may be 0 if the number is real."}),(0,r.jsxs)(n.p,{children:["If the value of the expression is not a number or the value is not\navailable as a bignum return ",(0,r.jsx)(n.code,{children:"undefined"}),". That is, the value is not\nupconverted to a bignum."]}),(0,r.jsxs)(n.p,{children:["To get the imaginary value either as a bignum or a number, use\n",(0,r.jsx)(n.code,{children:"expr.bignumIm ?? expr.im"}),"."]}),(0,r.jsxs)(n.p,{children:["When using this pattern, the value is returned as a bignum if available, otherwise as a number or ",(0,r.jsx)(n.code,{children:"NaN"})," if the value is not a number."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionsgn",children:"BoxedExpression.sgn"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly sgn: Sign;\n"})}),(0,r.jsx)(n.p,{children:"Return the sign of the expression."}),(0,r.jsxs)(n.p,{children:["Note that complex numbers have no natural ordering, so if the value is an\nimaginary number (a complex number with a non-zero imaginary part),\n",(0,r.jsx)(n.code,{children:"this.sgn"})," will return ",(0,r.jsx)(n.code,{children:"unsigned"}),"."]}),(0,r.jsxs)(n.p,{children:["If a symbol, this does take assumptions into account, that is ",(0,r.jsx)(n.code,{children:"this.sgn"}),"\nwill return ",(0,r.jsx)(n.code,{children:"positive"})," if the symbol is assumed to be positive\nusing ",(0,r.jsx)(n.code,{children:"ce.assume()"}),"."]}),(0,r.jsxs)(n.p,{children:["Non-canonical expressions return ",(0,r.jsx)(n.code,{children:"undefined"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionispositive",children:"BoxedExpression.isPositive"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isPositive: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["The value of this expression is > 0, same as ",(0,r.jsx)(n.code,{children:"isGreaterEqual(0)"})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisnonnegative",children:"BoxedExpression.isNonNegative"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isNonNegative: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["The value of this expression is >= 0, same as ",(0,r.jsx)(n.code,{children:"isGreaterEqual(0)"})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisnegative",children:"BoxedExpression.isNegative"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isNegative: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["The value of this expression is < 0, same as ",(0,r.jsx)(n.code,{children:"isLess(0)"})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisnonpositive",children:"BoxedExpression.isNonPositive"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isNonPositive: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["The  value of this expression is <= 0, same as ",(0,r.jsx)(n.code,{children:"isLessEqual(0)"})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisnan",children:"BoxedExpression.isNaN"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isNaN: boolean;\n"})}),(0,r.jsx)(n.p,{children:'If true, the value of this expression is "Not a Number".'}),(0,r.jsxs)(n.p,{children:["A value representing undefined result of computations, such as ",(0,r.jsx)(n.code,{children:"0/0"}),",\nas per the floating point format standard IEEE-754."]}),(0,r.jsxs)(n.p,{children:["Note that if ",(0,r.jsx)(n.code,{children:"isNaN"})," is true, ",(0,r.jsx)(n.code,{children:"isNumber"})," is also true (yes, ",(0,r.jsx)(n.code,{children:"NaN"})," is a\nnumber)."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisinfinity",children:"BoxedExpression.isInfinity"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isInfinity: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["The numeric value of this expression is ",(0,r.jsx)(n.code,{children:"\xb1Infinity"})," or ComplexInfinity."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisfinite",children:"BoxedExpression.isFinite"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isFinite: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["This expression is a number, but not ",(0,r.jsx)(n.code,{children:"\xb1Infinity"}),", ",(0,r.jsx)(n.code,{children:"ComplexInfinity"})," or\n",(0,r.jsx)(n.code,{children:"NaN"})]})]}),"\n",(0,r.jsx)(n.h4,{id:"other",children:"Other"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionengine",children:"BoxedExpression.engine"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly engine: ComputeEngine;\n"})}),(0,r.jsx)(n.p,{children:"The Compute Engine instance associated with this expression provides\na context in which to interpret it, such as definition of symbols\nand functions."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressiontolatex",children:"BoxedExpression.toLatex()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"toLatex(options?): string\n"})}),(0,r.jsx)(n.p,{children:"Serialize to a LaTeX string."}),(0,r.jsx)(n.p,{children:"Note that lazy collections are eagerly evaluated."}),(0,r.jsx)(n.p,{children:"Will ignore any LaTeX metadata."}),(0,r.jsx)(n.p,{children:"####### options?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Partial"}),"<",(0,r.jsx)(n.a,{href:"#serializelatexoptions",children:(0,r.jsx)(n.code,{children:"SerializeLatexOptions"})}),">"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionlatex",children:"BoxedExpression.latex"}),(0,r.jsx)(n.p,{children:"LaTeX representation of this expression."}),(0,r.jsx)(n.p,{children:"If the expression was parsed from LaTeX, the LaTeX representation is\nthe same as the input LaTeX."}),(0,r.jsxs)(n.p,{children:["To customize the serialization, use ",(0,r.jsx)(n.code,{children:"expr.toLatex()"}),"."]}),(0,r.jsx)(n.p,{children:"Note that lazy collections are eagerly evaluated."}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressiontomathjson",children:"BoxedExpression.toMathJson()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"toMathJson(options?): Expression\n"})}),(0,r.jsx)(n.p,{children:"Serialize to a MathJSON expression with specified options"}),(0,r.jsx)(n.p,{children:"####### options?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Readonly"}),"<",(0,r.jsx)(n.code,{children:"Partial"}),"<",(0,r.jsx)(n.a,{href:"#jsonserializationoptions",children:(0,r.jsx)(n.code,{children:"JsonSerializationOptions"})}),">>"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionjson",children:"BoxedExpression.json"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly json: Expression;\n"})}),(0,r.jsx)(n.p,{children:"MathJSON representation of this expression."}),(0,r.jsx)(n.p,{children:"This representation always use shorthands when possible. Metadata is not\nincluded."}),(0,r.jsx)(n.p,{children:"Numbers are converted to JavaScript numbers and may lose precision."}),(0,r.jsxs)(n.p,{children:["The expression is represented exactly and no sugaring is applied. For\nexample, ",(0,r.jsx)(n.code,{children:'["Power", "x", 2]'})," is not represented as ",(0,r.jsx)(n.code,{children:'["Square", "x"]'}),"."]}),(0,r.jsxs)(n.p,{children:["For more control over the serialization, use ",(0,r.jsx)(n.code,{children:"expr.toMathJson()"}),"."]}),(0,r.jsxs)(n.p,{children:["Note that lazy collections are ",(0,r.jsx)(n.em,{children:"not"})," eagerly evaluated."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionprint",children:"BoxedExpression.print()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"print(): void\n"})}),(0,r.jsx)(n.p,{children:"Output to the console a string representation of the expression."}),(0,r.jsx)(n.p,{children:"Note that lazy collections are eagerly evaluated when printed."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionverbatimlatex",children:"BoxedExpression.verbatimLatex?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional verbatimLatex: string;\n"})}),(0,r.jsx)(n.p,{children:"If the expression was constructed from a LaTeX string, the verbatim LaTeX\nstring it was parsed from."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressioniscanonical",children:"BoxedExpression.isCanonical"}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"true"}),", this expression is in a canonical form."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisstructural",children:"BoxedExpression.isStructural"}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"true"}),", this expression is in a structural form."]}),(0,r.jsxs)(n.p,{children:["The structural form of an expression is used when applying rules to\nan expression. For example, a rational number is represented as a\nfunction expression instead of a ",(0,r.jsx)(n.code,{children:"BoxedExpression"})," object."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressioncanonical",children:"BoxedExpression.canonical"}),(0,r.jsx)(n.p,{children:"Return the canonical form of this expression."}),(0,r.jsx)(n.p,{children:"If a function expression or symbol, they are first bound with a definition\nin the current scope."}),(0,r.jsx)(n.p,{children:"When determining the canonical form the following operator definition\nflags are applied:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"associative"}),": \\( f(a, f(b), c) \\longrightarrow f(a, b, c) \\)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"idempotent"}),": \\( f(f(a)) \\longrightarrow f(a) \\)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"involution"}),": \\( f(f(a)) \\longrightarrow a \\)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"commutative"}),": sort the arguments."]}),"\n"]}),(0,r.jsxs)(n.p,{children:["If this expression is already canonical, the value of canonical is\n",(0,r.jsx)(n.code,{children:"this"}),"."]}),(0,r.jsxs)(n.p,{children:["The arguments of a canonical function expression may not all be\ncanonical, for example in the ",(0,r.jsx)(n.code,{children:'["Declare", "i", 2]'})," expression,\n",(0,r.jsx)(n.code,{children:"i"})," is not canonical since it is used only as the name of a symbol, not\nas a (potentially) existing symbol."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsxs)(n.p,{children:["Partially canonical expressions, such as those produced through\n",(0,r.jsx)(n.code,{children:"CanonicalForm"}),", also yield an expression which is marked as ",(0,r.jsx)(n.code,{children:"canonical"}),".\nThis means that, likewise for partially canonical expressions, the\n",(0,r.jsx)(n.code,{children:"canonical"})," property will return the self-same expression (and\n'isCanonical' will also be true)."]})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionstructural",children:"BoxedExpression.structural"}),(0,r.jsx)(n.p,{children:"Return the structural form of this expression."}),(0,r.jsxs)(n.p,{children:["Some expressions, such as rational numbers, are represented with\na ",(0,r.jsx)(n.code,{children:"BoxedExpression"})," object. In some cases, for example when doing a\nstructural comparison of two expressions, it is useful to have a\nstructural representation of the expression where the rational numbers\nis represented by a function expression instead."]}),(0,r.jsxs)(n.p,{children:["If there is a structural representation of the expression, return it,\notherwise return ",(0,r.jsx)(n.code,{children:"this"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisvalid",children:"BoxedExpression.isValid"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isValid: boolean;\n"})}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"false"})," if this expression or any of its subexpressions is an ",(0,r.jsx)(n.code,{children:'["Error"]'}),"\nexpression."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions. For\nnon-canonical expression, this may indicate a syntax error while parsing\nLaTeX. For canonical expression, this may indicate argument type\nmismatch, or missing or unexpected arguments."})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionispure",children:"BoxedExpression.isPure"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isPure: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.em,{children:"true"}),", evaluating this expression has no side-effects (does not\nchange the state of the Compute Engine)."]}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.em,{children:"false"}),", evaluating this expression may change the state of the\nCompute Engine or it may return a different value each time it is\nevaluated, even if the state of the Compute Engine is the same."]}),(0,r.jsxs)(n.p,{children:['As an example, the ["Add", 2, 3]',(0,r.jsx)(n.code,{children:"function expression is pure, but the"}),'["Random"]` function expression is not pure.']}),(0,r.jsx)(n.p,{children:"For a function expression to be pure, the function itself (its operator)\nmust be pure, and all of its arguments must be pure too."}),(0,r.jsxs)(n.p,{children:["A pure function expression may return a different value each time it is\nevaluated if its arguments are not constant. For example, the\n",(0,r.jsx)(n.code,{children:'["Add", "x", 1]'})," function expression is pure, but it is not\nconstant, because ",(0,r.jsx)(n.code,{children:"x"})," is not constant."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical expressions only"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisconstant",children:"BoxedExpression.isConstant"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isConstant: boolean;\n"})}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"True"})," if evaluating this expression always returns the same value."]}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.em,{children:"true"})," and a function expression, implies that it is ",(0,r.jsx)(n.em,{children:"pure"})," and\nthat all of its arguments are constant."]}),(0,r.jsxs)(n.p,{children:["Number literals, symbols with constant values, and pure numeric functions\nwith constant arguments are all ",(0,r.jsx)(n.em,{children:"constant"}),", i.e.:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"42"})," is constant"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Pi"})," is constant"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'["Divide", "Pi", 2]'})," is constant"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"x"})," is not constant, unless declared with a constant flag."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'["Add", "x", 2]'})," is either constant only if ",(0,r.jsx)(n.code,{children:"x"})," is constant."]}),"\n"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionerrors",children:"BoxedExpression.errors"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly errors: readonly BoxedExpression[];\n"})}),(0,r.jsxs)(n.p,{children:["All the ",(0,r.jsx)(n.code,{children:'["Error"]'})," subexpressions."]}),(0,r.jsxs)(n.p,{children:["If an expression includes an error, the expression is also an error.\nIn that case, the ",(0,r.jsx)(n.code,{children:"this.isValid"})," property is ",(0,r.jsx)(n.code,{children:"false"}),"."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressiongetsubexpressions",children:"BoxedExpression.getSubexpressions()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"getSubexpressions(operator): readonly BoxedExpression[]\n"})}),(0,r.jsx)(n.p,{children:"All the subexpressions matching the named operator, recursively."}),(0,r.jsx)(n.p,{children:"Example:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const expr = ce.parse('a + b * c + d');\nconst subexpressions = expr.getSubexpressions('Add');\n// -> `[['Add', 'a', 'b'], ['Add', 'c', 'd']]`\n"})}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})}),(0,r.jsx)(n.p,{children:"####### operator"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"string"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionsubexpressions",children:"BoxedExpression.subexpressions"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly subexpressions: readonly BoxedExpression[];\n"})}),(0,r.jsx)(n.p,{children:"All the subexpressions in this expression, recursively"}),(0,r.jsx)(n.p,{children:"Example:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const expr = ce.parse('a + b * c + d');\nconst subexpressions = expr.subexpressions;\n// -> `[['Add', 'a', 'b'], ['Add', 'c', 'd'], 'a', 'b', 'c', 'd']`\n"})}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionsymbols",children:"BoxedExpression.symbols"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly symbols: readonly string[];\n"})}),(0,r.jsx)(n.p,{children:"All the symbols in the expression, recursively"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const expr = ce.parse('a + b * c + d');\nconst symbols = expr.symbols;\n// -> ['a', 'b', 'c', 'd']\n"})}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionunknowns",children:"BoxedExpression.unknowns"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly unknowns: readonly string[];\n"})}),(0,r.jsx)(n.p,{children:"All the symbols used in the expression that do not have a value\nassociated with them, i.e. they are declared but not defined."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressiontonumericvalue",children:"BoxedExpression.toNumericValue()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"toNumericValue(): [NumericValue, BoxedExpression]\n"})}),(0,r.jsxs)(n.p,{children:["Attempt to factor a numeric coefficient ",(0,r.jsx)(n.code,{children:"c"})," and a ",(0,r.jsx)(n.code,{children:"rest"})," out of a\ncanonical expression such that ",(0,r.jsx)(n.code,{children:"rest.mul(c)"})," is equal to ",(0,r.jsx)(n.code,{children:"this"}),"."]}),(0,r.jsxs)(n.p,{children:["Attempts to make ",(0,r.jsx)(n.code,{children:"rest"})," a positive value (i.e. pulls out negative sign)."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:"['Multiply', 2, 'x', 3, 'a']\n   -> [NumericValue(6), ['Multiply', 'x', 'a']]\n\n['Divide', ['Multiply', 2, 'x'], ['Multiply', 3, 'y', 'a']]\n   -> [NumericValue({rational: [2, 3]}), ['Divide', 'x', ['Multiply, 'y', 'a']]]\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionneg",children:"BoxedExpression.neg()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"neg(): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Negate (additive inverse)"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressioninv",children:"BoxedExpression.inv()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"inv(): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Inverse (multiplicative inverse)"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionabs",children:"BoxedExpression.abs()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abs(): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Absolute value"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionadd",children:"BoxedExpression.add()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"add(rhs): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Addition"}),(0,r.jsx)(n.p,{children:"####### rhs"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionsub",children:"BoxedExpression.sub()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"sub(rhs): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Subtraction"}),(0,r.jsx)(n.p,{children:"####### rhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionmul",children:"BoxedExpression.mul()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"mul(rhs): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Multiplication"}),(0,r.jsx)(n.p,{children:"####### rhs"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#numericvalue-1",children:(0,r.jsx)(n.code,{children:"NumericValue"})})," | ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressiondiv",children:"BoxedExpression.div()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"div(rhs): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Division"}),(0,r.jsx)(n.p,{children:"####### rhs"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionpow",children:"BoxedExpression.pow()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"pow(exp): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Power"}),(0,r.jsx)(n.p,{children:"####### exp"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionroot",children:"BoxedExpression.root()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"root(exp): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Exponentiation"}),(0,r.jsx)(n.p,{children:"####### exp"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionsqrt",children:"BoxedExpression.sqrt()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"sqrt(): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Square root"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionln",children:"BoxedExpression.ln()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"ln(base?): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Logarithm (natural by default)"}),(0,r.jsx)(n.p,{children:"####### base?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionnumerator",children:"BoxedExpression.numerator"}),(0,r.jsx)(n.p,{children:"Return this expression expressed as a numerator."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressiondenominator",children:"BoxedExpression.denominator"}),(0,r.jsx)(n.p,{children:"Return this expression expressed as a denominator."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionnumeratordenominator",children:"BoxedExpression.numeratorDenominator"}),(0,r.jsx)(n.p,{children:"Return this expression expressed as a numerator and denominator."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisscoped",children:"BoxedExpression.isScoped"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isScoped: boolean;\n"})}),(0,r.jsx)(n.p,{children:"If true, the expression has its own local scope that can be used\nfor local variables and arguments. Only true if the expression is a\nfunction expression."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionlocalscope",children:"BoxedExpression.localScope"}),(0,r.jsx)(n.p,{children:"If this expression has a local scope, return it."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionsubs",children:"BoxedExpression.subs()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"subs(sub, options?): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Replace all the symbols in the expression as indicated."}),(0,r.jsxs)(n.p,{children:["Note the same effect can be achieved with ",(0,r.jsx)(n.code,{children:"this.replace()"}),", but\nusing ",(0,r.jsx)(n.code,{children:"this.subs()"})," is more efficient and simpler, but limited\nto replacing symbols."]}),(0,r.jsxs)(n.p,{children:["The result is bound to the current scope, not to ",(0,r.jsx)(n.code,{children:"this.scope"}),"."]}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"options.canonical"})," is not set, the result is canonical if ",(0,r.jsx)(n.code,{children:"this"}),"\nis canonical."]}),(0,r.jsxs)(n.admonition,{title:"Note",type:"info",children:[(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."}),(0,r.jsxs)(n.p,{children:["If this is a function, an empty substitution is given, and the computed value of ",(0,r.jsx)(n.code,{children:"canonical"}),"\ndoes not differ from that of this expr.: then a call this method is analagous to requesting a\n",(0,r.jsx)(n.em,{children:"clone"}),"."]})]}),(0,r.jsx)(n.p,{children:"####### sub"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#substitution-1",children:(0,r.jsx)(n.code,{children:"Substitution"})})}),(0,r.jsx)(n.p,{children:"####### options?"}),(0,r.jsx)(n.p,{children:"####### canonical?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#canonicaloptions",children:(0,r.jsx)(n.code,{children:"CanonicalOptions"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionmap",children:"BoxedExpression.map()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"map(fn, options?): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Recursively replace all the subexpressions in the expression as indicated."}),(0,r.jsxs)(n.p,{children:["To remove a subexpression, return an empty ",(0,r.jsx)(n.code,{children:'["Sequence"]'})," expression."]}),(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"canonical"})," option is applied to each function subexpression after\nthe substitution is applied."]}),(0,r.jsxs)(n.p,{children:["If no ",(0,r.jsx)(n.code,{children:"options.canonical"})," is set, the result is canonical if ",(0,r.jsx)(n.code,{children:"this"}),"\nis canonical."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Default"}),": ",(0,r.jsx)(n.code,{children:"{ canonical: this.isCanonical, recursive: true }"})]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})}),(0,r.jsx)(n.p,{children:"####### fn"}),(0,r.jsxs)(n.p,{children:["(",(0,r.jsx)(n.code,{children:"expr"}),") => ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})]}),(0,r.jsx)(n.p,{children:"####### options?"}),(0,r.jsx)(n.p,{children:"####### canonical"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#canonicaloptions",children:(0,r.jsx)(n.code,{children:"CanonicalOptions"})})}),(0,r.jsx)(n.p,{children:"####### recursive?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"boolean"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionreplace",children:"BoxedExpression.replace()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"replace(rules, options?): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Transform the expression by applying one or more replacement rules:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If the expression matches the ",(0,r.jsx)(n.code,{children:"match"})," pattern and the ",(0,r.jsx)(n.code,{children:"condition"}),"\npredicate is true, replace it with the ",(0,r.jsx)(n.code,{children:"replace"})," pattern."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If no rules apply, return ",(0,r.jsx)(n.code,{children:"null"}),"."]}),"\n"]}),"\n"]}),(0,r.jsxs)(n.p,{children:["See also ",(0,r.jsx)(n.code,{children:"expr.subs()"})," for a simple substitution of symbols."]}),(0,r.jsx)(n.p,{children:"Procedure for the determining the canonical-status of the input expression and replacements:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"options.canonical"})," is set, the ",(0,r.jsx)(n.em,{children:"entire expr."})," is canonicalized to this degree: whether\nthe replacement occurs at the top-level, or within/recursively."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If otherwise, the ",(0,r.jsx)(n.em,{children:"direct replacement will be canonical"})," if either the 'replaced' expression\nis canonical, or the given replacement (- is a BoxedExpression and -) is canonical.\nNotably also, if this replacement takes place recursively (not at the top-level), then exprs.\ncontaining the replaced expr. will still however have their (previous) canonical-status\n",(0,r.jsx)(n.em,{children:"preserved"}),"... unless this expr. was previously non-canonical, and ",(0,r.jsx)(n.em,{children:"replacements have resulted\nin canonical operands"}),". In this case, an expr. meeting this criteria will be updated to\ncanonical status. (Canonicalization is opportunistic here, in other words)."]}),"\n"]}),"\n"]}),(0,r.jsxs)(n.admonition,{title:"Note",type:"info",children:[(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."}),(0,r.jsxs)(n.p,{children:["To match a specific symbol (not a wildcard pattern), the ",(0,r.jsx)(n.code,{children:"match"})," must be\na ",(0,r.jsx)(n.code,{children:"BoxedExpression"})," (e.g., ",(0,r.jsx)(n.code,{children:"{ match: ce.box('x'), replace: ... }"}),").\nFor simple symbol substitution, consider using ",(0,r.jsx)(n.code,{children:"subs()"})," instead."]})]}),(0,r.jsx)(n.p,{children:"####### rules"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"#boxedruleset",children:(0,r.jsx)(n.code,{children:"BoxedRuleSet"})})," | ",(0,r.jsx)(n.a,{href:"#rule",children:(0,r.jsx)(n.code,{children:"Rule"})})," | ",(0,r.jsx)(n.a,{href:"#rule",children:(0,r.jsx)(n.code,{children:"Rule"})}),"[]"]}),(0,r.jsx)(n.p,{children:"####### options?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Partial"}),"<",(0,r.jsx)(n.a,{href:"#replaceoptions",children:(0,r.jsx)(n.code,{children:"ReplaceOptions"})}),">"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionhas",children:"BoxedExpression.has()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"has(v): boolean\n"})}),(0,r.jsxs)(n.p,{children:["True if the expression includes a symbol ",(0,r.jsx)(n.code,{children:"v"})," or a function operator ",(0,r.jsx)(n.code,{children:"v"}),"."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})}),(0,r.jsx)(n.p,{children:"####### v"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"string"})," | ",(0,r.jsx)(n.code,{children:"string"}),"[]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionmatch",children:"BoxedExpression.match()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"match(pattern, options?): BoxedSubstitution\n"})}),(0,r.jsxs)(n.p,{children:["If this expression matches ",(0,r.jsx)(n.code,{children:"pattern"}),", return a substitution that makes\n",(0,r.jsx)(n.code,{children:"pattern"})," equal to ",(0,r.jsx)(n.code,{children:"this"}),". Otherwise return ",(0,r.jsx)(n.code,{children:"null"}),"."]}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"pattern"})," includes wildcards (symbols that start\nwith ",(0,r.jsx)(n.code,{children:"_"}),"), the substitution will include a prop for each matching named\nwildcard."]}),(0,r.jsxs)(n.p,{children:["If this expression matches ",(0,r.jsx)(n.code,{children:"pattern"})," but there are no named wildcards,\nreturn the empty substitution, ",(0,r.jsx)(n.code,{children:"{}"}),"."]}),(0,r.jsxs)(n.p,{children:["Read more about ",(0,r.jsx)(n.a,{href:"/compute-engine/guides/patterns-and-rules/",children:(0,r.jsx)(n.strong,{children:"patterns and rules"})}),"."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})}),(0,r.jsx)(n.p,{children:"####### pattern"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})}),(0,r.jsx)(n.p,{children:"####### options?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#patternmatchoptions",children:(0,r.jsx)(n.code,{children:"PatternMatchOptions"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionwikidata",children:"BoxedExpression.wikidata"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly wikidata: string;\n"})}),(0,r.jsx)(n.p,{children:"Wikidata identifier."}),(0,r.jsxs)(n.p,{children:["If not a canonical expression, return ",(0,r.jsx)(n.code,{children:"undefined"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressiondescription",children:"BoxedExpression.description"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly description: string[];\n"})}),(0,r.jsx)(n.p,{children:"An optional short description if a symbol or function expression."}),(0,r.jsx)(n.p,{children:"May include markdown. Each string is a paragraph."}),(0,r.jsxs)(n.p,{children:["If not a canonical expression, return ",(0,r.jsx)(n.code,{children:"undefined"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionurl",children:"BoxedExpression.url"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly url: string;\n"})}),(0,r.jsx)(n.p,{children:"An optional URL pointing to more information about the symbol or\nfunction operator."}),(0,r.jsxs)(n.p,{children:["If not a canonical expression, return ",(0,r.jsx)(n.code,{children:"undefined"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressioncomplexity",children:"BoxedExpression.complexity"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly complexity: number;\n"})}),(0,r.jsx)(n.p,{children:"Expressions with a higher complexity score are sorted\nfirst in commutative functions"}),(0,r.jsxs)(n.p,{children:["If not a canonical expression, return ",(0,r.jsx)(n.code,{children:"undefined"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionbasedefinition",children:"BoxedExpression.baseDefinition"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly baseDefinition: BoxedBaseDefinition;\n"})}),(0,r.jsxs)(n.p,{children:["For symbols and functions, a definition associated with the\nexpression. ",(0,r.jsx)(n.code,{children:"this.baseDefinition"})," is the base class of symbol and function\ndefinition."]}),(0,r.jsxs)(n.p,{children:["If not a canonical expression, return ",(0,r.jsx)(n.code,{children:"undefined"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionoperatordefinition",children:"BoxedExpression.operatorDefinition"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly operatorDefinition: BoxedOperatorDefinition;\n"})}),(0,r.jsxs)(n.p,{children:["For function expressions, the definition of the operator associated with\nthe expression. For symbols, the definition of the symbol if it is an\noperator, for example ",(0,r.jsx)(n.code,{children:'"Sin"'}),"."]}),(0,r.jsxs)(n.p,{children:["If not a canonical expression or not a function expression,\nits value is ",(0,r.jsx)(n.code,{children:"undefined"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionvaluedefinition",children:"BoxedExpression.valueDefinition"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly valueDefinition: BoxedValueDefinition;\n"})}),(0,r.jsx)(n.p,{children:"For symbols, a definition associated with the expression, if it is\nnot an operator."}),(0,r.jsxs)(n.p,{children:["If not a canonical expression, or not a value, its value is ",(0,r.jsx)(n.code,{children:"undefined"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionsimplify",children:"BoxedExpression.simplify()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"simplify(options?): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Return a simpler form of this expression."}),(0,r.jsx)(n.p,{children:"A series of rewriting rules are applied repeatedly, until no more rules\napply."}),(0,r.jsxs)(n.p,{children:["The values assigned to symbols and the assumptions about symbols may be\nused, for example ",(0,r.jsx)(n.code,{children:"expr.isInteger"})," or ",(0,r.jsx)(n.code,{children:"expr.isPositive"}),"."]}),(0,r.jsx)(n.p,{children:"No calculations involving decimal numbers (numbers that are not\nintegers) are performed but exact calculations may be performed,\nfor example:"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{className:"language-math math-inline",children:"\\sin(\\frac{\\pi}{4}) \\longrightarrow \\frac{\\sqrt{2}}{2}"}),"."]}),(0,r.jsx)(n.p,{children:"The result is canonical."}),(0,r.jsxs)(n.p,{children:["To manipulate symbolically non-canonical expressions, use ",(0,r.jsx)(n.code,{children:"expr.replace()"}),"."]}),(0,r.jsx)(n.p,{children:"####### options?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Partial"}),"<",(0,r.jsx)(n.a,{href:"#simplifyoptions",children:(0,r.jsx)(n.code,{children:"SimplifyOptions"})}),">"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionexpand",children:"BoxedExpression.expand()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"expand(): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Expand the expression: distribute multiplications over additions,\nand expand powers."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionevaluate",children:"BoxedExpression.evaluate()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"evaluate(options?): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Return the value of the canonical form of this expression."}),(0,r.jsx)(n.p,{children:"A pure expression always returns the same value (provided that it\nremains constant / values of sub-expressions or symbols do not change),\nand has no side effects."}),(0,r.jsx)(n.p,{children:"Evaluating an impure expression may return a varying value, and may have\nsome side effects such as adjusting symbol assumptions."}),(0,r.jsxs)(n.p,{children:["To perform approximate calculations, use ",(0,r.jsx)(n.code,{children:"expr.N()"})," instead,\nor call with ",(0,r.jsx)(n.code,{children:"options.numericApproximation"})," to ",(0,r.jsx)(n.code,{children:"true"}),"."]}),(0,r.jsxs)(n.p,{children:["It is possible that the result of ",(0,r.jsx)(n.code,{children:"expr.evaluate()"})," may be the same as\n",(0,r.jsx)(n.code,{children:"expr.simplify()"}),"."]}),(0,r.jsx)(n.p,{children:"The result is in canonical form."}),(0,r.jsx)(n.p,{children:"####### options?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Partial"}),"<",(0,r.jsx)(n.a,{href:"#evaluateoptions",children:(0,r.jsx)(n.code,{children:"EvaluateOptions"})}),">"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionevaluateasync",children:"BoxedExpression.evaluateAsync()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"evaluateAsync(options?): Promise<BoxedExpression>\n"})}),(0,r.jsxs)(n.p,{children:["Asynchronous version of ",(0,r.jsx)(n.code,{children:"evaluate()"}),"."]}),(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"options"})," argument can include a ",(0,r.jsx)(n.code,{children:"signal"})," property, which is an\n",(0,r.jsx)(n.code,{children:"AbortSignal"})," object. If the signal is aborted, a ",(0,r.jsx)(n.code,{children:"CancellationError"})," is thrown."]}),(0,r.jsx)(n.p,{children:"####### options?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Partial"}),"<",(0,r.jsx)(n.a,{href:"#evaluateoptions",children:(0,r.jsx)(n.code,{children:"EvaluateOptions"})}),">"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionn",children:"BoxedExpression.N()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"N(): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"Return a numeric approximation of the canonical form of this expression."}),(0,r.jsx)(n.p,{children:"Any necessary calculations, including on decimal numbers (non-integers),\nare performed."}),(0,r.jsxs)(n.p,{children:["The calculations are performed according to the\n",(0,r.jsx)(n.code,{children:"precision"})," property of the ",(0,r.jsx)(n.code,{children:"ComputeEngine"}),"."]}),(0,r.jsxs)(n.p,{children:["To only perform exact calculations, use ",(0,r.jsx)(n.code,{children:"this.evaluate()"})," instead."]}),(0,r.jsxs)(n.p,{children:["If the function is not numeric, the result of ",(0,r.jsx)(n.code,{children:"this.N()"})," is the same as\n",(0,r.jsx)(n.code,{children:"this.evaluate()"}),"."]}),(0,r.jsx)(n.p,{children:"The result is in canonical form."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressioncompile",children:"BoxedExpression.compile()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"compile(options?): (...args) => any & {\n  isCompiled: boolean;\n}\n"})}),(0,r.jsx)(n.p,{children:"Compile the expression to a JavaScript function."}),(0,r.jsx)(n.p,{children:"The function takes an object as argument, with the keys being the\nsymbols in the expression, and returns the value of the expression."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const expr = ce.parse("x^2 + y^2");\nconst f = expr.compile();\nconsole.log(f({x: 2, y: 3}));\n// -> 13\n'})}),(0,r.jsx)(n.p,{children:"If the expression is a function literal, the function takes the\narguments of the function as arguments, and returns the value of the\nexpression."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const expr = ce.parse("(x) \\mapsto 2x");\nconst f = expr.compile();\nconsole.log(f(42));\n// -> 84\n'})}),(0,r.jsxs)(n.p,{children:["If the expression cannot be compiled, a JS function is returned that\nfalls back to the interpreting the expression, unless the\n",(0,r.jsx)(n.code,{children:"options.fallback"})," is set to ",(0,r.jsx)(n.code,{children:"false"}),". If it is set to ",(0,r.jsx)(n.code,{children:"false"}),", the\nfunction will throw an error if it cannot be compiled."]}),(0,r.jsx)(n.p,{children:"####### options?"}),(0,r.jsx)(n.p,{children:"####### to?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:'"javascript"'})," | ",(0,r.jsx)(n.code,{children:'"wgsl"'})," | ",(0,r.jsx)(n.code,{children:'"python"'})," | ",(0,r.jsx)(n.code,{children:'"webassembly"'})]}),(0,r.jsx)(n.p,{children:"####### functions?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Record"}),"<",(0,r.jsx)(n.a,{href:"#mathjsonsymbol",children:(0,r.jsx)(n.code,{children:"MathJsonSymbol"})}),", ",(0,r.jsx)(n.a,{href:"#jssource",children:(0,r.jsx)(n.code,{children:"JSSource"})})," | (...",(0,r.jsx)(n.code,{children:"any"}),") => ",(0,r.jsx)(n.code,{children:"any"}),">"]}),(0,r.jsx)(n.p,{children:"####### vars?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Record"}),"<",(0,r.jsx)(n.a,{href:"#mathjsonsymbol",children:(0,r.jsx)(n.code,{children:"MathJsonSymbol"})}),", ",(0,r.jsx)(n.a,{href:"#jssource",children:(0,r.jsx)(n.code,{children:"JSSource"})}),">"]}),(0,r.jsx)(n.p,{children:"####### imports?"}),(0,r.jsxs)(n.p,{children:["(...",(0,r.jsx)(n.code,{children:"any"}),") => ",(0,r.jsx)(n.code,{children:"any"}),"[]"]}),(0,r.jsx)(n.p,{children:"####### preamble?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.p,{children:"####### fallback?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"boolean"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionsolve",children:"BoxedExpression.solve()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"solve(vars?): readonly BoxedExpression[]\n"})}),(0,r.jsxs)(n.p,{children:["If this is an equation, solve the equation for the variables in vars.\nOtherwise, solve the equation ",(0,r.jsx)(n.code,{children:"this = 0"})," for the variables in vars."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const expr = ce.parse("x^2 + 2*x + 1 = 0");\nconsole.log(expr.solve("x"));\n'})}),(0,r.jsx)(n.p,{children:"####### vars?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"string"})," | ",(0,r.jsx)(n.code,{children:"Iterable"}),"<",(0,r.jsx)(n.code,{children:"string"}),", ",(0,r.jsx)(n.code,{children:"any"}),", ",(0,r.jsx)(n.code,{children:"any"}),"> | ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})," | ",(0,r.jsx)(n.code,{children:"Iterable"}),"<",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})}),", ",(0,r.jsx)(n.code,{children:"any"}),", ",(0,r.jsx)(n.code,{children:"any"}),">"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionvalue",children:"BoxedExpression.value"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"get value(): BoxedExpression\nset value(value: \n  | string\n  | number\n  | boolean\n  | number[]\n  | Decimal\n  | OnlyFirst<{\n  re: number;\n  im: number;\n }, {\n  re: number;\n  im: number;\n } & {\n  num: number;\n  denom: number;\n } & BoxedExpression>\n  | OnlyFirst<{\n  num: number;\n  denom: number;\n }, {\n  re: number;\n  im: number;\n } & {\n  num: number;\n  denom: number;\n } & BoxedExpression>\n  | OnlyFirst<BoxedExpression, {\n  re: number;\n  im: number;\n } & {\n  num: number;\n  denom: number;\n } & BoxedExpression>): void\n"})}),(0,r.jsx)(n.p,{children:"If this expression is a number literal, a string literal or a function\nliteral, return the expression."}),(0,r.jsx)(n.p,{children:"If the expression is a symbol, return the value of the symbol."}),(0,r.jsxs)(n.p,{children:["Otherwise, the expression is a symbolic expression, including an unknown\nsymbol, i.e. a symbol with no value, return ",(0,r.jsx)(n.code,{children:"undefined"}),"."]}),(0,r.jsx)(n.p,{children:"If the expression is a symbol, set the value of the symbol."}),(0,r.jsxs)(n.p,{children:["Will throw a runtime error if either not a symbol, or a symbol with the\n",(0,r.jsx)(n.code,{children:"constant"})," flag set to ",(0,r.jsx)(n.code,{children:"true"}),"."]}),(0,r.jsx)(n.p,{children:"Setting the value of a symbol results in the forgetting of all assumptions\nabout it in the current scope."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressioniscollection",children:"BoxedExpression.isCollection"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isCollection: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["Is ",(0,r.jsx)(n.code,{children:"true"})," if the expression is a collection."]}),(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"isCollection"})," is ",(0,r.jsx)(n.code,{children:"true"}),", the expression:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["has an ",(0,r.jsx)(n.code,{children:"each()"})," method that returns a generator over the elements\nof the collection."]}),"\n",(0,r.jsxs)(n.li,{children:["has a ",(0,r.jsx)(n.code,{children:"size"})," property that returns the number of elements in the\ncollection."]}),"\n",(0,r.jsxs)(n.li,{children:["has a ",(0,r.jsx)(n.code,{children:"contains(other)"})," method that returns ",(0,r.jsx)(n.code,{children:"true"})," if the ",(0,r.jsx)(n.code,{children:"other"}),"\nexpression is in the collection."]}),"\n"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisindexedcollection",children:"BoxedExpression.isIndexedCollection"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isIndexedCollection: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["Is ",(0,r.jsx)(n.code,{children:"true"})," if this is an indexed collection, such as a list, a vector,\na matrix, a tuple, etc..."]}),(0,r.jsx)(n.p,{children:"The elements of an indexed collection can be accessed by a one-based\nindex."}),(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"isIndexedCollection"})," is ",(0,r.jsx)(n.code,{children:"true"}),", the expression:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["has an ",(0,r.jsx)(n.code,{children:"each()"}),", ",(0,r.jsx)(n.code,{children:"size()"})," and ",(0,r.jsx)(n.code,{children:"contains(rhs)"})," methods\nas for a collection."]}),"\n",(0,r.jsxs)(n.li,{children:["has an ",(0,r.jsx)(n.code,{children:"at(index: number)"})," method that returns the element at the\nspecified index."]}),"\n",(0,r.jsxs)(n.li,{children:["has an ",(0,r.jsx)(n.code,{children:"indexWhere(predicate: (element: BoxedExpression) => boolean)"}),"\nmethod that returns the index of the first element that matches the\npredicate."]}),"\n"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionislazycollection",children:"BoxedExpression.isLazyCollection"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isLazyCollection: boolean;\n"})}),(0,r.jsx)(n.p,{children:"False if not a collection, or if the elements of the collection\nare not computed lazily."}),(0,r.jsxs)(n.p,{children:["The elements of a lazy collection are computed on demand, when\niterating over the collection using ",(0,r.jsx)(n.code,{children:"each()"}),"."]}),(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"ListFrom"})," and related functions to create eager collections from\nlazy collections."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressioneach",children:"BoxedExpression.each()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"each(): Generator<BoxedExpression>\n"})}),(0,r.jsx)(n.p,{children:"If this is a collection, return an iterator over the elements of the\ncollection."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const expr = ce.parse('[1, 2, 3, 4]');\nfor (const e of expr.each()) {\n console.log(e);\n}\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressioncontains",children:"BoxedExpression.contains()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"contains(rhs): boolean\n"})}),(0,r.jsxs)(n.p,{children:["If this is a collection, return true if the ",(0,r.jsx)(n.code,{children:"rhs"})," expression is in the\ncollection."]}),(0,r.jsxs)(n.p,{children:["Return ",(0,r.jsx)(n.code,{children:"undefined"})," if the membership cannot be determined without\niterating over the collection."]}),(0,r.jsx)(n.p,{children:"####### rhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionsubsetof",children:"BoxedExpression.subsetOf()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"subsetOf(other, strict): boolean\n"})}),(0,r.jsx)(n.p,{children:"Check if this collection is a subset of another collection."}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})}),(0,r.jsx)(n.p,{children:"The other collection to check against."}),(0,r.jsx)(n.p,{children:"####### strict"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"boolean"})}),(0,r.jsx)(n.p,{children:"If true, the subset relation is strict (i.e., proper subset)."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressioncount",children:"BoxedExpression.count"}),(0,r.jsx)(n.p,{children:"If this is a collection, return the number of elements in the collection."}),(0,r.jsxs)(n.p,{children:["If the collection is infinite, return ",(0,r.jsx)(n.code,{children:"Infinity"}),"."]}),(0,r.jsxs)(n.p,{children:["If the number of elements cannot be determined, return ",(0,r.jsx)(n.code,{children:"undefined"}),", for\nexample, if the collection is lazy and not finite and the size cannot\nbe determined without iterating over the collection."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisfinitecollection",children:"BoxedExpression.isFiniteCollection"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isFiniteCollection: boolean;\n"})}),(0,r.jsx)(n.p,{children:"If this is a finite collection, return true."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisemptycollection",children:"BoxedExpression.isEmptyCollection"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isEmptyCollection: boolean;\n"})}),(0,r.jsx)(n.p,{children:"If this is an empty collection, return true."}),(0,r.jsx)(n.p,{children:"An empty collection has a size of 0."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionat",children:"BoxedExpression.at()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"at(index): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"If this is an indexed collection, return the element at the specified\nindex. The first element is at index 1."}),(0,r.jsxs)(n.p,{children:["If the index is negative, return the element at index ",(0,r.jsx)(n.code,{children:"size() + index + 1"}),"."]}),(0,r.jsx)(n.p,{children:"The last element is at index -1."}),(0,r.jsx)(n.p,{children:"####### index"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionget",children:"BoxedExpression.get()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"get(key): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"If this is a keyed collection (map, record, tuple), return the value of\nthe corresponding key."}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"key"})," is a ",(0,r.jsx)(n.code,{children:"BoxedExpression"}),", it should be a string."]}),(0,r.jsx)(n.p,{children:"####### key"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"string"})," | ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionindexwhere",children:"BoxedExpression.indexWhere()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"indexWhere(predicate): number\n"})}),(0,r.jsx)(n.p,{children:"If this is an indexed collection, return the index of the first element\nthat matches the predicate."}),(0,r.jsx)(n.p,{children:"####### predicate"}),(0,r.jsxs)(n.p,{children:["(",(0,r.jsx)(n.code,{children:"element"}),") => ",(0,r.jsx)(n.code,{children:"boolean"})]})]}),"\n",(0,r.jsx)(n.h4,{id:"primitive-methods",children:"Primitive Methods"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionvalueof",children:"BoxedExpression.valueOf()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"valueOf(): string | number | boolean | number[] | number[][] | number[][][]\n"})}),(0,r.jsxs)(n.p,{children:["Return a JavaScript primitive value for the expression, based on\n",(0,r.jsx)(n.code,{children:"Object.valueOf()"}),"."]}),(0,r.jsx)(n.p,{children:"This method is intended to make it easier to work with JavaScript\nprimitives, for example when mixing JavaScript computations with\nsymbolic computations from the Compute Engine."}),(0,r.jsxs)(n.p,{children:["If the expression is a ",(0,r.jsx)(n.strong,{children:"machine number"}),", a ",(0,r.jsx)(n.strong,{children:"bignum"}),", or a ",(0,r.jsx)(n.strong,{children:"rational"}),"\nthat can be converted to a machine number, return a JavaScript ",(0,r.jsx)(n.code,{children:"number"}),".\nThis conversion may result in a loss of precision."]}),(0,r.jsxs)(n.p,{children:["If the expression is the ",(0,r.jsxs)(n.strong,{children:["symbol ",(0,r.jsx)(n.code,{children:'"True"'})]})," or the ",(0,r.jsxs)(n.strong,{children:["symbol ",(0,r.jsx)(n.code,{children:'"False"'})]}),",\nreturn ",(0,r.jsx)(n.code,{children:"true"})," or ",(0,r.jsx)(n.code,{children:"false"}),", respectively."]}),(0,r.jsxs)(n.p,{children:["If the expression is a ",(0,r.jsx)(n.strong,{children:"symbol with a numeric value"}),", return the numeric\nvalue of the symbol."]}),(0,r.jsxs)(n.p,{children:["If the expression is a ",(0,r.jsx)(n.strong,{children:"string literal"}),", return the string value."]}),(0,r.jsxs)(n.p,{children:["If the expression is a ",(0,r.jsx)(n.strong,{children:"tensor"})," (list of number or multidimensional\narray or matrix), return an array of numbers, or an array of\narrays of numbers, or an array of arrays of arrays of numbers."]}),(0,r.jsx)(n.p,{children:"If the expression is a function expression return a string representation\nof the expression."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressiontoprimitive",children:"BoxedExpression.[toPrimitive]()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"toPrimitive: string | number\n"})}),(0,r.jsxs)(n.p,{children:["Similar to",(0,r.jsx)(n.code,{children:"expr.valueOf()"})," but includes a hint."]}),(0,r.jsx)(n.p,{children:"####### hint"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:'"string"'})," | ",(0,r.jsx)(n.code,{children:'"number"'})," | ",(0,r.jsx)(n.code,{children:'"default"'})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressiontostring",children:"BoxedExpression.toString()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"toString(): string\n"})}),(0,r.jsx)(n.p,{children:"Return an ASCIIMath representation of the expression. This string is\nsuitable to be output to the console for debugging, for example."}),(0,r.jsxs)(n.p,{children:["Based on ",(0,r.jsx)(n.code,{children:"Object.toString()"}),"."]}),(0,r.jsxs)(n.p,{children:["To get a LaTeX representation of the expression, use ",(0,r.jsx)(n.code,{children:"expr.latex"}),"."]}),(0,r.jsx)(n.p,{children:"Note that lazy collections are eagerly evaluated."}),(0,r.jsxs)(n.p,{children:["Used when coercing a ",(0,r.jsx)(n.code,{children:"BoxedExpression"})," to a ",(0,r.jsx)(n.code,{children:"String"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressiontojson",children:"BoxedExpression.toJSON()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"toJSON(): Expression\n"})}),(0,r.jsxs)(n.p,{children:["Used by ",(0,r.jsx)(n.code,{children:"JSON.stringify()"})," to serialize this object to JSON."]}),(0,r.jsxs)(n.p,{children:["Method version of ",(0,r.jsx)(n.code,{children:"expr.json"}),"."]}),(0,r.jsxs)(n.p,{children:["Based on ",(0,r.jsx)(n.code,{children:"Object.toJSON()"}),"."]}),(0,r.jsxs)(n.p,{children:["Note that lazy collections are ",(0,r.jsx)(n.em,{children:"not"})," eagerly evaluated."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionis",children:"BoxedExpression.is()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"is(other): boolean\n"})}),(0,r.jsxs)(n.p,{children:["Equivalent to ",(0,r.jsx)(n.code,{children:"BoxedExpression.isSame()"})," but the argument can be\na JavaScript primitive. For example, ",(0,r.jsx)(n.code,{children:"expr.is(2)"})," is equivalent to\n",(0,r.jsx)(n.code,{children:"expr.isSame(ce.number(2))"}),"."]}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"string"})," | ",(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.code,{children:"bigint"})," | ",(0,r.jsx)(n.code,{children:"boolean"})," | ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})]})]}),"\n",(0,r.jsx)(n.h4,{id:"relational-operator",children:"Relational Operator"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionissame",children:"BoxedExpression.isSame()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isSame(rhs): boolean\n"})}),(0,r.jsx)(n.p,{children:"Structural/symbolic equality (weak equality)."}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ce.parse('1+x', {canonical: false}).isSame(ce.parse('x+1', {canonical: false}))"})," is ",(0,r.jsx)(n.code,{children:"false"}),"."]}),(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.code,{children:"expr.isEqual()"})," for mathematical equality."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})}),(0,r.jsx)(n.p,{children:"####### rhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisless",children:"BoxedExpression.isLess()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isLess(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"The value of both expressions are compared."}),(0,r.jsxs)(n.p,{children:["If the expressions cannot be compared, return ",(0,r.jsx)(n.code,{children:"undefined"})]}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionislessequal",children:"BoxedExpression.isLessEqual()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isLessEqual(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"The value of both expressions are compared."}),(0,r.jsxs)(n.p,{children:["If the expressions cannot be compared, return ",(0,r.jsx)(n.code,{children:"undefined"})]}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisgreater",children:"BoxedExpression.isGreater()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isGreater(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"The value of both expressions are compared."}),(0,r.jsxs)(n.p,{children:["If the expressions cannot be compared, return ",(0,r.jsx)(n.code,{children:"undefined"})]}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisgreaterequal",children:"BoxedExpression.isGreaterEqual()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isGreaterEqual(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"The value of both expressions are compared."}),(0,r.jsxs)(n.p,{children:["If the expressions cannot be compared, return ",(0,r.jsx)(n.code,{children:"undefined"})]}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisequal",children:"BoxedExpression.isEqual()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isEqual(other): boolean\n"})}),(0,r.jsxs)(n.p,{children:["Mathematical equality (strong equality), that is the value\nof this expression and the value of ",(0,r.jsx)(n.code,{children:"other"})," are numerically equal."]}),(0,r.jsx)(n.p,{children:"Both expressions are evaluated and the result is compared numerically."}),(0,r.jsxs)(n.p,{children:["Numbers whose difference is less than ",(0,r.jsx)(n.code,{children:"engine.tolerance"})," are\nconsidered equal. This tolerance is set when the ",(0,r.jsx)(n.code,{children:"engine.precision"})," is\nchanged to be such that the last two digits are ignored."]}),(0,r.jsx)(n.p,{children:"Evaluating the expressions may be expensive. Other options to consider\nto compare two expressions include:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"expr.isSame(other)"})," for a structural comparison which does not involve\nevaluating the expressions."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"expr.is(other)"})," for a comparison of a number literal"]}),"\n"]}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"let expr = ce.parse('2 + 2');\nconsole.log(expr.isEqual(4)); // true\nconsole.log(expr.isSame(ce.parse(4))); // false\nconsole.log(expr.is(4)); // false\n\nexpr = ce.parse('4');\nconsole.log(expr.isEqual(4)); // true\nconsole.log(expr.isSame(ce.parse(4))); // true\nconsole.log(expr.is(4)); // true (fastest)\n\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})]})]}),"\n",(0,r.jsx)(n.h4,{id:"string-expression",children:"String Expression"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionstring",children:"BoxedExpression.string"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly string: string;\n"})}),(0,r.jsxs)(n.p,{children:["If this expression is a string, return the value of the string.\nOtherwise, return ",(0,r.jsx)(n.code,{children:"null"}),"."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})})]}),"\n",(0,r.jsx)(n.h4,{id:"symbol-expression",children:"Symbol Expression"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionsymbol",children:"BoxedExpression.symbol"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly symbol: string;\n"})}),(0,r.jsxs)(n.p,{children:["If this expression is a symbol, return the name of the symbol as a string.\nOtherwise, return ",(0,r.jsx)(n.code,{children:"null"}),"."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})})]}),"\n",(0,r.jsx)(n.h4,{id:"tensor-expression",children:"Tensor Expression"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressiontensor",children:"BoxedExpression.tensor"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly tensor: Tensor<any>;\n"})}),(0,r.jsxs)(n.p,{children:["If this expression is a tensor, return the tensor data.\nOtherwise, return ",(0,r.jsx)(n.code,{children:"null"}),"."]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"Applicable to canonical and non-canonical expressions."})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionshape",children:"BoxedExpression.shape"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly shape: number[];\n"})}),(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"shape"})," describes the ",(0,r.jsx)(n.strong,{children:"axes"})," of the expression, where each axis\nrepresent a way to index the elements of the expression."]}),(0,r.jsxs)(n.p,{children:["When the expression is a scalar (number), the shape is ",(0,r.jsx)(n.code,{children:"[]"}),"."]}),(0,r.jsxs)(n.p,{children:["When the expression is a vector of length ",(0,r.jsx)(n.code,{children:"n"}),", the shape is ",(0,r.jsx)(n.code,{children:"[n]"}),"."]}),(0,r.jsxs)(n.p,{children:["When the expression is a ",(0,r.jsx)(n.code,{children:"n"})," by ",(0,r.jsx)(n.code,{children:"m"})," matrix, the shape is ",(0,r.jsx)(n.code,{children:"[n, m]"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionrank",children:"BoxedExpression.rank"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly rank: number;\n"})}),(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"rank"})," refers to the number of dimensions (or axes) of the\nexpression."]}),(0,r.jsx)(n.p,{children:"Return 0 for a scalar, 1 for a vector, 2 for a matrix, > 2 for\na multidimensional matrix."}),(0,r.jsxs)(n.p,{children:["The rank is equivalent to the length of ",(0,r.jsx)(n.code,{children:"expr.shape"})]}),(0,r.jsx)(n.admonition,{title:"Note",type:"info",children:(0,r.jsx)(n.p,{children:"There are several definitions of rank in the literature.\nFor example, the row rank of a matrix is the number of linearly\nindependent rows. The rank can also refer to the number of non-zero\nsingular values of a matrix."})})]}),"\n",(0,r.jsx)(n.h4,{id:"type-properties",children:"Type Properties"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressiontype",children:"BoxedExpression.type"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"get type(): BoxedType\nset type(type: \n  | string\n  | AlgebraicType\n  | NegationType\n  | CollectionType\n  | ListType\n  | SetType\n  | RecordType\n  | DictionaryType\n  | TupleType\n  | SymbolType\n  | ExpressionType\n  | NumericType\n  | FunctionSignature\n  | ValueType\n  | TypeReference\n  | BoxedType): void\n"})}),(0,r.jsx)(n.p,{children:"The type of the value of this expression."}),(0,r.jsx)(n.p,{children:"If a symbol the type of the value of the symbol."}),(0,r.jsx)(n.p,{children:"If a function expression, the type of the value of the function\n(the result type)."}),(0,r.jsxs)(n.p,{children:["If a symbol with a ",(0,r.jsx)(n.code,{children:'"function"'})," type (a function literal), returns the\nsignature."]}),(0,r.jsxs)(n.p,{children:["If not valid, return ",(0,r.jsx)(n.code,{children:'"error"'}),"."]}),(0,r.jsxs)(n.p,{children:["If the type is not known, return ",(0,r.jsx)(n.code,{children:'"unknown"'}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisnumber",children:"BoxedExpression.isNumber"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isNumber: boolean;\n"})}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"true"})," if the value of this expression is a number."]}),(0,r.jsxs)(n.p,{children:["Note that in a fateful twist of cosmic irony, ",(0,r.jsx)(n.code,{children:"NaN"}),' ("Not a Number")\n',(0,r.jsx)(n.strong,{children:"is"})," a number."]}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"isNumber"})," is ",(0,r.jsx)(n.code,{children:"true"}),", this indicates that evaluating the expression\nwill return a number."]}),(0,r.jsxs)(n.p,{children:["This does not indicate that the expression is a number literal. To check\nif the expression is a number literal, use ",(0,r.jsx)(n.code,{children:"expr.isNumberLiteral"}),"."]}),(0,r.jsxs)(n.p,{children:["For example, the expression ",(0,r.jsx)(n.code,{children:'["Add", 1, "x"]'}),' is a number if "x" is a\nnumber and ',(0,r.jsx)(n.code,{children:"expr.isNumber"})," is ",(0,r.jsx)(n.code,{children:"true"}),", but ",(0,r.jsx)(n.code,{children:"isNumberLiteral"})," is ",(0,r.jsx)(n.code,{children:"false"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisinteger",children:"BoxedExpression.isInteger"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isInteger: boolean;\n"})}),(0,r.jsx)(n.p,{children:"The value of this expression is an element of the set \u2124: ...,-2, -1, 0, 1, 2..."}),(0,r.jsx)(n.p,{children:"Note that \xb1\u221e and NaN are not integers."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisrational",children:"BoxedExpression.isRational"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isRational: boolean;\n"})}),(0,r.jsx)(n.p,{children:"The value of this expression is an element of the set \u211a, p/q with p \u2208 \u2115, q \u2208 \u2124 \u20f0  q >= 1"}),(0,r.jsx)(n.p,{children:"Note that every integer is also a rational."}),(0,r.jsxs)(n.p,{children:["This is equivalent to ",(0,r.jsx)(n.code,{children:'this.type === "rational" || this.type === "integer"'})]}),(0,r.jsx)(n.p,{children:"Note that \xb1\u221e and NaN are not rationals."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedexpressionisreal",children:"BoxedExpression.isReal"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isReal: boolean;\n"})}),(0,r.jsx)(n.p,{children:"The value of this expression is a real number."}),(0,r.jsxs)(n.p,{children:["This is equivalent to ",(0,r.jsx)(n.code,{children:'this.type === "rational" || this.type === "integer" || this.type === "real"'})]}),(0,r.jsx)(n.p,{children:"Note that \xb1\u221e and NaN are not real numbers."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"semiboxedexpression",children:"SemiBoxedExpression"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type SemiBoxedExpression = \n  | number\n  | bigint\n  | string\n  | BigNum\n  | MathJsonNumberObject\n  | MathJsonStringObject\n  | MathJsonSymbolObject\n  | MathJsonFunctionObject\n  | MathJsonDictionaryObject\n  | readonly [MathJsonSymbol, ...SemiBoxedExpression[]]\n  | BoxedExpression;\n"})}),(0,r.jsx)(n.p,{children:"A semi boxed expression is a MathJSON expression which can include some\nboxed terms."}),(0,r.jsxs)(n.p,{children:["This is convenient when creating new expressions from portions\nof an existing ",(0,r.jsx)(n.code,{children:"BoxedExpression"})," while avoiding unboxing and reboxing."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"replaceoptions",children:"ReplaceOptions"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type ReplaceOptions = {\n  recursive: boolean;\n  once: boolean;\n  useVariations: boolean;\n  matchPermutations: boolean;\n  iterationLimit: number;\n  canonical: CanonicalOptions;\n};\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"simplifyoptions",children:"SimplifyOptions"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type SimplifyOptions = {\n  rules:   | null\n     | Rule\n     | ReadonlyArray<BoxedRule | Rule>\n     | BoxedRuleSet;\n  costFunction: (expr) => number;\n};\n"})}),(0,r.jsxs)(n.p,{children:["Options for ",(0,r.jsx)(n.code,{children:"BoxedExpression.simplify()"})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"canonicalform",children:"CanonicalForm"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type CanonicalForm = \n  | "InvisibleOperator"\n  | "Number"\n  | "Multiply"\n  | "Add"\n  | "Power"\n  | "Divide"\n  | "Flatten"\n  | "Order";\n'})}),(0,r.jsx)(n.p,{children:'When provided, canonical forms are used to put an expression in a\n"standard" form.'}),(0,r.jsx)(n.p,{children:"Each canonical form applies some transformation to an expression. When\nspecified as an array, each transformation is done in the order in which\nit was provided."}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"InvisibleOperator"}),": replace use of the ",(0,r.jsx)(n.code,{children:"InvisibleOperator"})," with\nanother operation, such as multiplication (i.e. ",(0,r.jsx)(n.code,{children:"2x"})," or function\napplication (",(0,r.jsx)(n.code,{children:"f(x)"}),"). Also replaces ['InvisibleOperator', real, imaginary] instances with\ncomplex (imaginary) numbers."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Number"}),": replace all numeric values with their\ncanonical representation, for example, reduce\nrationals and replace complex numbers with no imaginary part with a real number."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Multiply"}),": replace negation with multiplication by -1, remove 1 from multiplications, simplify signs (",(0,r.jsx)(n.code,{children:"-y \\times -x"})," -> ",(0,r.jsx)(n.code,{children:"x \\times y"}),"), complex numbers are promoted (['Multiply', 2, 'ImaginaryUnit'] -> ",(0,r.jsx)(n.code,{children:'["Complex", 0, 2]'}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Add"}),": replace ",(0,r.jsx)(n.code,{children:"Subtract"})," with ",(0,r.jsx)(n.code,{children:"Add"}),', removes 0 in addition, promote complex numbers (["Add", "a", ["Complex", 0, "b"] -> ',(0,r.jsx)(n.code,{children:'["Complex", "a", "b"]'}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Power"}),": simplify ",(0,r.jsx)(n.code,{children:"Power"})," expression, for example, ",(0,r.jsx)(n.code,{children:"x^{-1}"})," -> ",(0,r.jsx)(n.code,{children:"\\frac{1}{x}"}),", ",(0,r.jsx)(n.code,{children:"x^0"})," -> ",(0,r.jsx)(n.code,{children:"1"}),", ",(0,r.jsx)(n.code,{children:"x^1"})," -> ",(0,r.jsx)(n.code,{children:"x"}),", ",(0,r.jsx)(n.code,{children:"1^x"})," -> ",(0,r.jsx)(n.code,{children:"1"}),", ",(0,r.jsx)(n.code,{children:"x^{\\frac{1}{2}}"})," -> ",(0,r.jsx)(n.code,{children:"\\sqrt{x}"}),", ",(0,r.jsx)(n.code,{children:"a^b^c"})," -> ",(0,r.jsx)(n.code,{children:"a^{bc}"}),"..."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Divide"}),": replace with a ",(0,r.jsx)(n.code,{children:"Rational"})," number if numerator and denominator are integers, simplify, e.g. ",(0,r.jsx)(n.code,{children:"\\frac{x}{1}"})," -> ",(0,r.jsx)(n.code,{children:"x"}),"..."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Flatten"}),": remove any unnecessary ",(0,r.jsx)(n.code,{children:"Delimiter"})," expression, and flatten any associative functions, for example ",(0,r.jsx)(n.code,{children:'["Add", ["Add", "a", "b"], "c"]'})," -> ",(0,r.jsx)(n.code,{children:'["Add", "a", "b", "c"]'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Order"}),": when applicable, sort the arguments in a specific order, for\nexample for addition and multiplication."]}),"\n"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"canonicaloptions",children:"CanonicalOptions"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type CanonicalOptions = \n  | boolean\n  | CanonicalForm\n  | CanonicalForm[];\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"evaluateoptions",children:"EvaluateOptions"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type EvaluateOptions = {\n  numericApproximation: boolean;\n  materialization: boolean | number | [number, number];\n  signal: AbortSignal;\n  withArguments: Record<MathJsonSymbol, BoxedExpression>;\n};\n"})}),(0,r.jsxs)(n.p,{children:["Options for ",(0,r.jsx)(n.code,{children:"BoxedExpression.evaluate()"})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"metadata",children:"Metadata"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Metadata = {\n  latex: string;\n  wikidata: string;\n};\n"})}),(0,r.jsx)(n.p,{children:"Metadata that can be associated with an MathJSON expression."})]}),"\n",(0,r.jsx)(n.h2,{id:"pattern-matching",children:"Pattern Matching"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"patternmatchoptions",children:"PatternMatchOptions"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type PatternMatchOptions = {\n  substitution: BoxedSubstitution;\n  recursive: boolean;\n  useVariations: boolean;\n  matchPermutations: boolean;\n};\n"})}),(0,r.jsx)(n.p,{children:"Control how a pattern is matched to an expression."}),(0,r.jsx)(n.h3,{id:"wildcards",children:"Wildcards"}),(0,r.jsx)(n.p,{children:"Patterns can include wildcards to match parts of expressions:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Universal (",(0,r.jsx)(n.code,{children:"_"})," or ",(0,r.jsx)(n.code,{children:"_name"}),")"]}),": Matches exactly one element"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Sequence (",(0,r.jsx)(n.code,{children:"__"})," or ",(0,r.jsx)(n.code,{children:"__name"}),")"]}),": Matches one or more elements"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Optional Sequence (",(0,r.jsx)(n.code,{children:"___"})," or ",(0,r.jsx)(n.code,{children:"___name"}),")"]}),": Matches zero or more elements"]}),"\n"]}),(0,r.jsx)(n.p,{children:"Named wildcards capture values in the returned substitution:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"['Add', '_a', 1].match(['Add', 'x', 1])"})," \u2192 ",(0,r.jsx)(n.code,{children:"{_a: 'x'}"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"['Add', '__a'].match(['Add', 1, 2, 3])"})," \u2192 ",(0,r.jsx)(n.code,{children:"{__a: [1, 2, 3]}"})]}),"\n"]}),(0,r.jsx)(n.h3,{id:"options",children:"Options"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"substitution"}),": if present, assumes these values for a subset of\nnamed wildcards, and ensure that subsequent occurrence of the same\nwildcard have the same value."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"recursive"}),": if true, match recursively, otherwise match only the top\nlevel."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"useVariations"}),": if false, only match expressions that are structurally identical.\nIf true, match expressions that are structurally identical or equivalent.\nFor example, when true, ",(0,r.jsx)(n.code,{children:"[\"Add\", '_a', 2]"})," matches ",(0,r.jsx)(n.code,{children:"2"}),", with ",(0,r.jsx)(n.code,{children:"_a = 0"}),".\n",(0,r.jsx)(n.strong,{children:"Default"}),": ",(0,r.jsx)(n.code,{children:"false"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"matchPermutations"}),": if true (default), for commutative operators, try all\npermutations of pattern operands. If false, match exact order only."]}),"\n"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"substitution",children:"Substitution"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Substitution<T> = {};\n"})}),(0,r.jsx)(n.p,{children:"A substitution describes the values of the wildcards in a pattern so that\nthe pattern is equal to a target expression."}),(0,r.jsxs)(n.p,{children:["A substitution can also be considered a more constrained version of a\nrule whose ",(0,r.jsx)(n.code,{children:"match"})," is always a symbol."]}),(0,r.jsx)(n.h4,{id:"type-parameters",children:"Type Parameters"}),(0,r.jsxs)(n.p,{children:["\u2022 T = ",(0,r.jsx)(n.a,{href:"#semiboxedexpression",children:(0,r.jsx)(n.code,{children:"SemiBoxedExpression"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"boxedsubstitution",children:"BoxedSubstitution"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type BoxedSubstitution = Substitution<BoxedExpression>;\n"})})]}),"\n",(0,r.jsx)(n.h2,{id:"rules",children:"Rules"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"rulereplacefunction",children:"RuleReplaceFunction()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type RuleReplaceFunction = (expr, wildcards) => BoxedExpression | undefined;\n"})}),(0,r.jsx)(n.p,{children:"Given an expression and set of wildcards, return a new expression."}),(0,r.jsx)(n.p,{children:"For example:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n   match: '_x',\n   replace: (expr, {_x}) => { return ['Add', 1, _x] }\n}\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"ruleconditionfunction",children:"RuleConditionFunction()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type RuleConditionFunction = (wildcards, ce) => boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"rulefunction",children:"RuleFunction()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type RuleFunction = (expr) => \n  | undefined\n  | BoxedExpression\n  | RuleStep;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"rulestep",children:"RuleStep"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type RuleStep = {\n  value: BoxedExpression;\n  because: string;\n};\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"rulesteps",children:"RuleSteps"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type RuleSteps = RuleStep[];\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"rule",children:"Rule"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Rule = \n  | string\n  | RuleFunction\n  | {\n  match:   | LatexString\n     | SemiBoxedExpression\n     | BoxedExpression;\n  replace:   | LatexString\n     | SemiBoxedExpression\n     | RuleReplaceFunction\n     | RuleFunction;\n  condition:   | LatexString\n     | RuleConditionFunction;\n  useVariations: boolean;\n  id: string;\n  onBeforeMatch: (rule, expr) => void;\n  onMatch: (rule, expr, replace) => void;\n};\n"})}),(0,r.jsxs)(n.p,{children:["A rule describes how to modify an expression that matches a pattern ",(0,r.jsx)(n.code,{children:"match"}),"\ninto a new expression ",(0,r.jsx)(n.code,{children:"replace"}),"."]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"x-1"})," ( \\to ) ",(0,r.jsx)(n.code,{children:"1-x"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"(x+1)(x-1)"})," ( \\to ) `x^2-1"]}),"\n"]}),(0,r.jsxs)(n.p,{children:["The patterns can be expressed as LaTeX strings or ",(0,r.jsx)(n.code,{children:"SemiBoxedExpression"}),"'s.\nAlternatively, match/replace logic may be specified by a ",(0,r.jsx)(n.code,{children:"RuleFunction"}),", allowing both custom\nlogic/conditions for the match, and either a ",(0,r.jsx)(n.em,{children:"BoxedExpression"})," (or ",(0,r.jsx)(n.code,{children:"RuleStep"})," if being\ndescriptive) for the replacement."]}),(0,r.jsxs)(n.p,{children:["As a shortcut, a rule can be defined as a LaTeX string: ",(0,r.jsx)(n.code,{children:"x-1 -> 1-x"}),".\nThe expression to the left of ",(0,r.jsx)(n.code,{children:"->"})," is the ",(0,r.jsx)(n.code,{children:"match"})," and the expression to the\nright is the ",(0,r.jsx)(n.code,{children:"replace"}),". When using LaTeX strings, single character variables\nare assumed to be wildcards. The rule LHS ('match') and RHS ('replace') may also be supplied\nseparately: in this case following the same rules."]}),(0,r.jsxs)(n.p,{children:["When using MathJSON expressions, anonymous wildcards (",(0,r.jsx)(n.code,{children:"_"}),") will match any\nexpression. Named wildcards (",(0,r.jsx)(n.code,{children:"_x"}),", ",(0,r.jsx)(n.code,{children:"_a"}),", etc...) will match any expression\nand bind the expression to the wildcard name."]}),(0,r.jsxs)(n.p,{children:["In addition the sequence wildcard (",(0,r.jsx)(n.code,{children:"__1"}),", ",(0,r.jsx)(n.code,{children:"__a"}),", etc...) will match\na sequence of one or more expressions, and bind the sequence to the\nwildcard name."]}),(0,r.jsxs)(n.p,{children:['Sequence wildcards are useful when the number of elements in the sequence\nis not known in advance. For example, in a sum, the number of terms is\nnot known in advance. ["Add", 0, ',(0,r.jsx)(n.code,{children:"__a"}),"] will match two or more terms and\nthe ",(0,r.jsx)(n.code,{children:"__a"})," wildcard will be a sequence of the matchign terms."]}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"exact"})," is false, the rule will match variants."]}),(0,r.jsx)(n.p,{children:"For example 'x' will match 'a + x', 'x' will match 'ax', etc..."}),(0,r.jsxs)(n.p,{children:["For simplification rules, you generally want ",(0,r.jsx)(n.code,{children:"exact"})," to be true, but\nto solve equations, you want it to be false. Default to true."]}),(0,r.jsx)(n.p,{children:"When set to false, infinite recursion is possible."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"boxedrule",children:"BoxedRule"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type BoxedRule = {\n  match: undefined | BoxedExpression;\n  replace:   | BoxedExpression\n     | RuleReplaceFunction\n     | RuleFunction;\n  condition: undefined | RuleConditionFunction;\n  useVariations: boolean;\n  id: string;\n  onBeforeMatch: (rule, expr) => void;\n  onMatch: (rule, expr, replace) => void;\n};\n"})}),(0,r.jsxs)(n.p,{children:["If the ",(0,r.jsx)(n.code,{children:"match"})," property is ",(0,r.jsx)(n.code,{children:"undefined"}),", all expressions match this rule\nand ",(0,r.jsx)(n.code,{children:"condition"})," should also be ",(0,r.jsx)(n.code,{children:"undefined"}),". The ",(0,r.jsx)(n.code,{children:"replace"})," property should\nbe a ",(0,r.jsx)(n.code,{children:"BoxedExpression"})," or a ",(0,r.jsx)(n.code,{children:"RuleFunction"}),", and further filtering can be\ndone in the ",(0,r.jsx)(n.code,{children:"replace"})," function."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"boxedruleset",children:"BoxedRuleSet"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type BoxedRuleSet = {\n  rules: ReadonlyArray<BoxedRule>;\n};\n"})}),(0,r.jsxs)(n.p,{children:["To create a BoxedRuleSet use the ",(0,r.jsx)(n.code,{children:"ce.rules()"})," method."]}),(0,r.jsxs)(n.p,{children:["Do not create a ",(0,r.jsx)(n.code,{children:"BoxedRuleSet"})," directly."]})]}),"\n",(0,r.jsx)(n.h2,{id:"assumptions",children:"Assumptions"}),"\n",(0,r.jsx)(n.h3,{id:"assumption",children:"Assumption"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionispositive",children:"Assumption.isPositive"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isPositive: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisnonnegative",children:"Assumption.isNonNegative"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isNonNegative: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisnegative",children:"Assumption.isNegative"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isNegative: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisnonpositive",children:"Assumption.isNonPositive"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isNonPositive: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisnumber",children:"Assumption.isNumber"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isNumber: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisinteger",children:"Assumption.isInteger"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isInteger: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisrational",children:"Assumption.isRational"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isRational: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisreal",children:"Assumption.isReal"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isReal: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptioniscomplex",children:"Assumption.isComplex"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isComplex: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisimaginary",children:"Assumption.isImaginary"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isImaginary: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisfinite",children:"Assumption.isFinite"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isFinite: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisinfinite",children:"Assumption.isInfinite"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isInfinite: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisnan",children:"Assumption.isNaN"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isNaN: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptioniszero",children:"Assumption.isZero"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isZero: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionmatches",children:"Assumption.matches()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"matches(t): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### t"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedtype",children:(0,r.jsx)(n.code,{children:"BoxedType"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisgreater",children:"Assumption.isGreater()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isGreater(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisgreaterequal",children:"Assumption.isGreaterEqual()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isGreaterEqual(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisless",children:"Assumption.isLess()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isLess(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionislessequal",children:"Assumption.isLessEqual()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isLessEqual(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptionisequal",children:"Assumption.isEqual()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isEqual(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"assumptiontoexpression",children:"Assumption.toExpression()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"toExpression(ce, x): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"####### ce"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"ComputeEngine"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"string"})})]}),"\n",(0,r.jsx)(n.h3,{id:"expressionmapinterface",children:"ExpressionMapInterface"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"expressionmapinterfacehas",children:"ExpressionMapInterface.has()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"has(expr): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### expr"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"expressionmapinterfaceget",children:"ExpressionMapInterface.get()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"get(expr): U\n"})}),(0,r.jsx)(n.p,{children:"####### expr"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"expressionmapinterfaceset",children:"ExpressionMapInterface.set()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"set(expr, value): void\n"})}),(0,r.jsx)(n.p,{children:"####### expr"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})}),(0,r.jsx)(n.p,{children:"####### value"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"U"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"expressionmapinterfacedelete",children:"ExpressionMapInterface.delete()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"delete(expr): void\n"})}),(0,r.jsx)(n.p,{children:"####### expr"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#boxedexpression",children:(0,r.jsx)(n.code,{children:"BoxedExpression"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"expressionmapinterfaceclear",children:"ExpressionMapInterface.clear()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"clear(): void\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"expressionmapinterfaceiterator",children:"ExpressionMapInterface.[iterator]()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"iterator: IterableIterator<[BoxedExpression, U]>\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"expressionmapinterfaceentries",children:"ExpressionMapInterface.entries()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"entries(): IterableIterator<[BoxedExpression, U]>\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"assumeresult",children:"AssumeResult"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type AssumeResult = \n  | "internal-error"\n  | "not-a-predicate"\n  | "contradiction"\n  | "tautology"\n  | "ok";\n'})})]}),"\n",(0,r.jsx)(n.h2,{id:"compiling",children:"Compiling"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"compiledtype",children:"CompiledType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type CompiledType = boolean | number | string | object;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"jssource",children:"JSSource"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type JSSource = string;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"compiledexpression",children:"CompiledExpression"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type CompiledExpression = {\n  evaluate: (scope) => number | BoxedExpression;\n};\n"})})]}),"\n",(0,r.jsx)(n.h2,{id:"definitions",children:"Definitions"}),"\n",(0,r.jsx)(n.h3,{id:"eqhandlers",children:"EqHandlers"}),"\n",(0,r.jsx)(n.p,{children:"These handlers compare two expressions."}),"\n",(0,r.jsx)(n.p,{children:"If only one of the handlers is provided, the other is derived from it."}),"\n",(0,r.jsx)(n.p,{children:"Having both may be useful if comparing non-equality is faster than equality."}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"eqhandlerseq",children:"EqHandlers.eq()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"eq: (a, b) => boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"eqhandlersneq",children:"EqHandlers.neq()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"neq: (a, b) => boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"hold",children:"Hold"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type Hold = "none" | "all" | "first" | "rest" | "last" | "most";\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"valuedefinition",children:"ValueDefinition"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type ValueDefinition = BaseDefinition & {\n  holdUntil: "never" | "evaluate" | "N";\n  type:   | Type\n     | TypeString\n     | BoxedType;\n  inferred: boolean;\n  value:   | LatexString\n     | SemiBoxedExpression\n     | (ce) => BoxedExpression | null;\n  eq: (a) => boolean | undefined;\n  neq: (a) => boolean | undefined;\n  cmp: (a) => "=" | ">" | "<" | undefined;\n  collection: CollectionHandlers;\n};\n'})}),(0,r.jsx)(n.p,{children:"A bound symbol (i.e. one with an associated definition) has either a type\n(e.g. \u2200 x \u2208 \u211d), a value (x = 5) or both (\u03c0: value = 3.14... type = 'real')."}),(0,r.jsx)(n.h4,{id:"valuedefinitioninferred",children:"ValueDefinition.inferred"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"inferred: boolean;\n"})}),(0,r.jsx)(n.p,{children:"If true, the type is inferred, and could be adjusted later\nas more information becomes available or if the symbol is explicitly\ndeclared."}),(0,r.jsx)(n.h4,{id:"valuedefinitionvalue",children:"ValueDefinition.value"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"value: \n  | LatexString\n  | SemiBoxedExpression\n  | (ce) => BoxedExpression | null;\n"})}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"value"})," can be a JS function since for some constants, such as\n",(0,r.jsx)(n.code,{children:"Pi"}),", the actual value depends on the ",(0,r.jsx)(n.code,{children:"precision"})," setting of the\n",(0,r.jsx)(n.code,{children:"ComputeEngine"})," and possible other environment settings"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"operatordefinition",children:"OperatorDefinition"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type OperatorDefinition = Partial<BaseDefinition> & Partial<OperatorDefinitionFlags> & {\n  signature:   | Type\n     | TypeString\n     | BoxedType;\n  type: (ops, options) => \n     | Type\n     | TypeString\n     | BoxedType\n     | undefined;\n  sgn: (ops, options) => Sign | undefined;\n  isPositive: boolean;\n  isNonNegative: boolean;\n  isNegative: boolean;\n  isNonPositive: boolean;\n  even: (ops, options) => boolean | undefined;\n  complexity: number;\n  canonical: (ops, options) => BoxedExpression | null;\n  evaluate:   | (ops, options) => BoxedExpression | undefined\n     | BoxedExpression;\n  evaluateAsync: (ops, options) => Promise<BoxedExpression | undefined>;\n  evalDimension: (args, options) => BoxedExpression;\n  xcompile: (expr) => CompiledExpression;\n  eq: (a, b) => boolean | undefined;\n  neq: (a, b) => boolean | undefined;\n  collection: CollectionHandlers;\n};\n"})}),(0,r.jsx)(n.p,{children:"Definition record for a function."}),(0,r.jsx)(n.h4,{id:"operatordefinitionsignature",children:"OperatorDefinition.signature?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional signature: \n  | Type\n  | TypeString\n  | BoxedType;\n"})}),(0,r.jsx)(n.p,{children:"The function signature, describing the type of the arguments and the\nreturn type."}),(0,r.jsxs)(n.p,{children:["If a ",(0,r.jsx)(n.code,{children:"type"})," handler is provided, the return type of the function should\nbe a subtype of the return type in the signature."]}),(0,r.jsx)(n.h4,{id:"operatordefinitiontype",children:"OperatorDefinition.type()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional type: (ops, options) => \n  | Type\n  | TypeString\n  | BoxedType\n  | undefined;\n"})}),(0,r.jsx)(n.p,{children:"The type of the result (return type) based on the type of\nthe arguments."}),(0,r.jsx)(n.p,{children:"Should be a subtype of the type indicated by the signature."}),(0,r.jsxs)(n.p,{children:["For example, if the signature is ",(0,r.jsx)(n.code,{children:"(number) -> real"}),", the type of the\nresult could be ",(0,r.jsx)(n.code,{children:"real"})," or ",(0,r.jsx)(n.code,{children:"integer"}),", but not ",(0,r.jsx)(n.code,{children:"complex"}),"."]}),(0,r.jsxs)(n.admonition,{title:"Note",type:"info",children:[(0,r.jsx)(n.p,{children:"Do not evaluate the arguments."}),(0,r.jsx)(n.p,{children:"However, the type of the arguments can be used to determine the type of\nthe result."})]}),(0,r.jsx)(n.h4,{id:"operatordefinitionsgn",children:"OperatorDefinition.sgn()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional sgn: (ops, options) => Sign | undefined;\n"})}),(0,r.jsx)(n.p,{children:"Return the sign of the function expression."}),(0,r.jsxs)(n.p,{children:["If the sign cannot be determined, return ",(0,r.jsx)(n.code,{children:"undefined"}),"."]}),(0,r.jsx)(n.p,{children:"When determining the sign, only literal values and the values of\nsymbols, if they are literals, should be considered."}),(0,r.jsx)(n.p,{children:"Do not evaluate the arguments."}),(0,r.jsx)(n.p,{children:"However, the type and sign of the arguments can be used to determine the\nsign."}),(0,r.jsx)(n.h4,{id:"operatordefinitionispositive",children:"OperatorDefinition.isPositive?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly optional isPositive: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["The value of this expression is > 0, same as ",(0,r.jsx)(n.code,{children:"isGreater(0)"})]}),(0,r.jsx)(n.h4,{id:"operatordefinitionisnonnegative",children:"OperatorDefinition.isNonNegative?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly optional isNonNegative: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["The value of this expression is >= 0, same as ",(0,r.jsx)(n.code,{children:"isGreaterEqual(0)"})]}),(0,r.jsx)(n.h4,{id:"operatordefinitionisnegative",children:"OperatorDefinition.isNegative?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly optional isNegative: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["The value of this expression is < 0, same as ",(0,r.jsx)(n.code,{children:"isLess(0)"})]}),(0,r.jsx)(n.h4,{id:"operatordefinitionisnonpositive",children:"OperatorDefinition.isNonPositive?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly optional isNonPositive: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["The  value of this expression is <= 0, same as ",(0,r.jsx)(n.code,{children:"isLessEqual(0)"})]}),(0,r.jsx)(n.h4,{id:"operatordefinitioneven",children:"OperatorDefinition.even()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional even: (ops, options) => boolean | undefined;\n"})}),(0,r.jsxs)(n.p,{children:["Return ",(0,r.jsx)(n.code,{children:"true"})," if the function expression is even, ",(0,r.jsx)(n.code,{children:"false"})," if it is odd\nand ",(0,r.jsx)(n.code,{children:"undefined"})," if it is neither (for example if it is not a number,\nor if it is a complex number)."]}),(0,r.jsx)(n.h4,{id:"operatordefinitioncomplexity",children:"OperatorDefinition.complexity?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional complexity: number;\n"})}),(0,r.jsx)(n.p,{children:"A number used to order arguments."}),(0,r.jsx)(n.p,{children:"Argument with higher complexity are placed after arguments with\nlower complexity when ordered canonically in commutative functions."}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Additive functions: 1000-1999"}),"\n",(0,r.jsx)(n.li,{children:"Multiplicative functions: 2000-2999"}),"\n",(0,r.jsx)(n.li,{children:"Root and power functions: 3000-3999"}),"\n",(0,r.jsx)(n.li,{children:"Log functions: 4000-4999"}),"\n",(0,r.jsx)(n.li,{children:"Trigonometric functions: 5000-5999"}),"\n",(0,r.jsx)(n.li,{children:"Hypertrigonometric functions: 6000-6999"}),"\n",(0,r.jsx)(n.li,{children:"Special functions (factorial, Gamma, ...): 7000-7999"}),"\n",(0,r.jsx)(n.li,{children:"Collections: 8000-8999"}),"\n",(0,r.jsx)(n.li,{children:"Inert and styling:  9000-9999"}),"\n",(0,r.jsx)(n.li,{children:"Logic: 10000-10999"}),"\n",(0,r.jsx)(n.li,{children:"Relational: 11000-11999"}),"\n"]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Default"}),": 100,000"]}),(0,r.jsx)(n.h4,{id:"operatordefinitioncanonical",children:"OperatorDefinition.canonical()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional canonical: (ops, options) => BoxedExpression | null;\n"})}),(0,r.jsxs)(n.p,{children:["Return the canonical form of the expression with the arguments ",(0,r.jsx)(n.code,{children:"args"}),"."]}),(0,r.jsxs)(n.p,{children:["The arguments (",(0,r.jsx)(n.code,{children:"args"}),") may not be in canonical form. If necessary, they\ncan be put in canonical form."]}),(0,r.jsx)(n.p,{children:"This handler should validate the type and number of the arguments\n(arity)."}),(0,r.jsxs)(n.p,{children:["If a required argument is missing, it should be indicated with a\n",(0,r.jsx)(n.code,{children:'["Error", "\'missing"]'})," expression. If more arguments than expected\nare present, this should be indicated with an\n",(0,r.jsx)(n.code,{children:'["Error", "\'unexpected-argument\'"]'})," error expression"]}),(0,r.jsxs)(n.p,{children:["If the type of an argument is not compatible, it should be indicated\nwith an ",(0,r.jsx)(n.code,{children:"incompatible-type"})," error."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:'["Sequence"]'})," expressions are not folded and need to be handled\nexplicitly."]}),(0,r.jsx)(n.p,{children:"If the function is associative, idempotent or an involution,\nthis handler should account for it. Notably, if it is commutative, the\narguments should be sorted in canonical order."}),(0,r.jsxs)(n.p,{children:["Values of symbols should not be substituted, unless they have\na ",(0,r.jsx)(n.code,{children:"holdUntil"})," attribute of ",(0,r.jsx)(n.code,{children:'"never"'}),"."]}),(0,r.jsxs)(n.p,{children:["The handler should not consider the value or any assumptions about any\nof the arguments that are symbols or functions (i.e. ",(0,r.jsx)(n.code,{children:"arg.isZero"}),",\n",(0,r.jsx)(n.code,{children:"arg.isInteger"}),", etc...) since those may change over time."]}),(0,r.jsx)(n.p,{children:"The result of the handler should be a canonical expression."}),(0,r.jsxs)(n.p,{children:["If the arguments do not match, they should be replaced with an\nappropriate ",(0,r.jsx)(n.code,{children:'["Error"]'})," expression. If the expression cannot be put in\ncanonical form, the handler should return ",(0,r.jsx)(n.code,{children:"null"}),"."]}),(0,r.jsx)(n.h4,{id:"operatordefinitionevaluate",children:"OperatorDefinition.evaluate?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional evaluate: \n  | (ops, options) => BoxedExpression | undefined\n  | BoxedExpression;\n"})}),(0,r.jsx)(n.p,{children:"Evaluate a function expression."}),(0,r.jsxs)(n.p,{children:["When the handler is invoked, the arguments have been evaluated, except\nif the ",(0,r.jsx)(n.code,{children:"lazy"})," option is set to ",(0,r.jsx)(n.code,{children:"true"}),"."]}),(0,r.jsx)(n.p,{children:"It is not necessary to further simplify or evaluate the arguments."}),(0,r.jsxs)(n.p,{children:["If performing numerical calculations and ",(0,r.jsx)(n.code,{children:"options.numericalApproximation"}),"\nis ",(0,r.jsx)(n.code,{children:"false"})," return an exact numeric value, for example return a rational\nnumber or a square root, rather than a floating point approximation.\nUse ",(0,r.jsx)(n.code,{children:"ce.number()"})," to create the numeric value."]}),(0,r.jsxs)(n.p,{children:["If the expression cannot be evaluated, due to the values, types, or\nassumptions about its arguments, return ",(0,r.jsx)(n.code,{children:"undefined"})," or\nan ",(0,r.jsx)(n.code,{children:'["Error"]'})," expression."]}),(0,r.jsx)(n.h4,{id:"operatordefinitionevaluateasync",children:"OperatorDefinition.evaluateAsync()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional evaluateAsync: (ops, options) => Promise<BoxedExpression | undefined>;\n"})}),(0,r.jsxs)(n.p,{children:["An asynchronous version of ",(0,r.jsx)(n.code,{children:"evaluate"}),"."]}),(0,r.jsx)(n.h4,{id:"operatordefinitionevaldimension",children:"OperatorDefinition.evalDimension()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional evalDimension: (args, options) => BoxedExpression;\n"})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"Experimental"})})}),(0,r.jsx)(n.p,{children:"Dimensional analysis"}),(0,r.jsx)(n.h4,{id:"operatordefinitionxcompile",children:"OperatorDefinition.xcompile()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional xcompile: (expr) => CompiledExpression;\n"})}),(0,r.jsx)(n.p,{children:"Return a compiled (optimized) expression."})]}),"\n",(0,r.jsx)(n.h3,{id:"basedefinition",children:"BaseDefinition"}),"\n",(0,r.jsx)(n.p,{children:"Metadata common to both symbols and functions."}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"basedefinitiondescription",children:"BaseDefinition.description"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"description: string | string[];\n"})}),(0,r.jsx)(n.p,{children:"If a string, a short description, about one line long."}),(0,r.jsx)(n.p,{children:"Otherwise, a list of strings, each string a paragraph."}),(0,r.jsx)(n.p,{children:"May contain Markdown."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"basedefinitionexamples",children:"BaseDefinition.examples"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"examples: string | string[];\n"})}),(0,r.jsx)(n.p,{children:"A list of examples of how to use this symbol or operator."}),(0,r.jsxs)(n.p,{children:["Each example is a string, which can be a MathJSON expression or LaTeX, bracketed by ",(0,r.jsx)(n.code,{children:"$"})," signs.\nFor example, ",(0,r.jsx)(n.code,{children:'["Add", 1, 2]'})," or ",(0,r.jsx)(n.code,{children:"$\\\\sin(\\\\pi/4)$"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"basedefinitionurl",children:"BaseDefinition.url"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"url: string;\n"})}),(0,r.jsx)(n.p,{children:"A URL pointing to more information about this symbol or operator."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"basedefinitionwikidata",children:"BaseDefinition.wikidata"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"wikidata: string;\n"})}),(0,r.jsx)(n.p,{children:"A short string representing an entry in a wikibase."}),(0,r.jsxs)(n.p,{children:["For example ",(0,r.jsx)(n.code,{children:'"Q167"'})," is the ",(0,r.jsx)(n.a,{href:"https://www.wikidata.org/wiki/Q167",children:"wikidata entry"}),"\nfor the ",(0,r.jsx)(n.code,{children:"Pi"})," constant."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"basedefinitionisconstant",children:"BaseDefinition.isConstant?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly optional isConstant: boolean;\n"})}),(0,r.jsx)(n.p,{children:"If true, the value or type of the definition cannot be changed"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"symboldefinition",children:"SymbolDefinition"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type SymbolDefinition = OneOf<[ValueDefinition, OperatorDefinition]>;\n"})}),(0,r.jsx)(n.p,{children:"A table mapping symbols to their definition."}),(0,r.jsx)(n.p,{children:"Symbols should be valid MathJSON symbols. In addition, the\nfollowing rules are recommended:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use only latin letters, digits and ",(0,r.jsx)(n.code,{children:"-"}),": ",(0,r.jsx)(n.code,{children:"/[a-zA-Z0-9-]+/"})]}),"\n",(0,r.jsxs)(n.li,{children:["The first character should be a letter: ",(0,r.jsx)(n.code,{children:"/^[a-zA-Z]/"})]}),"\n",(0,r.jsxs)(n.li,{children:["Functions and symbols exported from a library should start with an uppercase letter ",(0,r.jsx)(n.code,{children:"/^[A-Z]/"})]}),"\n"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"symboldefinitions",children:"SymbolDefinitions"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type SymbolDefinitions = Readonly<{}>;\n"})})]}),"\n",(0,r.jsx)(n.h3,{id:"basecollectionhandlers",children:"BaseCollectionHandlers"}),"\n",(0,r.jsx)(n.p,{children:"These handlers are the primitive operations that can be performed on\nall collections, indexed or not."}),"\n",(0,r.jsx)(n.h4,{id:"definitions-1",children:"Definitions"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"basecollectionhandlersiterator",children:"BaseCollectionHandlers.iterator()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"iterator: (collection) => Iterator<BoxedExpression, undefined, any>;\n"})}),(0,r.jsx)(n.p,{children:"Return an iterator that iterates over the elements of the collection."}),(0,r.jsx)(n.p,{children:"The order in which the elements are returned is not defined. Requesting\ntwo iterators on the same collection may return the elements in a\ndifferent order."})]}),"\n",(0,r.jsx)(n.h4,{id:"other-1",children:"Other"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"basecollectionhandlerscount",children:"BaseCollectionHandlers.count()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"count: (collection) => number;\n"})}),(0,r.jsx)(n.p,{children:"Return the number of elements in the collection."}),(0,r.jsx)(n.p,{children:"An empty collection has a count of 0."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"basecollectionhandlersisempty",children:"BaseCollectionHandlers.isEmpty()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional isEmpty: (collection) => boolean;\n"})}),(0,r.jsx)(n.p,{children:"Optional flag to quickly check if the collection is empty, without having to count exactly how may elements it has (useful for lazy evaluation)."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"basecollectionhandlersisfinite",children:"BaseCollectionHandlers.isFinite()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional isFinite: (collection) => boolean;\n"})}),(0,r.jsx)(n.p,{children:"Optional flag to quickly check if the collection is finite, without having to count exactly how many elements it has (useful for lazy evaluation)."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"basecollectionhandlersislazy",children:"BaseCollectionHandlers.isLazy()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional isLazy: (collection) => boolean;\n"})}),(0,r.jsxs)(n.p,{children:["Return ",(0,r.jsx)(n.code,{children:"true"})," if the collection is lazy, ",(0,r.jsx)(n.code,{children:"false"})," otherwise.\nIf the collection is lazy, it means that the elements are not\ncomputed until they are needed, for example when iterating over the\ncollection."]}),(0,r.jsxs)(n.p,{children:["Default: ",(0,r.jsx)(n.code,{children:"true"})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"basecollectionhandlerscontains",children:"BaseCollectionHandlers.contains()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional contains: (collection, target) => boolean;\n"})}),(0,r.jsxs)(n.p,{children:["Return ",(0,r.jsx)(n.code,{children:"true"})," if the target expression is in the collection,\n",(0,r.jsx)(n.code,{children:"false"})," otherwise."]}),(0,r.jsxs)(n.p,{children:["Return ",(0,r.jsx)(n.code,{children:"undefined"})," if the membership cannot be determined."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"basecollectionhandlerssubsetof",children:"BaseCollectionHandlers.subsetOf()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional subsetOf: (collection, other, strict) => boolean;\n"})}),(0,r.jsxs)(n.p,{children:["Return ",(0,r.jsx)(n.code,{children:"true"})," if all the elements of ",(0,r.jsx)(n.code,{children:"other"})," are in ",(0,r.jsx)(n.code,{children:"collection"}),".\nBoth ",(0,r.jsx)(n.code,{children:"collection"})," and ",(0,r.jsx)(n.code,{children:"other"})," are collections."]}),(0,r.jsxs)(n.p,{children:["If strict is ",(0,r.jsx)(n.code,{children:"true"}),", the subset must be strict, that is, ",(0,r.jsx)(n.code,{children:"collection"})," must\nhave more elements than ",(0,r.jsx)(n.code,{children:"other"}),"."]}),(0,r.jsxs)(n.p,{children:["Return ",(0,r.jsx)(n.code,{children:"undefined"})," if the subset relation cannot be determined."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"basecollectionhandlerseltsgn",children:"BaseCollectionHandlers.eltsgn()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional eltsgn: (collection) => Sign;\n"})}),(0,r.jsx)(n.p,{children:"Return the sign of all the elements of the collection."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"basecollectionhandlerselttype",children:"BaseCollectionHandlers.elttype()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional elttype: (collection) => Type;\n"})}),(0,r.jsx)(n.p,{children:"Return the widest type of all the elements in the collection"})]}),"\n",(0,r.jsx)(n.h3,{id:"indexedcollectionhandlers",children:"IndexedCollectionHandlers"}),"\n",(0,r.jsx)(n.p,{children:"These additional collection handlers are applicable to indexed\ncollections only."}),"\n",(0,r.jsx)(n.p,{children:"The elements of an indexed collection can be accessed by index, and\nthe order of the elements is defined."}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"indexedcollectionhandlersat",children:"IndexedCollectionHandlers.at()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"at: (collection, index) => BoxedExpression;\n"})}),(0,r.jsx)(n.p,{children:"Return the element at the specified index."}),(0,r.jsxs)(n.p,{children:["The first element is ",(0,r.jsx)(n.code,{children:"at(1)"}),", the last element is ",(0,r.jsx)(n.code,{children:"at(-1)"}),"."]}),(0,r.jsxs)(n.p,{children:["If the index is <0, return the element at index ",(0,r.jsx)(n.code,{children:"count() + index + 1"}),"."]}),(0,r.jsxs)(n.p,{children:["The index can also be a string for example for records. The set of valid\nkeys is returned by the ",(0,r.jsx)(n.code,{children:"keys()"})," handler."]}),(0,r.jsxs)(n.p,{children:["If the index is invalid, return ",(0,r.jsx)(n.code,{children:"undefined"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"indexedcollectionhandlersindexwhere",children:"IndexedCollectionHandlers.indexWhere()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"indexWhere: (collection, predicate) => number;\n"})}),(0,r.jsx)(n.p,{children:"Return the index of the first element that matches the predicate."}),(0,r.jsxs)(n.p,{children:["If no element matches the predicate, return ",(0,r.jsx)(n.code,{children:"undefined"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"collectionhandlers",children:"CollectionHandlers"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type CollectionHandlers = BaseCollectionHandlers & Partial<IndexedCollectionHandlers>;\n"})}),(0,r.jsx)(n.p,{children:"The collection handlers are the primitive operations that can be\nperformed on collections, such as lists, sets, tuples, etc..."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"taggedvaluedefinition",children:"TaggedValueDefinition"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type TaggedValueDefinition = {\n  value: BoxedValueDefinition;\n};\n"})}),(0,r.jsx)(n.p,{children:"The definition for a value, represented as a tagged object literal."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"taggedoperatordefinition",children:"TaggedOperatorDefinition"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type TaggedOperatorDefinition = {\n  operator: BoxedOperatorDefinition;\n};\n"})}),(0,r.jsx)(n.p,{children:"The definition for an operator, represented as a tagged object literal."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"boxeddefinition",children:"BoxedDefinition"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type BoxedDefinition = \n  | TaggedValueDefinition\n  | TaggedOperatorDefinition;\n"})}),(0,r.jsx)(n.p,{children:"A definition can be either a value or an operator."}),(0,r.jsx)(n.p,{children:"It is collected in a tagged object literal, instead of being a simple union\ntype, so that the type of the definition can be changed while keeping\nreferences to the definition in bound expressions."})]}),"\n",(0,r.jsx)(n.h3,{id:"boxedbasedefinition",children:"BoxedBaseDefinition"}),"\n",(0,r.jsx)(n.h4,{id:"extends",children:"Extends"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Partial"}),"<",(0,r.jsx)(n.a,{href:"#basedefinition-1",children:(0,r.jsx)(n.code,{children:"BaseDefinition"})}),">"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"extended-by",children:"Extended by"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#boxedvaluedefinition",children:(0,r.jsx)(n.code,{children:"BoxedValueDefinition"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#boxedoperatordefinition",children:(0,r.jsx)(n.code,{children:"BoxedOperatorDefinition"})})}),"\n"]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedbasedefinitioncollection",children:"BoxedBaseDefinition.collection?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional collection: CollectionHandlers;\n"})}),(0,r.jsx)(n.p,{children:"If this is the definition of a collection, the set of primitive operations\nthat can be performed on this collection (counting the number of elements,\nenumerating it, etc...)."})]}),"\n",(0,r.jsx)(n.h3,{id:"boxedvaluedefinition",children:"BoxedValueDefinition"}),"\n",(0,r.jsx)(n.h4,{id:"extends-1",children:"Extends"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#boxedbasedefinition",children:(0,r.jsx)(n.code,{children:"BoxedBaseDefinition"})})}),"\n"]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedvaluedefinitionholduntil",children:"BoxedValueDefinition.holdUntil"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'holdUntil: "never" | "evaluate" | "N";\n'})}),(0,r.jsx)(n.p,{children:"If the symbol has a value, it is held as indicated in the table below.\nA green checkmark indicate that the symbol is substituted."}),(0,r.jsx)("div",{className:"symbols-table",children:(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{style:{textAlign:"left"},children:"Operation"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:(0,r.jsx)(n.code,{children:'"never"'})}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:(0,r.jsx)(n.code,{children:'"evaluate"'})}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:(0,r.jsx)(n.code,{children:'"N"'})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"canonical()"})}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"(X)"}),(0,r.jsx)(n.td,{style:{textAlign:"center"}}),(0,r.jsx)(n.td,{style:{textAlign:"center"}})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"evaluate()"})}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"(X)"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"(X)"}),(0,r.jsx)(n.td,{style:{textAlign:"center"}})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:'"N()"'})}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"(X)"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"(X)"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"(X)"})]})]})]})}),(0,r.jsx)(n.p,{children:"Some examples:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ImaginaryUnit"})," has ",(0,r.jsx)(n.code,{children:"holdUntil: 'never'"}),": it is substituted during canonicalization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"x"})," has ",(0,r.jsx)(n.code,{children:"holdUntil: 'evaluate'"})," (variables)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Pi"})," has ",(0,r.jsx)(n.code,{children:"holdUntil: 'N'"})," (special numeric constant)"]}),"\n"]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Default:"})," ",(0,r.jsx)(n.code,{children:"evaluate"})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedvaluedefinitionvalue",children:"BoxedValueDefinition.value"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly value: BoxedExpression;\n"})}),(0,r.jsx)(n.p,{children:"This is either the initial value of the symbol (i.e. when a new\nevaluation context is created), or its constant value, if a constant.\nOtherwise, the current value is tracked in the evaluation context."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedvaluedefinitioneq",children:"BoxedValueDefinition.eq()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional eq: (a) => boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedvaluedefinitionneq",children:"BoxedValueDefinition.neq()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional neq: (a) => boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedvaluedefinitioncmp",children:"BoxedValueDefinition.cmp()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'optional cmp: (a) => ">" | "<" | "=";\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedvaluedefinitioninferredtype",children:"BoxedValueDefinition.inferredType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"inferredType: boolean;\n"})}),(0,r.jsx)(n.p,{children:"True if the type has been inferred. An inferred type can be updated as\nmore information becomes available."}),(0,r.jsx)(n.p,{children:"A type that is not inferred, but has been set explicitly, cannot be updated."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedvaluedefinitiontype",children:"BoxedValueDefinition.type"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"operatordefinitionflags",children:"OperatorDefinitionFlags"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type OperatorDefinitionFlags = {\n  lazy: boolean;\n  scoped: boolean;\n  broadcastable: boolean;\n  associative: boolean;\n  commutative: boolean;\n  commutativeOrder: (a, b) => number | undefined;\n  idempotent: boolean;\n  involution: boolean;\n  pure: boolean;\n};\n"})}),(0,r.jsx)(n.p,{children:"An operator definition can have some flags to indicate specific\nproperties of the operator."})]}),"\n",(0,r.jsx)(n.h3,{id:"boxedoperatordefinition",children:"BoxedOperatorDefinition"}),"\n",(0,r.jsx)(n.p,{children:"The definition includes information specific about an operator, such as\nhandlers to canonicalize or evaluate a function expression with this\noperator."}),"\n",(0,r.jsx)(n.h4,{id:"extends-2",children:"Extends"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#boxedbasedefinition",children:(0,r.jsx)(n.code,{children:"BoxedBaseDefinition"})}),".",(0,r.jsx)(n.a,{href:"#operatordefinitionflags",children:(0,r.jsx)(n.code,{children:"OperatorDefinitionFlags"})})]}),"\n"]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedoperatordefinitioncomplexity",children:"BoxedOperatorDefinition.complexity"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"complexity: number;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedoperatordefinitioninferredsignature",children:"BoxedOperatorDefinition.inferredSignature"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"inferredSignature: boolean;\n"})}),(0,r.jsx)(n.p,{children:"If true, the signature was inferred from usage and may be modified\nas more information becomes available."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedoperatordefinitionsignature",children:"BoxedOperatorDefinition.signature"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"signature: BoxedType;\n"})}),(0,r.jsx)(n.p,{children:"The type of the arguments and return value of this function"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedoperatordefinitiontype",children:"BoxedOperatorDefinition.type()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional type: (ops, options) => \n  | string\n  | AlgebraicType\n  | NegationType\n  | CollectionType\n  | ListType\n  | SetType\n  | RecordType\n  | DictionaryType\n  | TupleType\n  | SymbolType\n  | ExpressionType\n  | NumericType\n  | FunctionSignature\n  | ValueType\n  | TypeReference\n  | BoxedType;\n"})}),(0,r.jsxs)(n.p,{children:["If present, this handler can be used to more precisely determine the\nreturn type based on the type of the arguments. The arguments themselves\nshould ",(0,r.jsx)(n.em,{children:"not"})," be evaluated, only their types should be used."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedoperatordefinitionsgn",children:"BoxedOperatorDefinition.sgn()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional sgn: (ops, options) => Sign;\n"})}),(0,r.jsx)(n.p,{children:"If present, this handler can be used to determine the sign of the\nreturn value of the function, based on the sign and type of its\narguments."}),(0,r.jsxs)(n.p,{children:["The arguments themselves should ",(0,r.jsx)(n.em,{children:"not"})," be evaluated, only their types and\nsign should be used."]}),(0,r.jsx)(n.p,{children:"This can be used in some case for example to determine when certain\nsimplifications are valid."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedoperatordefinitioneq",children:"BoxedOperatorDefinition.eq()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional eq: (a, b) => boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedoperatordefinitionneq",children:"BoxedOperatorDefinition.neq()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional neq: (a, b) => boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedoperatordefinitioncanonical",children:"BoxedOperatorDefinition.canonical()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional canonical: (ops, options) => BoxedExpression;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedoperatordefinitionevaluate",children:"BoxedOperatorDefinition.evaluate()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional evaluate: (ops, options) => BoxedExpression;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedoperatordefinitionevaluateasync",children:"BoxedOperatorDefinition.evaluateAsync()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional evaluateAsync: (ops, options?) => Promise<BoxedExpression>;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedoperatordefinitionevaldimension",children:"BoxedOperatorDefinition.evalDimension()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional evalDimension: (ops, options) => BoxedExpression;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedoperatordefinitioncompile",children:"BoxedOperatorDefinition.compile()?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional compile: (expr) => CompiledExpression;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"scope",children:"Scope"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Scope = {\n  parent: Scope | null;\n  bindings: Map<string, BoxedDefinition>;\n  types: Record<string, TypeReference>;\n};\n"})}),(0,r.jsx)(n.p,{children:"A lexical scope is a table mapping symbols to their definitions. The\nsymbols are the names of the variables, unknowns and functions in the scope."}),(0,r.jsx)(n.p,{children:"The lexical scope is used to resolve the metadata about symbols, such as\ntheir type, whether they are constant, etc..."}),(0,r.jsx)(n.p,{children:"It does not resolve the values of the symbols, since those depend on the\nevaluation context. For example, the local variables of a recursive function\nwill have the same lexical scope, but different values in each evaluation\ncontext."})]}),"\n",(0,r.jsx)(n.h2,{id:"latex-parsing-and-serialization",children:"Latex Parsing and Serialization"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"latextoken",children:"LatexToken"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type LatexToken = string | "<{>" | "<}>" | "<space>" | "<$>" | "<$$>";\n'})}),(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"LatexToken"})," is a token as returned by ",(0,r.jsx)(n.code,{children:"Parser.peek"}),"."]}),(0,r.jsx)(n.p,{children:"It can be one of the indicated tokens, or a string that starts with a\n`` for LaTeX commands, or a LaTeX character which includes digits,\nletters and punctuation."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"latexstring",children:"LatexString"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type LatexString = string;\n"})}),(0,r.jsxs)(n.p,{children:["A LatexString is a regular string of LaTeX, for example:\n",(0,r.jsx)(n.code,{children:"\\frac{\\pi}{2}"})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"delimiter",children:"Delimiter"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type Delimiter = \n  | "."\n  | ")"\n  | "("\n  | "]"\n  | "["\n  | "{"\n  | "}"\n  | "<"\n  | ">"\n  | "|"\n  | "||"\n  | "\\lceil"\n  | "\\rceil"\n  | "\\lfloor"\n  | "\\rfloor"\n  | "\\llbracket"\n  | "\\rrbracket";\n'})}),(0,r.jsxs)(n.p,{children:["Open and close delimiters that can be used with ",(0,r.jsx)(n.a,{href:"#matchfixentry",children:(0,r.jsx)(n.code,{children:"MatchfixEntry"})}),"\nrecord to define new LaTeX dictionary entries."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"delimiterscale",children:"DelimiterScale"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type DelimiterScale = "normal" | "scaled" | "big" | "none";\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"librarycategory",children:"LibraryCategory"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type LibraryCategory = \n  | "algebra"\n  | "arithmetic"\n  | "calculus"\n  | "collections"\n  | "control-structures"\n  | "combinatorics"\n  | "complex"\n  | "core"\n  | "data-structures"\n  | "dimensions"\n  | "domains"\n  | "linear-algebra"\n  | "logic"\n  | "number-theory"\n  | "numeric"\n  | "other"\n  | "physics"\n  | "polynomials"\n  | "relop"\n  | "sets"\n  | "statistics"\n  | "styling"\n  | "symbols"\n  | "trigonometry"\n  | "units";\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"precedence",children:"Precedence"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Precedence = number;\n"})}),(0,r.jsxs)(n.admonition,{title:"THEORY OF OPERATIONS",type:"info",children:[(0,r.jsx)(n.p,{children:"The precedence of an operator is a number that indicates the order in which\noperators are applied."}),(0,r.jsxs)(n.p,{children:["For example, in ",(0,r.jsx)(n.code,{children:"1 + 2 * 3"}),", the ",(0,r.jsx)(n.code,{children:"*"})," operator has a ",(0,r.jsx)(n.strong,{children:"higher"})," precedence\nthan the ",(0,r.jsx)(n.code,{children:"+"})," operator, so it is applied first."]}),(0,r.jsx)(n.p,{children:'The precedence ranges from 0 to 1000. The larger the number, the higher the\nprecedence, the more "binding" the operator is.'}),(0,r.jsx)(n.h3,{id:"operator-precedence-table",children:"Operator Precedence Table"}),(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Precedence"}),(0,r.jsx)(n.th,{children:"Operators"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"880"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\lnot"})," ",(0,r.jsx)(n.code,{children:"\\neg"})," ",(0,r.jsx)(n.code,{children:"++"})," ",(0,r.jsx)(n.code,{children:"--"})," ",(0,r.jsx)(n.code,{children:"+"})," ",(0,r.jsx)(n.code,{children:"-"})," (prefix)"]}),(0,r.jsx)(n.td,{children:"Prefix/postfix unary"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"810"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"!"})," ",(0,r.jsx)(n.code,{children:"'"})," ",(0,r.jsx)(n.code,{children:"!!"})," ",(0,r.jsx)(n.code,{children:"'''"})]}),(0,r.jsx)(n.td,{children:"Factorial, prime (postfix)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"800"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"_"})," (subscript)"]}),(0,r.jsx)(n.td,{children:"Subscript"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"780"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\degree"})," ",(0,r.jsx)(n.code,{children:"\\prime"})]}),(0,r.jsx)(n.td,{children:"Degree, prime symbols"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"740"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"\\%"})}),(0,r.jsx)(n.td,{children:"Percent"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"720"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"/"})," (inline division)"]}),(0,r.jsx)(n.td,{children:"Inline division"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"700"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"^"})," ",(0,r.jsx)(n.code,{children:"\\overset"})," ",(0,r.jsx)(n.code,{children:"\\underset"})]}),(0,r.jsx)(n.td,{children:"Exponentiation, over/underscript"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"650"})}),(0,r.jsxs)(n.td,{children:["(invisible multiply) ",(0,r.jsx)(n.code,{children:"\\cdot"})]}),(0,r.jsx)(n.td,{children:"Implicit multiplication"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"600"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\div"})," ",(0,r.jsx)(n.code,{children:"\\frac"})]}),(0,r.jsx)(n.td,{children:"Division"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"390"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\times"})," ",(0,r.jsx)(n.code,{children:"*"})," ",(0,r.jsx)(n.code,{children:"/"})]}),(0,r.jsx)(n.td,{children:"Multiplication"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"350"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\cup"})," ",(0,r.jsx)(n.code,{children:"\\cap"})]}),(0,r.jsx)(n.td,{children:"Set union/intersection"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"275"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"+"})," ",(0,r.jsx)(n.code,{children:"-"})," (infix)"]}),(0,r.jsx)(n.td,{children:"Addition, subtraction"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"270"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\to"})," ",(0,r.jsx)(n.code,{children:"\\rightarrow"})," ",(0,r.jsx)(n.code,{children:"\\mapsto"})]}),(0,r.jsx)(n.td,{children:"Arrows"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"265"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\setminus"})," ",(0,r.jsx)(n.code,{children:"\\smallsetminus"})," ",(0,r.jsx)(n.code,{children:":"})," (range)"]}),(0,r.jsx)(n.td,{children:"Set difference, range"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"260"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:":="})}),(0,r.jsx)(n.td,{children:"Assignment"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"255"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"\\ne"})}),(0,r.jsx)(n.td,{children:"Not equal"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"250"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"\\not\\approxeq"})}),(0,r.jsx)(n.td,{children:"Not approximately equal"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"247"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"\\approx"})}),(0,r.jsx)(n.td,{children:"Approximately"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"245-246"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"="})," ",(0,r.jsx)(n.code,{children:"<"})," ",(0,r.jsx)(n.code,{children:">"})," ",(0,r.jsx)(n.code,{children:"\\lt"})," ",(0,r.jsx)(n.code,{children:"\\gt"})," ",(0,r.jsx)(n.code,{children:"\\nless"})," ",(0,r.jsx)(n.code,{children:"\\ngtr"})]}),(0,r.jsx)(n.td,{children:"Equality, comparison"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"241-244"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\le"})," ",(0,r.jsx)(n.code,{children:"\\leq"})," ",(0,r.jsx)(n.code,{children:"\\ge"})," ",(0,r.jsx)(n.code,{children:"\\geq"})," ",(0,r.jsx)(n.code,{children:">="})]}),(0,r.jsx)(n.td,{children:"Less/greater or equal"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"240"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\in"})," ",(0,r.jsx)(n.code,{children:"\\notin"})," ",(0,r.jsx)(n.code,{children:"\\subset"})," ",(0,r.jsx)(n.code,{children:"\\supset"})," ..."]}),(0,r.jsx)(n.td,{children:"Set membership/relations"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"235"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\land"})," ",(0,r.jsx)(n.code,{children:"\\wedge"})," ",(0,r.jsx)(n.code,{children:"\\&"})]}),(0,r.jsx)(n.td,{children:"Logical AND"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"232"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\veebar"})," ",(0,r.jsx)(n.code,{children:"\\barwedge"})," (Xor, Nand, Nor)"]}),(0,r.jsx)(n.td,{children:"Logical XOR, NAND, NOR"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"230"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\lor"})," ",(0,r.jsx)(n.code,{children:"\\vee"})," ",(0,r.jsx)(n.code,{children:"\\parallel"})]}),(0,r.jsx)(n.td,{children:"Logical OR"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"220"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\implies"})," ",(0,r.jsx)(n.code,{children:"\\Rightarrow"})," ",(0,r.jsx)(n.code,{children:"\\vdash"})," ",(0,r.jsx)(n.code,{children:"\\models"})]}),(0,r.jsx)(n.td,{children:"Implication, entailment"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"219"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\iff"})," ",(0,r.jsx)(n.code,{children:"\\Leftrightarrow"})," ",(0,r.jsx)(n.code,{children:"\\equiv"})]}),(0,r.jsx)(n.td,{children:"Equivalence"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"200"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\forall"})," ",(0,r.jsx)(n.code,{children:"\\exists"})," ",(0,r.jsx)(n.code,{children:"\\exists!"})]}),(0,r.jsx)(n.td,{children:"Quantifiers"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"160"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"\\mid"})," ",(0,r.jsx)(n.code,{children:"\\vert"})," (set builder)"]}),(0,r.jsx)(n.td,{children:"Set builder notation"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"19-20"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:","})," ",(0,r.jsx)(n.code,{children:";"})," ",(0,r.jsx)(n.code,{children:"\\ldots"})]}),(0,r.jsx)(n.td,{children:"Sequence separators"})]})]})]}),(0,r.jsx)(n.h3,{id:"key-relationships",children:"Key Relationships"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Comparisons bind tighter than logic"}),": ",(0,r.jsx)(n.code,{children:"x = 1 \\lor y = 2"})," parses as\n",(0,r.jsx)(n.code,{children:"(x = 1) \\lor (y = 2)"}),", not ",(0,r.jsx)(n.code,{children:"x = (1 \\lor y) = 2"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"AND binds tighter than OR"}),": ",(0,r.jsx)(n.code,{children:"a \\land b \\lor c"})," parses as\n",(0,r.jsx)(n.code,{children:"(a \\land b) \\lor c"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Logic operators bind tighter than implication"}),": ",(0,r.jsx)(n.code,{children:"a \\lor b \\implies c"}),"\nparses as ",(0,r.jsx)(n.code,{children:"(a \\lor b) \\implies c"})]}),"\n"]}),(0,r.jsx)(n.p,{children:"Some constants are defined below for common precedence values."}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": MathML defines\n",(0,r.jsx)(n.a,{href:"https://www.w3.org/TR/2009/WD-MathML3-20090924/appendixc.html",children:"some operator precedence"}),",\nbut it has some issues and inconsistencies. However,\nwhenever possible we adopted the MathML precedence."]}),(0,r.jsxs)(n.p,{children:["The JavaScript operator precedence is documented\n",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence",children:"here"}),"."]})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"terminator",children:"Terminator"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Terminator = {\n  minPrec: Precedence;\n  condition: (parser) => boolean;\n};\n"})}),(0,r.jsx)(n.p,{children:"This indicates a condition under which parsing should stop:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"an operator of a precedence higher than specified has been encountered"}),"\n",(0,r.jsx)(n.li,{children:"the last token has been reached"}),"\n",(0,r.jsx)(n.li,{children:"or if a condition is provided, the condition returns true"}),"\n"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"parsehandler",children:"ParseHandler"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type ParseHandler = \n  | ExpressionParseHandler\n  | SymbolParseHandler\n  | FunctionParseHandler\n  | EnvironmentParseHandler\n  | PostfixParseHandler\n  | InfixParseHandler\n  | MatchfixParseHandler;\n"})}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Custom parsing handler."})}),(0,r.jsx)(n.p,{children:"When this handler is invoked the parser points right after the LaTeX\nfragment that triggered it."}),(0,r.jsxs)(n.p,{children:["Tokens can be consumed with ",(0,r.jsx)(n.code,{children:"parser.nextToken()"})," and other parser methods\nsuch as ",(0,r.jsx)(n.code,{children:"parser.parseGroup()"}),", ",(0,r.jsx)(n.code,{children:"parser.parseOptionalGroup()"}),", etc..."]}),(0,r.jsxs)(n.p,{children:["If it was in an infix or postfix context, ",(0,r.jsx)(n.code,{children:"lhs"})," will represent the\nleft-hand side argument. In a prefix or matchfix context, ",(0,r.jsx)(n.code,{children:"lhs"})," is ",(0,r.jsx)(n.code,{children:"null"}),"."]}),(0,r.jsxs)(n.p,{children:["In a superfix (",(0,r.jsx)(n.code,{children:"^"}),") or subfix (",(0,r.jsx)(n.code,{children:"_"}),") context (that is if the first token of\nthe trigger is ",(0,r.jsx)(n.code,{children:"^"})," or ",(0,r.jsx)(n.code,{children:"_"}),"), ",(0,r.jsx)(n.code,{children:"lhs"})," is ",(0,r.jsx)(n.code,{children:'["Superscript", lhs, rhs]'}),"\nand ",(0,r.jsx)(n.code,{children:'["Subscript", lhs, rhs]'}),", respectively."]}),(0,r.jsxs)(n.p,{children:["The handler should return ",(0,r.jsx)(n.code,{children:"null"})," if the tokens could not be parsed\n(didn't match the syntax that was expected), or the matching expression\notherwise."]}),(0,r.jsxs)(n.p,{children:["If the tokens were parsed but should be ignored, the handler should\nreturn ",(0,r.jsx)(n.code,{children:"Nothing"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"expressionparsehandler",children:"ExpressionParseHandler()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type ExpressionParseHandler = (parser, until?) => Expression | null;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"prefixparsehandler",children:"PrefixParseHandler()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type PrefixParseHandler = (parser, until?) => Expression | null;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"symbolparsehandler",children:"SymbolParseHandler()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type SymbolParseHandler = (parser, until?) => Expression | null;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"functionparsehandler",children:"FunctionParseHandler()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type FunctionParseHandler = (parser, until?) => Expression | null;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"environmentparsehandler",children:"EnvironmentParseHandler()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type EnvironmentParseHandler = (parser, until?) => Expression | null;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"postfixparsehandler",children:"PostfixParseHandler()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type PostfixParseHandler = (parser, lhs, until?) => Expression | null;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"infixparsehandler",children:"InfixParseHandler()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type InfixParseHandler = (parser, lhs, until) => Expression | null;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"matchfixparsehandler",children:"MatchfixParseHandler()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type MatchfixParseHandler = (parser, body) => Expression | null;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"latexargumenttype",children:"LatexArgumentType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type LatexArgumentType = \n  | "{expression}"\n  | "[expression]"\n  | "{text}"\n  | "[text]"\n  | "{unit}"\n  | "[unit]"\n  | "{glue}"\n  | "[glue]"\n  | "{string}"\n  | "[string]"\n  | "{color}"\n  | "[color]";\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"trigger",children:"Trigger"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Trigger = {\n  latexTrigger: LatexString | LatexToken[];\n  symbolTrigger: MathJsonSymbol;\n};\n"})}),(0,r.jsxs)(n.p,{children:["A trigger is the set of tokens that will make an entry in the\nLaTeX dictionary eligible to parse the stream and generate an expression.\nIf the trigger matches, the ",(0,r.jsx)(n.code,{children:"parse"})," handler is called, if available."]}),(0,r.jsxs)(n.p,{children:["The trigger can be specified either as a LaTeX string (",(0,r.jsx)(n.code,{children:"latexTrigger"}),") or\nas an symbol (",(0,r.jsx)(n.code,{children:"symbolTrigger"}),"). A symbol match several\nLaTeX expressions that are equivalent, for example ",(0,r.jsx)(n.code,{children:"\\operatorname{gcd}"})," or\n",(0,r.jsx)(n.code,{children:"\\mathbin{gcd}"}),", match the ",(0,r.jsx)(n.code,{children:'"gcd"'})," symbol"]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"matchfix"})," operators use ",(0,r.jsx)(n.code,{children:"openTrigger"})," and ",(0,r.jsx)(n.code,{children:"closeTrigger"})," instead."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"baseentry",children:"BaseEntry"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type BaseEntry = {\n  name: MathJsonSymbol;\n  serialize: LatexString | SerializeHandler;\n};\n"})}),(0,r.jsx)(n.p,{children:"Maps a string of LaTeX tokens to a function or symbol and vice-versa."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"defaultentry",children:"DefaultEntry"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type DefaultEntry = BaseEntry & Trigger & {\n  parse:   | Expression\n     | ExpressionParseHandler;\n};\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"expressionentry",children:"ExpressionEntry"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type ExpressionEntry = BaseEntry & Trigger & {\n  kind: "expression";\n  parse:   | Expression\n     | ExpressionParseHandler;\n  precedence: Precedence;\n};\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"matchfixentry",children:"MatchfixEntry"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type MatchfixEntry = BaseEntry & {\n  kind: "matchfix";\n  openTrigger: Delimiter | LatexToken[];\n  closeTrigger: Delimiter | LatexToken[];\n  parse: MatchfixParseHandler;\n};\n'})}),(0,r.jsx)(n.h4,{id:"matchfixentryopentrigger",children:"MatchfixEntry.openTrigger"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"openTrigger: Delimiter | LatexToken[];\n"})}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"kind"})," is ",(0,r.jsx)(n.code,{children:"'matchfix'"}),": the ",(0,r.jsx)(n.code,{children:"openTrigger"})," and ",(0,r.jsx)(n.code,{children:"closeTrigger"}),"\nproperties are required."]}),(0,r.jsx)(n.h4,{id:"matchfixentryparse",children:"MatchfixEntry.parse?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional parse: MatchfixParseHandler;\n"})}),(0,r.jsx)(n.p,{children:"When invoked, the parser is pointing after the close delimiter.\nThe argument of the handler is the body, i.e. the content between\nthe open delimiter and the close delimiter."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"infixentry",children:"InfixEntry"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type InfixEntry = BaseEntry & Trigger & {\n  kind: "infix";\n  associativity: "right" | "left" | "none" | "any";\n  precedence: Precedence;\n  parse: string | InfixParseHandler;\n};\n'})}),(0,r.jsx)(n.h4,{id:"infixentrykind",children:"InfixEntry.kind"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'kind: "infix";\n'})}),(0,r.jsxs)(n.p,{children:["Infix position, with an operand before and an operand after: ",(0,r.jsx)(n.code,{children:"a \u229b b"}),"."]}),(0,r.jsxs)(n.p,{children:["Example: ",(0,r.jsx)(n.code,{children:"+"}),", ",(0,r.jsx)(n.code,{children:"\\times"}),"."]}),(0,r.jsx)(n.h4,{id:"infixentryassociativity",children:"InfixEntry.associativity?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'optional associativity: "right" | "left" | "none" | "any";\n'})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"none"})}),": a ? b ? c -> syntax error"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"any"})}),": a + b + c -> +(a, b, c)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"left"})}),": a / b / c -> /(/(a, b), c)"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"right"})}),": a = b = c -> =(a, =(b, c))"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"any"}),"-associative operators have an unlimited number of arguments"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"left"}),", ",(0,r.jsx)(n.code,{children:"right"})," or ",(0,r.jsx)(n.code,{children:"none"})," associative operators have two arguments"]}),"\n"]}),"\n"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"postfixentry",children:"PostfixEntry"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type PostfixEntry = BaseEntry & Trigger & {\n  kind: "postfix";\n  precedence: Precedence;\n  parse: string | PostfixParseHandler;\n};\n'})}),(0,r.jsx)(n.h4,{id:"postfixentrykind",children:"PostfixEntry.kind"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'kind: "postfix";\n'})}),(0,r.jsxs)(n.p,{children:["Postfix position, with an operand before: ",(0,r.jsx)(n.code,{children:"a \u229b"})]}),(0,r.jsxs)(n.p,{children:["Example: ",(0,r.jsx)(n.code,{children:"!"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"prefixentry",children:"PrefixEntry"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type PrefixEntry = BaseEntry & Trigger & {\n  kind: "prefix";\n  precedence: Precedence;\n  parse: string | PrefixParseHandler;\n};\n'})}),(0,r.jsx)(n.h4,{id:"prefixentrykind",children:"PrefixEntry.kind"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'kind: "prefix";\n'})}),(0,r.jsxs)(n.p,{children:["Prefix position, with an operand after: ",(0,r.jsx)(n.code,{children:"\u229b a"})]}),(0,r.jsxs)(n.p,{children:["Example: ",(0,r.jsx)(n.code,{children:"-"}),", ",(0,r.jsx)(n.code,{children:"\\not"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"environmententry",children:"EnvironmentEntry"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type EnvironmentEntry = BaseEntry & {\n  kind: "environment";\n  parse: EnvironmentParseHandler;\n  symbolTrigger: MathJsonSymbol;\n};\n'})}),(0,r.jsxs)(n.p,{children:["A LaTeX dictionary entry for an environment, that is a LaTeX\nconstruct using ",(0,r.jsx)(n.code,{children:"\\begin{...}...\\end{...}"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"symbolentry",children:"SymbolEntry"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type SymbolEntry = BaseEntry & Trigger & {\n  kind: "symbol";\n  precedence: Precedence;\n  parse:   | Expression\n     | SymbolParseHandler;\n};\n'})}),(0,r.jsx)(n.h4,{id:"symbolentryprecedence",children:"SymbolEntry.precedence?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional precedence: Precedence;\n"})}),(0,r.jsx)(n.p,{children:"Used for appropriate wrapping (i.e. when to surround it with parens)"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"functionentry",children:"FunctionEntry"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type FunctionEntry = BaseEntry & Trigger & {\n  kind: "function";\n  parse:   | Expression\n     | FunctionParseHandler;\n};\n'})}),(0,r.jsx)(n.p,{children:"A function is a symbol followed by:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["some postfix operators such as ",(0,r.jsx)(n.code,{children:"\\prime"})]}),"\n",(0,r.jsx)(n.li,{children:"an optional list of arguments in an enclosure (parentheses)"}),"\n"]}),(0,r.jsxs)(n.p,{children:["For more complex situations, for example implicit arguments or\ninverse functions postfix (i.e. ^",-1,"), use a custom parse handler with a\nentry of kind ",(0,r.jsx)(n.code,{children:"expression"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"latexdictionaryentry",children:"LatexDictionaryEntry"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type LatexDictionaryEntry = OneOf<[\n  | ExpressionEntry\n  | MatchfixEntry\n  | InfixEntry\n  | PostfixEntry\n  | PrefixEntry\n  | SymbolEntry\n  | FunctionEntry\n  | EnvironmentEntry\n| DefaultEntry]>;\n"})}),(0,r.jsx)(n.p,{children:"A dictionary entry is a record that maps a LaTeX token or string of tokens\n( a trigger) to a MathJSON expression or to a parsing handler."}),(0,r.jsx)(n.p,{children:"Set the ComputeEngine.latexDictionary property to an array of\ndictionary entries to define custom LaTeX parsing and serialization."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"parselatexoptions",children:"ParseLatexOptions"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type ParseLatexOptions = NumberFormat & {\n  skipSpace: boolean;\n  parseNumbers: "auto" | "rational" | "decimal" | "never";\n  getSymbolType: (symbol) => BoxedType;\n  parseUnexpectedToken: (lhs, parser) => Expression | null;\n  preserveLatex: boolean;\n  quantifierScope: "tight" | "loose";\n};\n'})}),(0,r.jsxs)(n.p,{children:["The LaTeX parsing options can be used with the ",(0,r.jsx)(n.code,{children:"ce.parse()"})," method."]}),(0,r.jsx)(n.h4,{id:"parselatexoptionsskipspace",children:"ParseLatexOptions.skipSpace"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"skipSpace: boolean;\n"})}),(0,r.jsx)(n.p,{children:"If true, ignore space characters in math mode."}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Default"}),": ",(0,r.jsx)(n.code,{children:"true"})]}),(0,r.jsx)(n.h4,{id:"parselatexoptionsparsenumbers",children:"ParseLatexOptions.parseNumbers"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'parseNumbers: "auto" | "rational" | "decimal" | "never";\n'})}),(0,r.jsxs)(n.p,{children:["When parsing a decimal number, e.g. ",(0,r.jsx)(n.code,{children:"3.1415"}),":"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"auto"'})," or ",(0,r.jsx)(n.code,{children:'"decimal"'}),": if a decimal number, parse it as an approximate\ndecimal number with a whole part and a fractional part"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"rational"'}),": if a decimal number, parse it as an exact rational number\nwith a numerator  and a denominator. If not a decimal number, parse\nit as a regular number."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"never"'}),": do not parse numbers, instead return each token making up\nthe number (minus sign, digits, decimal marker, etc...)."]}),"\n"]}),(0,r.jsxs)(n.p,{children:["Note: if the number includes repeating digits (e.g. ",(0,r.jsx)(n.code,{children:"1.33(333)"}),"),\nit will be parsed as a decimal number even if this setting is ",(0,r.jsx)(n.code,{children:'"rational"'}),"."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Default"}),": ",(0,r.jsx)(n.code,{children:'"auto"'})]}),(0,r.jsx)(n.h4,{id:"parselatexoptionsgetsymboltype",children:"ParseLatexOptions.getSymbolType()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"getSymbolType: (symbol) => BoxedType;\n"})}),(0,r.jsx)(n.p,{children:"This handler is invoked when the parser encounters a\nthat has not yet been declared."}),(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"symbol"})," argument is a ",(0,r.jsx)(n.a,{href:"#symbols",children:"valid symbol"}),"."]}),(0,r.jsx)(n.h4,{id:"parselatexoptionsparseunexpectedtoken",children:"ParseLatexOptions.parseUnexpectedToken()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"parseUnexpectedToken: (lhs, parser) => Expression | null;\n"})}),(0,r.jsx)(n.p,{children:"This handler is invoked when the parser encounters an unexpected token."}),(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"lhs"})," argument is the left-hand side of the token, if any."]}),(0,r.jsxs)(n.p,{children:["The handler can access the unexpected token with ",(0,r.jsx)(n.code,{children:"parser.peek"}),". If\nit is a token that should be recognized, the handler can consume it\nby calling ",(0,r.jsx)(n.code,{children:"parser.nextToken()"}),"."]}),(0,r.jsxs)(n.p,{children:["The handler should return an expression or ",(0,r.jsx)(n.code,{children:"null"})," if the token is not\nrecognized."]}),(0,r.jsx)(n.h4,{id:"parselatexoptionspreservelatex",children:"ParseLatexOptions.preserveLatex"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"preserveLatex: boolean;\n"})}),(0,r.jsx)(n.p,{children:"If true, the expression will be decorated with the LaTeX\nfragments corresponding to each elements of the expression."}),(0,r.jsxs)(n.p,{children:["The top-level expression, that is the one returned by ",(0,r.jsx)(n.code,{children:"parse()"}),", will\ninclude the verbatim LaTeX input that was parsed. The sub-expressions\nmay contain a slightly different LaTeX, for example with consecutive spaces\nreplaced by one, with comments removed and with some low-level LaTeX\ncommands replaced, for example ",(0,r.jsx)(n.code,{children:"\\egroup"})," and ",(0,r.jsx)(n.code,{children:"\\bgroup"}),"."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Default:"})," ",(0,r.jsx)(n.code,{children:"false"})]}),(0,r.jsx)(n.h4,{id:"parselatexoptionsquantifierscope",children:"ParseLatexOptions.quantifierScope"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'quantifierScope: "tight" | "loose";\n'})}),(0,r.jsxs)(n.p,{children:["Controls how quantifier scope is determined when parsing expressions\nlike ",(0,r.jsx)(n.code,{children:"\\forall x. P(x) \\rightarrow Q(x)"}),"."]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:'"tight"'}),": The quantifier binds only to the immediately following\nwell-formed formula, stopping at logical connectives (",(0,r.jsx)(n.code,{children:"\\rightarrow"}),",\n",(0,r.jsx)(n.code,{children:"\\implies"}),", ",(0,r.jsx)(n.code,{children:"\\land"}),", ",(0,r.jsx)(n.code,{children:"\\lor"}),", etc.). This follows standard First-Order\nLogic conventions. Use explicit parentheses for wider scope:\n",(0,r.jsx)(n.code,{children:"\\forall x. (P(x) \\rightarrow Q(x))"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:'"loose"'}),": The quantifier scope extends to the end of the expression\nor until a lower-precedence operator is encountered."]}),"\n"]}),"\n"]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Default:"})," ",(0,r.jsx)(n.code,{children:'"tight"'})]}),(0,r.jsx)(n.h5,{id:"example",children:"Example"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'// With "tight" (default):\n// \\forall x. P(x) \\rightarrow Q(x)\n// parses as: (\u2200x. P(x)) \u2192 Q(x)\n\n// With "loose":\n// \\forall x. P(x) \\rightarrow Q(x)\n// parses as: \u2200x. (P(x) \u2192 Q(x))\n'})})]}),"\n",(0,r.jsx)(n.h3,{id:"parser",children:"Parser"}),"\n",(0,r.jsxs)(n.p,{children:["An instance of ",(0,r.jsx)(n.code,{children:"Parser"})," is provided to the ",(0,r.jsx)(n.code,{children:"parse"})," handlers of custom\nLaTeX dictionary entries."]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parseroptions",children:"Parser.options"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly options: Required<ParseLatexOptions>;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserindex",children:"Parser.index"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"index: number;\n"})}),(0,r.jsx)(n.p,{children:"The index of the current token"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parseratend",children:"Parser.atEnd"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly atEnd: boolean;\n"})}),(0,r.jsxs)(n.p,{children:["True if the last token has been reached.\nConsider also ",(0,r.jsx)(n.code,{children:"atTerminator()"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserpeek",children:"Parser.peek"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly peek: string;\n"})}),(0,r.jsx)(n.p,{children:"Return the next token, without advancing the index"})]}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"parseratboundary",children:"Parser.atBoundary"})}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parsergetsymboltype",children:"Parser.getSymbolType()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"getSymbolType(id): BoxedType\n"})}),(0,r.jsx)(n.p,{children:"####### id"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"string"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserpushsymboltable",children:"Parser.pushSymbolTable()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"pushSymbolTable(): void\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserpopsymboltable",children:"Parser.popSymbolTable()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"popSymbolTable(): void\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parseraddsymbol",children:"Parser.addSymbol()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"addSymbol(id, type): void\n"})}),(0,r.jsx)(n.p,{children:"####### id"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.p,{children:"####### type"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"string"})," | ",(0,r.jsx)(n.a,{href:"#boxedtype",children:(0,r.jsx)(n.code,{children:"BoxedType"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parseratterminator",children:"Parser.atTerminator()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"atTerminator(t): boolean\n"})}),(0,r.jsx)(n.p,{children:"Return true if the terminator condition is met or if the last token\nhas been reached."}),(0,r.jsx)(n.p,{children:"####### t"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#terminator",children:(0,r.jsx)(n.code,{children:"Terminator"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parsernexttoken",children:"Parser.nextToken()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"nextToken(): string\n"})}),(0,r.jsx)(n.p,{children:"Return the next token and advance the index"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserlatex",children:"Parser.latex()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"latex(start, end?): string\n"})}),(0,r.jsxs)(n.p,{children:["Return a string representation of the expression\nbetween ",(0,r.jsx)(n.code,{children:"start"})," and ",(0,r.jsx)(n.code,{children:"end"})," (default: the whole expression)"]}),(0,r.jsx)(n.p,{children:"####### start"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.p,{children:"####### end?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parsererror",children:"Parser.error()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"error(code, fromToken): Expression\n"})}),(0,r.jsx)(n.p,{children:"Return an error expression with the specified code and arguments"}),(0,r.jsx)(n.p,{children:"####### code"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"string"})," | [",(0,r.jsx)(n.code,{children:"string"}),", ",(0,r.jsx)(n.code,{children:"...Expression[]"}),"]"]}),(0,r.jsx)(n.p,{children:"####### fromToken"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserskipspace",children:"Parser.skipSpace()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"skipSpace(): boolean\n"})}),(0,r.jsx)(n.p,{children:"If there are any space, advance the index until a non-space is encountered"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserskipvisualspace",children:"Parser.skipVisualSpace()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"skipVisualSpace(): void\n"})}),(0,r.jsxs)(n.p,{children:['Skip over "visual space" which\nincludes space tokens, empty groups ',(0,r.jsx)(n.code,{children:"{}"}),", and commands such as ",(0,r.jsx)(n.code,{children:"\\,"})," and ",(0,r.jsx)(n.code,{children:"\\!"})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parsermatch",children:"Parser.match()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"match(token): boolean\n"})}),(0,r.jsx)(n.p,{children:"If the next token matches the target advance and return true. Otherwise\nreturn false"}),(0,r.jsx)(n.p,{children:"####### token"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"string"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parsermatchall",children:"Parser.matchAll()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"matchAll(tokens): boolean\n"})}),(0,r.jsx)(n.p,{children:"Return true if the next tokens match the argument, an array of tokens, or null otherwise"}),(0,r.jsx)(n.p,{children:"####### tokens"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"string"}),"[]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parsermatchany",children:"Parser.matchAny()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"matchAny(tokens): string\n"})}),(0,r.jsx)(n.p,{children:"Return the next token if it matches any of the token in the argument or null otherwise"}),(0,r.jsx)(n.p,{children:"####### tokens"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"string"}),"[]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserparsechar",children:"Parser.parseChar()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"parseChar(): string\n"})}),(0,r.jsxs)(n.p,{children:["If the next token is a character, return it and advance the index\nThis includes plain characters (e.g. 'a', '+'...), characters\ndefined in hex (^^ and ^^^^), the ",(0,r.jsx)(n.code,{children:"\\char"})," and ",(0,r.jsx)(n.code,{children:"\\unicode"})," command."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserparsegroup",children:"Parser.parseGroup()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"parseGroup(): Expression\n"})}),(0,r.jsxs)(n.p,{children:["Parse an expression in a LaTeX group enclosed in curly brackets ",(0,r.jsx)(n.code,{children:"{}"}),".\nThese are often used as arguments to LaTeX commands, for example\n",(0,r.jsx)(n.code,{children:"\\frac{1}{2}"}),"."]}),(0,r.jsxs)(n.p,{children:["Return ",(0,r.jsx)(n.code,{children:"null"})," if none was found\nReturn ",(0,r.jsx)(n.code,{children:"Nothing"})," if an empty group ",(0,r.jsx)(n.code,{children:"{}"})," was found"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserparsetoken",children:"Parser.parseToken()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"parseToken(): Expression\n"})}),(0,r.jsxs)(n.p,{children:["Some LaTeX commands (but not all) can accept arguments as single\ntokens (i.e. without braces), for example ",(0,r.jsx)(n.code,{children:"^2"}),", ",(0,r.jsx)(n.code,{children:"\\sqrt3"})," or ",(0,r.jsx)(n.code,{children:"\\frac12"})]}),(0,r.jsxs)(n.p,{children:["This argument will usually be a single token, but can be a sequence of\ntokens (e.g. ",(0,r.jsx)(n.code,{children:"\\sqrt\\frac12"})," or ",(0,r.jsx)(n.code,{children:"\\sqrt\\operatorname{speed}"}),")."]}),(0,r.jsxs)(n.p,{children:["The following tokens are excluded from consideration in order to fail\nearly when encountering a likely syntax error, for example ",(0,r.jsx)(n.code,{children:"x^(2)"}),"\ninstead of ",(0,r.jsx)(n.code,{children:"x^{2}"}),". With ",(0,r.jsx)(n.code,{children:"("})," in the list of excluded tokens, the\nmatch will fail and the error can be recovered."]}),(0,r.jsxs)(n.p,{children:["The excluded tokens include ",(0,r.jsx)(n.code,{children:'!"#$%&(),/;:?@[]'}),'|~", ',(0,r.jsx)(n.code,{children:"\\left"}),", ",(0,r.jsx)(n.code,{children:"\\bigl"}),", etc..."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserparseoptionalgroup",children:"Parser.parseOptionalGroup()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"parseOptionalGroup(): Expression\n"})}),(0,r.jsxs)(n.p,{children:["Parse an expression enclosed in a LaTeX optional group enclosed in square brackets ",(0,r.jsx)(n.code,{children:"[]"}),"."]}),(0,r.jsxs)(n.p,{children:["Return ",(0,r.jsx)(n.code,{children:"null"})," if none was found."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserparseenclosure",children:"Parser.parseEnclosure()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"parseEnclosure(): Expression\n"})}),(0,r.jsx)(n.p,{children:"Parse an enclosure (open paren/close paren, etc..) and return the expression inside the enclosure"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserparsestringgroup",children:"Parser.parseStringGroup()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"parseStringGroup(optional?): string\n"})}),(0,r.jsxs)(n.p,{children:["Some LaTeX commands have arguments that are not interpreted as\nexpressions, but as strings. For example, ",(0,r.jsx)(n.code,{children:"\\begin{array}{ccc}"})," (both\n",(0,r.jsx)(n.code,{children:"array"})," and ",(0,r.jsx)(n.code,{children:"ccc"})," are strings), ",(0,r.jsx)(n.code,{children:"\\color{red}"})," or ",(0,r.jsx)(n.code,{children:"\\operatorname{lim sup}"}),"."]}),(0,r.jsxs)(n.p,{children:["If the next token is the start of a group (",(0,r.jsx)(n.code,{children:"{"}),"), return the content\nof the group as a string. This may include white space, and it may need\nto be trimmed at the start and end of the string."]}),(0,r.jsxs)(n.p,{children:["LaTeX commands are typically not allowed inside a string group (for example,\n",(0,r.jsx)(n.code,{children:"\\alpha"})," would result in an error), but we do not enforce this."]}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"optional"})," is true, this should be an optional group in square brackets\notherwise it is a regular group in braces."]}),(0,r.jsx)(n.p,{children:"####### optional?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"boolean"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserparsesymbol",children:"Parser.parseSymbol()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"parseSymbol(until?): Expression\n"})}),(0,r.jsx)(n.p,{children:"A symbol can be:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["a single-letter symbol: ",(0,r.jsx)(n.code,{children:"x"})]}),"\n",(0,r.jsxs)(n.li,{children:["a single LaTeX command: ",(0,r.jsx)(n.code,{children:"\\pi"})]}),"\n",(0,r.jsxs)(n.li,{children:["a multi-letter symbol: ",(0,r.jsx)(n.code,{children:"\\operatorname{speed}"})]}),"\n"]}),(0,r.jsx)(n.p,{children:"####### until?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Partial"}),"<",(0,r.jsx)(n.a,{href:"#terminator",children:(0,r.jsx)(n.code,{children:"Terminator"})}),">"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserparsetabular",children:"Parser.parseTabular()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"parseTabular(): Expression[][]\n"})}),(0,r.jsxs)(n.p,{children:["Parse an expression in a tabular format, where rows are separated by ",(0,r.jsx)(n.code,{children:"\\\\"}),"\nand columns by ",(0,r.jsx)(n.code,{children:"&"}),"."]}),(0,r.jsxs)(n.p,{children:["Return rows of sparse columns: empty rows are indicated with ",(0,r.jsx)(n.code,{children:"Nothing"}),",\nand empty cells are also indicated with ",(0,r.jsx)(n.code,{children:"Nothing"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserparsearguments",children:"Parser.parseArguments()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"parseArguments(kind?, until?): readonly Expression[]\n"})}),(0,r.jsxs)(n.p,{children:["Parse an argument list, for example: ",(0,r.jsx)(n.code,{children:"(12, x+1)"})," or ",(0,r.jsx)(n.code,{children:"\\left(x\\right)"})]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["'enclosure' : will look for arguments inside an enclosure\n(an open/close fence) (",(0,r.jsx)(n.strong,{children:"default"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["'implicit': either an expression inside a pair of ",(0,r.jsx)(n.code,{children:"()"}),", or just a primary\n(i.e. we interpret ",(0,r.jsx)(n.code,{children:"\\cos x + 1"})," as ",(0,r.jsx)(n.code,{children:"\\cos(x) + 1"}),")"]}),"\n"]}),(0,r.jsxs)(n.p,{children:["Return an array of expressions, one for each argument, or ",(0,r.jsx)(n.code,{children:"null"})," if no\nargument was found."]}),(0,r.jsx)(n.p,{children:"####### kind?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:'"implicit"'})," | ",(0,r.jsx)(n.code,{children:'"enclosure"'})]}),(0,r.jsx)(n.p,{children:"####### until?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#terminator",children:(0,r.jsx)(n.code,{children:"Terminator"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserparsepostfixoperator",children:"Parser.parsePostfixOperator()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"parsePostfixOperator(lhs, until?): Expression\n"})}),(0,r.jsxs)(n.p,{children:["Parse a postfix operator, such as ",(0,r.jsx)(n.code,{children:"'"})," or ",(0,r.jsx)(n.code,{children:"!"}),"."]}),(0,r.jsxs)(n.p,{children:["Prefix, infix and matchfix operators are handled by ",(0,r.jsx)(n.code,{children:"parseExpression()"})]}),(0,r.jsx)(n.p,{children:"####### lhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#expression",children:(0,r.jsx)(n.code,{children:"Expression"})})}),(0,r.jsx)(n.p,{children:"####### until?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Partial"}),"<",(0,r.jsx)(n.a,{href:"#terminator",children:(0,r.jsx)(n.code,{children:"Terminator"})}),">"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserparseexpression",children:"Parser.parseExpression()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"parseExpression(until?): Expression\n"})}),(0,r.jsx)(n.p,{children:"Parse an expression:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<expression> ::=\n | <primary> ( <infix-op> <expression> )?\n | <prefix-op> <expression>\n\n<primary> :=\n  (<number> | <symbol> | <function-call> | <matchfix-expr>)\n  (<subsup> | <postfix-operator>)*\n\n<matchfix-expr> :=\n  <matchfix-op-open> <expression> <matchfix-op-close>\n\n<function-call> ::=\n  | <function><matchfix-op-group-open><expression>[',' <expression>]<matchfix-op-group-close>\n"})}),(0,r.jsx)(n.p,{children:"This is the top-level parsing entry point."}),(0,r.jsxs)(n.p,{children:["Stop when an operator of precedence less than ",(0,r.jsx)(n.code,{children:"until.minPrec"}),"\nor the sequence of tokens ",(0,r.jsx)(n.code,{children:"until.tokens"})," is encountered"]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"until"})," is ",(0,r.jsx)(n.code,{children:"{ minPrec:0 }"})," by default."]}),(0,r.jsx)(n.p,{children:"####### until?"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Partial"}),"<",(0,r.jsx)(n.a,{href:"#terminator",children:(0,r.jsx)(n.code,{children:"Terminator"})}),">"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserparsenumber",children:"Parser.parseNumber()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"parseNumber(): Expression\n"})}),(0,r.jsx)(n.p,{children:"Parse a number."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parseraddboundary",children:"Parser.addBoundary()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"addBoundary(boundary): void\n"})}),(0,r.jsx)(n.p,{children:"Boundaries are used to detect the end of an expression."}),(0,r.jsxs)(n.p,{children:["They are used for unusual syntactic constructs, for example\n",(0,r.jsx)(n.code,{children:"\\int \\sin x dx"})," where the ",(0,r.jsx)(n.code,{children:"dx"})," is not an argument to the ",(0,r.jsx)(n.code,{children:"\\sin"}),"\nfunction, but a boundary of the integral."]}),(0,r.jsx)(n.p,{children:"They are also useful when handling syntax errors and recovery."}),(0,r.jsxs)(n.p,{children:["For example, ",(0,r.jsx)(n.code,{children:"\\begin{bmatrix} 1 & 2 { \\end{bmatrix}"})," has an\nextraneous ",(0,r.jsx)(n.code,{children:"{"}),", but the parser will attempt to recover and continue\nparsing when it encounters the ",(0,r.jsx)(n.code,{children:"\\end{bmatrix}"})," boundary."]}),(0,r.jsx)(n.p,{children:"####### boundary"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"string"}),"[]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserremoveboundary",children:"Parser.removeBoundary()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"removeBoundary(): void\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parsermatchboundary",children:"Parser.matchBoundary()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"matchBoundary(): boolean\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"parserboundaryerror",children:"Parser.boundaryError()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"boundaryError(msg): Expression\n"})}),(0,r.jsx)(n.p,{children:"####### msg"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"string"})," | [",(0,r.jsx)(n.code,{children:"string"}),", ",(0,r.jsx)(n.code,{children:"...Expression[]"}),"]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"serializelatexoptions",children:"SerializeLatexOptions"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type SerializeLatexOptions = NumberSerializationFormat & {\n  prettify: boolean;\n  materialization: boolean | number | [number, number];\n  invisibleMultiply: LatexString;\n  invisiblePlus: LatexString;\n  multiply: LatexString;\n  missingSymbol: LatexString;\n  applyFunctionStyle: (expr, level) => DelimiterScale;\n  groupStyle: (expr, level) => DelimiterScale;\n  rootStyle: (expr, level) => "radical" | "quotient" | "solidus";\n  fractionStyle: (expr, level) => \n     | "quotient"\n     | "block-quotient"\n     | "inline-quotient"\n     | "inline-solidus"\n     | "nice-solidus"\n     | "reciprocal"\n     | "factor";\n  logicStyle: (expr, level) => "word" | "boolean" | "uppercase-word" | "punctuation";\n  powerStyle: (expr, level) => "root" | "solidus" | "quotient";\n  numericSetStyle: (expr, level) => "compact" | "regular" | "interval" | "set-builder";\n};\n'})}),(0,r.jsxs)(n.p,{children:["The LaTeX serialization options can used with the ",(0,r.jsx)(n.code,{children:"expr.toLatex()"})," method."]}),(0,r.jsx)(n.h4,{id:"serializelatexoptionsprettify",children:"SerializeLatexOptions.prettify"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"prettify: boolean;\n"})}),(0,r.jsx)(n.p,{children:"If true, prettify the LaTeX output."}),(0,r.jsxs)(n.p,{children:["For example, render ",(0,r.jsx)(n.code,{children:"\\frac{a}{b}\\frac{c}{d}"})," as ",(0,r.jsx)(n.code,{children:"\\frac{ac}{bd}"})]}),(0,r.jsx)(n.h4,{id:"serializelatexoptionsmaterialization",children:"SerializeLatexOptions.materialization"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"materialization: boolean | number | [number, number];\n"})}),(0,r.jsx)(n.p,{children:"Controls the materialization of the lazy collections."}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"true"}),", lazy collections are materialized, i.e. it is rendered as a\nLaTeX expression with all its elements."]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"false"}),", the expression is not materialized, i.e. it is\nrendered as a LaTeX command with its arguments."]}),"\n",(0,r.jsx)(n.li,{children:"If a number is provided, it is the maximum number of elements\nthat will be materialized."}),"\n",(0,r.jsx)(n.li,{children:"If a pair of numbers is provided, it is the number of elements\nof the head and the tail that will be materialized, respectively."}),"\n"]}),(0,r.jsx)(n.h4,{id:"serializelatexoptionsinvisiblemultiply",children:"SerializeLatexOptions.invisibleMultiply"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"invisibleMultiply: LatexString;\n"})}),(0,r.jsx)(n.p,{children:"LaTeX string used to render an invisible multiply, e.g. in '2x'."}),(0,r.jsxs)(n.p,{children:["If empty, both operands are concatenated, i.e. ",(0,r.jsx)(n.code,{children:"2x"}),"."]}),(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"\\cdot"})," to insert a ",(0,r.jsx)(n.code,{children:"\\cdot"})," operator between them, i.e. ",(0,r.jsx)(n.code,{children:"2 \\cdot x"}),"."]}),(0,r.jsx)(n.p,{children:"Empty by default."}),(0,r.jsx)(n.h4,{id:"serializelatexoptionsinvisibleplus",children:"SerializeLatexOptions.invisiblePlus"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"invisiblePlus: LatexString;\n"})}),(0,r.jsxs)(n.p,{children:["LaTeX string used to render ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Fraction#Mixed_numbers",children:"mixed numbers"})," e.g. '1 3/4'."]}),(0,r.jsxs)(n.p,{children:["Leave it empty to join the main number and the fraction, i.e. render it\nas ",(0,r.jsx)(n.code,{children:"1\\frac{3}{4}"}),"."]}),(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"+"})," to insert an explicit ",(0,r.jsx)(n.code,{children:"+"})," operator between them,\ni.e. ",(0,r.jsx)(n.code,{children:"1+\\frac{3}{4}"})]}),(0,r.jsx)(n.p,{children:"Empty by default."}),(0,r.jsx)(n.h4,{id:"serializelatexoptionsmultiply",children:"SerializeLatexOptions.multiply"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"multiply: LatexString;\n"})}),(0,r.jsx)(n.p,{children:"LaTeX string used to render an explicit multiply operator."}),(0,r.jsxs)(n.p,{children:["For example, ",(0,r.jsx)(n.code,{children:"\\times"}),", ",(0,r.jsx)(n.code,{children:"\\cdot"}),", etc..."]}),(0,r.jsxs)(n.p,{children:["Default: ",(0,r.jsx)(n.code,{children:"\\times"})]}),(0,r.jsx)(n.h4,{id:"serializelatexoptionsmissingsymbol",children:"SerializeLatexOptions.missingSymbol"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"missingSymbol: LatexString;\n"})}),(0,r.jsxs)(n.p,{children:["Serialize the expression ",(0,r.jsx)(n.code,{children:'["Error", "\'missing\'"]'}),",  with this LaTeX string"]})]}),"\n",(0,r.jsx)(n.h3,{id:"serializer",children:"Serializer"}),"\n",(0,r.jsxs)(n.p,{children:["An instance of ",(0,r.jsx)(n.code,{children:"Serializer"})," is provided to the ",(0,r.jsx)(n.code,{children:"serialize"})," handlers of custom\nLaTeX dictionary entries."]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializeroptions",children:"Serializer.options"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly options: Required<SerializeLatexOptions>;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializerdictionary",children:"Serializer.dictionary"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly dictionary: IndexedLatexDictionary;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializerlevel",children:"Serializer.level"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"level: number;\n"})}),(0,r.jsx)(n.p,{children:'"depth" of the expression:'}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"0 for the root"}),"\n",(0,r.jsx)(n.li,{children:"1 for a subexpression of the root"}),"\n",(0,r.jsx)(n.li,{children:"2 for subexpressions of the subexpressions of the root"}),"\n",(0,r.jsx)(n.li,{children:"etc..."}),"\n"]}),(0,r.jsx)(n.p,{children:"This allows the serialized LaTeX to vary depending on the depth of the\nexpression."}),(0,r.jsxs)(n.p,{children:["For example use ",(0,r.jsx)(n.code,{children:"\\Bigl("})," for the top level, and ",(0,r.jsx)(n.code,{children:"\\bigl("})," or ",(0,r.jsx)(n.code,{children:"("})," for others."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializerserialize",children:"Serializer.serialize()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"serialize: (expr) => string;\n"})}),(0,r.jsx)(n.p,{children:"Output a LaTeX string representing the expression"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializerwrap",children:"Serializer.wrap()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"wrap: (expr, prec?) => string;\n"})}),(0,r.jsxs)(n.p,{children:["Add a group fence around the expression if it is\nan operator of precedence less than or equal to ",(0,r.jsx)(n.code,{children:"prec"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializerapplyfunctionstyle",children:"Serializer.applyFunctionStyle()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"applyFunctionStyle: (expr, level) => DelimiterScale;\n"})}),(0,r.jsx)(n.p,{children:"Styles"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializergroupstyle",children:"Serializer.groupStyle()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"groupStyle: (expr, level) => DelimiterScale;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializerrootstyle",children:"Serializer.rootStyle()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'rootStyle: (expr, level) => "radical" | "quotient" | "solidus";\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializerfractionstyle",children:"Serializer.fractionStyle()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'fractionStyle: (expr, level) => \n  | "quotient"\n  | "block-quotient"\n  | "inline-quotient"\n  | "inline-solidus"\n  | "nice-solidus"\n  | "reciprocal"\n  | "factor";\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializerlogicstyle",children:"Serializer.logicStyle()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'logicStyle: (expr, level) => "boolean" | "word" | "uppercase-word" | "punctuation";\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializerpowerstyle",children:"Serializer.powerStyle()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'powerStyle: (expr, level) => "quotient" | "solidus" | "root";\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializernumericsetstyle",children:"Serializer.numericSetStyle()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'numericSetStyle: (expr, level) => "interval" | "compact" | "regular" | "set-builder";\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializerserializefunction",children:"Serializer.serializeFunction()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"serializeFunction(expr, def?): string\n"})}),(0,r.jsx)(n.p,{children:"####### expr"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#expression",children:(0,r.jsx)(n.code,{children:"Expression"})})}),(0,r.jsx)(n.p,{children:"####### def?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"IndexedLatexDictionaryEntry"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializerserializesymbol",children:"Serializer.serializeSymbol()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"serializeSymbol(expr): string\n"})}),(0,r.jsx)(n.p,{children:"####### expr"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#expression",children:(0,r.jsx)(n.code,{children:"Expression"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializerwrapstring",children:"Serializer.wrapString()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"wrapString(s, style, delimiters?): string\n"})}),(0,r.jsxs)(n.p,{children:["Output ",(0,r.jsx)(n.code,{children:"s"})," surrounded by delimiters."]}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"delimiters"})," is not specified, use ",(0,r.jsx)(n.code,{children:"()"})]}),(0,r.jsx)(n.p,{children:"####### s"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"string"})}),(0,r.jsx)(n.p,{children:"####### style"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#delimiterscale",children:(0,r.jsx)(n.code,{children:"DelimiterScale"})})}),(0,r.jsx)(n.p,{children:"####### delimiters?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"string"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializerwraparguments",children:"Serializer.wrapArguments()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"wrapArguments(expr): string\n"})}),(0,r.jsx)(n.p,{children:"A string with the arguments of expr fenced appropriately and separated by\ncommas."}),(0,r.jsx)(n.p,{children:"####### expr"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#expression",children:(0,r.jsx)(n.code,{children:"Expression"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"serializerwrapshort",children:"Serializer.wrapShort()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"wrapShort(expr): string\n"})}),(0,r.jsx)(n.p,{children:"Add a group fence around the expression if it is\nshort (not a function)"}),(0,r.jsx)(n.p,{children:"####### expr"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#expression",children:(0,r.jsx)(n.code,{children:"Expression"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"serializehandler",children:"SerializeHandler()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type SerializeHandler = (serializer, expr) => string;\n"})}),(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"serialize"})," handler of a custom LaTeX dictionary entry can be\na function of this type."]})]}),"\n",(0,r.jsx)(n.h2,{id:"numerics",children:"Numerics"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"sign",children:"Sign"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type Sign = \n  | "zero"\n  | "positive"\n  | "negative"\n  | "non-negative"\n  | "non-positive"\n  | "not-zero"\n  | "unsigned";\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"exactnumericvaluedata",children:"ExactNumericValueData"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type ExactNumericValueData = {\n  rational: Rational;\n  radical: number;\n};\n"})}),(0,r.jsxs)(n.p,{children:["The value is equal to ",(0,r.jsx)(n.code,{children:"(decimal * rational * sqrt(radical)) + im * i"})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"numericvaluedata",children:"NumericValueData"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type NumericValueData = {\n  re: Decimal | number;\n  im: number;\n};\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"numericvaluefactory",children:"NumericValueFactory()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type NumericValueFactory = (data) => NumericValue;\n"})})]}),"\n",(0,r.jsxs)(n.h3,{id:"abstract-numericvalue",children:[(0,r.jsx)(n.code,{children:"abstract"})," NumericValue"]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"new-numericvalue",children:"new NumericValue()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"new NumericValue(): NumericValue\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueim",children:"NumericValue.im"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"im: number;\n"})}),(0,r.jsx)(n.p,{children:"The imaginary part of this numeric value."}),(0,r.jsx)(n.p,{children:"Can be negative, zero or positive."})]}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"numericvaluetype",children:"NumericValue.type"})}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueisexact",children:"NumericValue.isExact"}),(0,r.jsx)(n.p,{children:"True if numeric value is the product of a rational and the square root of an integer."}),(0,r.jsx)(n.p,{children:"This includes: 3/4\u221a5, -2, \u221a2, etc..."}),(0,r.jsx)(n.p,{children:"But it doesn't include 0.5, 3.141592, etc..."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueasexact",children:"NumericValue.asExact"}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"isExact()"}),", returns an ExactNumericValue, otherwise returns undefined."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluere",children:"NumericValue.re"}),(0,r.jsx)(n.p,{children:"The real part of this numeric value."}),(0,r.jsx)(n.p,{children:"Can be negative, 0 or positive."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluebignumre",children:"NumericValue.bignumRe"}),(0,r.jsx)(n.p,{children:"bignum version of .re, if available"})]}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"numericvaluebignumim",children:"NumericValue.bignumIm"})}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"numericvaluenumerator",children:"NumericValue.numerator"})}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"numericvaluedenominator",children:"NumericValue.denominator"})}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"numericvalueisnan",children:"NumericValue.isNaN"})}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"numericvalueispositiveinfinity",children:"NumericValue.isPositiveInfinity"})}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"numericvalueisnegativeinfinity",children:"NumericValue.isNegativeInfinity"})}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"numericvalueiscomplexinfinity",children:"NumericValue.isComplexInfinity"})}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"numericvalueiszero",children:"NumericValue.isZero"})}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"numericvalueisone",children:"NumericValue.isOne"})}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"numericvalueisnegativeone",children:"NumericValue.isNegativeOne"})}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueiszerowithtolerance",children:"NumericValue.isZeroWithTolerance()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isZeroWithTolerance(_tolerance): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### _tolerance"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.code,{children:"Decimal"})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluesgn",children:"NumericValue.sgn()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract sgn(): -1 | 0 | 1\n"})}),(0,r.jsx)(n.p,{children:"The sign of complex numbers is undefined"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluen",children:"NumericValue.N()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract N(): NumericValue\n"})}),(0,r.jsx)(n.p,{children:"Return a non-exact representation of the numeric value"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueneg",children:"NumericValue.neg()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract neg(): NumericValue\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueinv",children:"NumericValue.inv()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract inv(): NumericValue\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueadd",children:"NumericValue.add()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract add(other): NumericValue\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#numericvalue-1",children:(0,r.jsx)(n.code,{children:"NumericValue"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluesub",children:"NumericValue.sub()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract sub(other): NumericValue\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#numericvalue-1",children:(0,r.jsx)(n.code,{children:"NumericValue"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluemul",children:"NumericValue.mul()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract mul(other): NumericValue\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.code,{children:"Decimal"})," | ",(0,r.jsx)(n.a,{href:"#numericvalue-1",children:(0,r.jsx)(n.code,{children:"NumericValue"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluediv",children:"NumericValue.div()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract div(other): NumericValue\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#numericvalue-1",children:(0,r.jsx)(n.code,{children:"NumericValue"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluepow",children:"NumericValue.pow()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract pow(n): NumericValue\n"})}),(0,r.jsx)(n.p,{children:"####### n"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#numericvalue-1",children:(0,r.jsx)(n.code,{children:"NumericValue"})})," | {\n",(0,r.jsx)(n.code,{children:"re"}),": ",(0,r.jsx)(n.code,{children:"number"}),";\n",(0,r.jsx)(n.code,{children:"im"}),": ",(0,r.jsx)(n.code,{children:"number"}),";\n}"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueroot",children:"NumericValue.root()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract root(n): NumericValue\n"})}),(0,r.jsx)(n.p,{children:"####### n"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluesqrt",children:"NumericValue.sqrt()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract sqrt(): NumericValue\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluegcd",children:"NumericValue.gcd()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract gcd(other): NumericValue\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#numericvalue-1",children:(0,r.jsx)(n.code,{children:"NumericValue"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueabs",children:"NumericValue.abs()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract abs(): NumericValue\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueln",children:"NumericValue.ln()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract ln(base?): NumericValue\n"})}),(0,r.jsx)(n.p,{children:"####### base?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueexp",children:"NumericValue.exp()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract exp(): NumericValue\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluefloor",children:"NumericValue.floor()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract floor(): NumericValue\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueceil",children:"NumericValue.ceil()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract ceil(): NumericValue\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueround",children:"NumericValue.round()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract round(): NumericValue\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueeq",children:"NumericValue.eq()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract eq(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#numericvalue-1",children:(0,r.jsx)(n.code,{children:"NumericValue"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluelt",children:"NumericValue.lt()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract lt(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#numericvalue-1",children:(0,r.jsx)(n.code,{children:"NumericValue"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluelte",children:"NumericValue.lte()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract lte(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#numericvalue-1",children:(0,r.jsx)(n.code,{children:"NumericValue"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluegt",children:"NumericValue.gt()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract gt(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#numericvalue-1",children:(0,r.jsx)(n.code,{children:"NumericValue"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluegte",children:"NumericValue.gte()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"abstract gte(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.a,{href:"#numericvalue-1",children:(0,r.jsx)(n.code,{children:"NumericValue"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluevalueof",children:"NumericValue.valueOf()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"valueOf(): string | number\n"})}),(0,r.jsx)(n.p,{children:"Object.valueOf(): returns a primitive value, preferably a JavaScript\nnumber over a string, even if at the expense of precision"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluetoprimitive",children:"NumericValue.[toPrimitive]()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"toPrimitive: string | number\n"})}),(0,r.jsx)(n.p,{children:"Object.toPrimitive()"}),(0,r.jsx)(n.p,{children:"####### hint"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:'"string"'})," | ",(0,r.jsx)(n.code,{children:'"number"'})," | ",(0,r.jsx)(n.code,{children:'"default"'})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvaluetojson",children:"NumericValue.toJSON()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"toJSON(): any\n"})}),(0,r.jsx)(n.p,{children:"Object.toJSON"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"numericvalueprint",children:"NumericValue.print()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"print(): void\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"smallinteger",children:"SmallInteger"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type SmallInteger = IsInteger<number>;\n"})}),(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"SmallInteger"})," is an integer < 1e6"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"rational",children:"Rational"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Rational = \n  | [SmallInteger, SmallInteger]\n  | [bigint, bigint];\n"})}),(0,r.jsx)(n.p,{children:"A rational number is a number that can be expressed as the quotient or fraction p/q of two integers,\na numerator p and a non-zero denominator q."}),(0,r.jsx)(n.p,{children:"A rational can either be represented as a pair of small integers or\na pair of big integers."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"bignum",children:"BigNum"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type BigNum = Decimal;\n"})})]}),"\n",(0,r.jsx)(n.h3,{id:"ibignum",children:"IBigNum"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"ibignum_bignum_nan",children:"IBigNum._BIGNUM_NAN"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly _BIGNUM_NAN: Decimal;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"ibignum_bignum_zero",children:"IBigNum._BIGNUM_ZERO"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly _BIGNUM_ZERO: Decimal;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"ibignum_bignum_one",children:"IBigNum._BIGNUM_ONE"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly _BIGNUM_ONE: Decimal;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"ibignum_bignum_two",children:"IBigNum._BIGNUM_TWO"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly _BIGNUM_TWO: Decimal;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"ibignum_bignum_half",children:"IBigNum._BIGNUM_HALF"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly _BIGNUM_HALF: Decimal;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"ibignum_bignum_pi",children:"IBigNum._BIGNUM_PI"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly _BIGNUM_PI: Decimal;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"ibignum_bignum_negative_one",children:"IBigNum._BIGNUM_NEGATIVE_ONE"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly _BIGNUM_NEGATIVE_ONE: Decimal;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"ibignumbignum",children:"IBigNum.bignum()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"bignum(value): Decimal\n"})}),(0,r.jsx)(n.p,{children:"####### value"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"string"})," | ",(0,r.jsx)(n.code,{children:"number"})," | ",(0,r.jsx)(n.code,{children:"bigint"})," | ",(0,r.jsx)(n.code,{children:"Decimal"})]})]}),"\n",(0,r.jsx)(n.h2,{id:"other-2",children:"Other"}),"\n",(0,r.jsx)(n.h3,{id:"dictionaryinterface",children:"DictionaryInterface"}),"\n",(0,r.jsxs)(n.p,{children:["Interface for dictionary-like structures.\nUse ",(0,r.jsx)(n.code,{children:"isDictionary()"})," to check if an expression is a dictionary."]}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"dictionaryinterfacekeys",children:"DictionaryInterface.keys"})}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"dictionaryinterfaceentries",children:"DictionaryInterface.entries"})}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"dictionaryinterfacevalues",children:"DictionaryInterface.values"})}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"dictionaryinterfaceget",children:"DictionaryInterface.get()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"get(key): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"####### key"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"string"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"dictionaryinterfacehas",children:"DictionaryInterface.has()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"has(key): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### key"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"string"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"symboltable",children:"SymbolTable"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type SymbolTable = {\n  parent: SymbolTable | null;\n  ids: {};\n};\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"bignumfactory",children:"BigNumFactory()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type BigNumFactory = (value) => Decimal;\n"})})]}),"\n",(0,r.jsx)(n.h2,{id:"serialization",children:"Serialization"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"jsonserializationoptions",children:"JsonSerializationOptions"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type JsonSerializationOptions = {\n  prettify: boolean;\n  exclude: string[];\n  shorthands: ("all" | "number" | "symbol" | "function" | "string" | "dictionary")[];\n  metadata: ("all" | "wikidata" | "latex")[];\n  repeatingDecimal: boolean;\n  fractionalDigits: "auto" | "max" | number;\n};\n'})}),(0,r.jsxs)(n.p,{children:["Options to control the serialization to MathJSON when using ",(0,r.jsx)(n.code,{children:"BoxedExpression.toMathJson()"}),"."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"numberformat",children:"NumberFormat"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type NumberFormat = {\n  positiveInfinity: LatexString;\n  negativeInfinity: LatexString;\n  notANumber: LatexString;\n  imaginaryUnit: LatexString;\n  decimalSeparator: LatexString;\n  digitGroupSeparator:   | LatexString\n     | [LatexString, LatexString];\n  digitGroup: "lakh" | number | [number | "lakh", number];\n  exponentProduct: LatexString;\n  beginExponentMarker: LatexString;\n  endExponentMarker: LatexString;\n  truncationMarker: LatexString;\n  repeatingDecimal: "auto" | "vinculum" | "dots" | "parentheses" | "arc" | "none";\n};\n'})}),(0,r.jsx)(n.p,{children:"These options control how numbers are parsed and serialized."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"numberserializationformat",children:"NumberSerializationFormat"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type NumberSerializationFormat = NumberFormat & {\n  fractionalDigits: "auto" | "max" | number;\n  notation: "auto" | "engineering" | "scientific" | "adaptiveScientific";\n  avoidExponentsInRange: undefined | null | [number, number];\n};\n'})}),(0,r.jsx)(n.h4,{id:"numberserializationformatfractionaldigits",children:"NumberSerializationFormat.fractionalDigits"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'fractionalDigits: "auto" | "max" | number;\n'})}),(0,r.jsx)(n.p,{children:"The maximum number of significant digits in serialized numbers."}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"max"'}),": all availabe digits are serialized."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"auto"'}),": use the same precision as the compute engine."]}),"\n"]}),(0,r.jsxs)(n.p,{children:["Default: ",(0,r.jsx)(n.code,{children:'"auto"'})]})]}),"\n",(0,r.jsx)(n.h2,{id:"tensors",children:"Tensors"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"datatypemap",children:"DataTypeMap"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type DataTypeMap = {\n  float64: number;\n  float32: number;\n  int32: number;\n  uint8: number;\n  complex128: Complex;\n  complex64: Complex;\n  bool: boolean;\n  expression: BoxedExpression;\n};\n"})}),(0,r.jsxs)(n.p,{children:["Map of ",(0,r.jsx)(n.code,{children:"TensorDataType"})," to JavaScript type."]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"tensordatatype",children:"TensorDataType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type TensorDataType = keyof DataTypeMap;\n"})}),(0,r.jsx)(n.p,{children:"The type of the cells in a tensor."})]}),"\n",(0,r.jsx)(n.h3,{id:"tensordata",children:"TensorData"}),"\n",(0,r.jsx)(n.p,{children:"A record representing the type, shape and data of a tensor."}),"\n",(0,r.jsx)(n.h4,{id:"extended-by-1",children:"Extended by"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#tensor",children:(0,r.jsx)(n.code,{children:"Tensor"})})}),"\n"]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensordatadtype",children:"TensorData.dtype"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"dtype: DT;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensordatashape",children:"TensorData.shape"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"shape: number[];\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensordatarank",children:"TensorData.rank?"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"optional rank: number;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensordatadata",children:"TensorData.data"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"data: DataTypeMap[DT][];\n"})})]}),"\n",(0,r.jsx)(n.h3,{id:"tensorfield",children:"TensorField"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldone",children:"TensorField.one"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly one: T;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldzero",children:"TensorField.zero"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly zero: T;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldnan",children:"TensorField.nan"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly nan: T;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldcast",children:"TensorField.cast()"}),(0,r.jsx)(n.h6,{id:"castx-dtype",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): number\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"float64"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-1",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): number\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"float32"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-2",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): number\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"int32"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-3",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): number\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"uint8"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-4",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): any\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"complex128"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-5",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): any\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"complex64"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-6",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"bool"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-7",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"expression"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-8",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): number[]\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"T"}),"[]"]}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"float64"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-9",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): number[]\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"T"}),"[]"]}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"float32"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-10",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): number[]\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"T"}),"[]"]}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"int32"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-11",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): number[]\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"T"}),"[]"]}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"uint8"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-12",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): Complex[]\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"T"}),"[]"]}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"complex128"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-13",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): Complex[]\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"T"}),"[]"]}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"complex64"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-14",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): boolean[]\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"T"}),"[]"]}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"bool"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-15",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): BoxedExpression[]\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"T"}),"[]"]}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:'"expression"'})}),(0,r.jsx)(n.h6,{id:"castx-dtype-16",children:"cast(x, dtype)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"cast(x, dtype): any\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"T"})," | ",(0,r.jsx)(n.code,{children:"T"}),"[]"]}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsxs)(n.p,{children:["keyof ",(0,r.jsx)(n.a,{href:"#datatypemap",children:(0,r.jsx)(n.code,{children:"DataTypeMap"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldexpression",children:"TensorField.expression()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"expression(x): BoxedExpression\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldiszero",children:"TensorField.isZero()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isZero(x): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldisone",children:"TensorField.isOne()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"isOne(x): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldequals",children:"TensorField.equals()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"equals(lhs, rhs): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### lhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.p,{children:"####### rhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldadd",children:"TensorField.add()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"add(lhs, rhs): T\n"})}),(0,r.jsx)(n.p,{children:"####### lhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.p,{children:"####### rhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldaddn",children:"TensorField.addn()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"addn(...xs): T\n"})}),(0,r.jsx)(n.p,{children:"####### xs"}),(0,r.jsxs)(n.p,{children:["...",(0,r.jsx)(n.code,{children:"T"}),"[]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldneg",children:"TensorField.neg()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"neg(x): T\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldsub",children:"TensorField.sub()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"sub(lhs, rhs): T\n"})}),(0,r.jsx)(n.p,{children:"####### lhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.p,{children:"####### rhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldmul",children:"TensorField.mul()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"mul(lhs, rhs): T\n"})}),(0,r.jsx)(n.p,{children:"####### lhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.p,{children:"####### rhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldmuln",children:"TensorField.muln()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"muln(...xs): T\n"})}),(0,r.jsx)(n.p,{children:"####### xs"}),(0,r.jsxs)(n.p,{children:["...",(0,r.jsx)(n.code,{children:"T"}),"[]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfielddiv",children:"TensorField.div()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"div(lhs, rhs): T\n"})}),(0,r.jsx)(n.p,{children:"####### lhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.p,{children:"####### rhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldpow",children:"TensorField.pow()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"pow(rhs, n): T\n"})}),(0,r.jsx)(n.p,{children:"####### rhs"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})}),(0,r.jsx)(n.p,{children:"####### n"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfieldconjugate",children:"TensorField.conjugate()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"conjugate(x): T\n"})}),(0,r.jsx)(n.p,{children:"####### x"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"T"})})]}),"\n",(0,r.jsx)(n.h3,{id:"tensor",children:"Tensor"}),"\n",(0,r.jsx)(n.h4,{id:"extends-3",children:"Extends"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#tensordata",children:(0,r.jsx)(n.code,{children:"TensorData"})}),"<",(0,r.jsx)(n.code,{children:"DT"}),">"]}),"\n"]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensordtype",children:"Tensor.dtype"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"dtype: DT;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorshape",children:"Tensor.shape"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"shape: number[];\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorrank",children:"Tensor.rank"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"rank: number;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensordata-1",children:"Tensor.data"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"data: DataTypeMap[DT][];\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorfield-1",children:"Tensor.field"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly field: TensorField<DT>;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorexpression",children:"Tensor.expression"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly expression: BoxedExpression;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorarray",children:"Tensor.array"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly array: NestedArray<DataTypeMap[DT]>;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorissquare",children:"Tensor.isSquare"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isSquare: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorissymmetric",children:"Tensor.isSymmetric"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isSymmetric: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorisskewsymmetric",children:"Tensor.isSkewSymmetric"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isSkewSymmetric: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorisdiagonal",children:"Tensor.isDiagonal"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isDiagonal: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorisuppertriangular",children:"Tensor.isUpperTriangular"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isUpperTriangular: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorislowertriangular",children:"Tensor.isLowerTriangular"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isLowerTriangular: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensoristriangular",children:"Tensor.isTriangular"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isTriangular: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorisidentity",children:"Tensor.isIdentity"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isIdentity: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensoriszero",children:"Tensor.isZero"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"readonly isZero: boolean;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorat",children:"Tensor.at()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"at(...indices): DataTypeMap[DT]\n"})}),(0,r.jsx)(n.p,{children:"####### indices"}),(0,r.jsxs)(n.p,{children:["...",(0,r.jsx)(n.code,{children:"number"}),"[]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensordiagonal",children:"Tensor.diagonal()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"diagonal(axis1?, axis2?): DataTypeMap[DT][]\n"})}),(0,r.jsx)(n.p,{children:"####### axis1?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.p,{children:"####### axis2?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensortrace",children:"Tensor.trace()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"trace(axis1?, axis2?): DataTypeMap[DT]\n"})}),(0,r.jsx)(n.p,{children:"####### axis1?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.p,{children:"####### axis2?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorreshape",children:"Tensor.reshape()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"reshape(...shape): Tensor<DT>\n"})}),(0,r.jsx)(n.p,{children:"####### shape"}),(0,r.jsxs)(n.p,{children:["...",(0,r.jsx)(n.code,{children:"number"}),"[]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorslice",children:"Tensor.slice()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"slice(index): Tensor<DT>\n"})}),(0,r.jsx)(n.p,{children:"####### index"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorflatten",children:"Tensor.flatten()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"flatten(): DataTypeMap[DT][]\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorupcast",children:"Tensor.upcast()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"upcast<DT>(dtype): Tensor<DT>\n"})}),(0,r.jsxs)(n.p,{children:["\u2022 DT extends keyof ",(0,r.jsx)(n.a,{href:"#datatypemap",children:(0,r.jsx)(n.code,{children:"DataTypeMap"})})]}),(0,r.jsx)(n.p,{children:"####### dtype"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"DT"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensortranspose",children:"Tensor.transpose()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"transpose(axis1?, axis2?): Tensor<DT>\n"})}),(0,r.jsx)(n.p,{children:"####### axis1?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.p,{children:"####### axis2?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorconjugatetranspose",children:"Tensor.conjugateTranspose()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"conjugateTranspose(axis1?, axis2?): Tensor<DT>\n"})}),(0,r.jsx)(n.p,{children:"####### axis1?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.p,{children:"####### axis2?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensordeterminant",children:"Tensor.determinant()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"determinant(): DataTypeMap[DT]\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorinverse",children:"Tensor.inverse()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"inverse(): Tensor<DT>\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorpseudoinverse",children:"Tensor.pseudoInverse()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"pseudoInverse(): Tensor<DT>\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensoradjugatematrix",children:"Tensor.adjugateMatrix()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"adjugateMatrix(): Tensor<DT>\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorminor",children:"Tensor.minor()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"minor(axis1, axis2): DataTypeMap[DT]\n"})}),(0,r.jsx)(n.p,{children:"####### axis1"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})}),(0,r.jsx)(n.p,{children:"####### axis2"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"number"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensormap1",children:"Tensor.map1()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"map1(fn, scalar): Tensor<DT>\n"})}),(0,r.jsx)(n.p,{children:"####### fn"}),(0,r.jsxs)(n.p,{children:["(",(0,r.jsx)(n.code,{children:"lhs"}),", ",(0,r.jsx)(n.code,{children:"rhs"}),") => ",(0,r.jsx)(n.a,{href:"#datatypemap",children:(0,r.jsx)(n.code,{children:"DataTypeMap"})}),"[",(0,r.jsx)(n.code,{children:"DT"}),"]"]}),(0,r.jsx)(n.p,{children:"####### scalar"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"#datatypemap",children:(0,r.jsx)(n.code,{children:"DataTypeMap"})}),"[",(0,r.jsx)(n.code,{children:"DT"}),"]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensormap2",children:"Tensor.map2()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"map2(fn, rhs): Tensor<DT>\n"})}),(0,r.jsx)(n.p,{children:"####### fn"}),(0,r.jsxs)(n.p,{children:["(",(0,r.jsx)(n.code,{children:"lhs"}),", ",(0,r.jsx)(n.code,{children:"rhs"}),") => ",(0,r.jsx)(n.a,{href:"#datatypemap",children:(0,r.jsx)(n.code,{children:"DataTypeMap"})}),"[",(0,r.jsx)(n.code,{children:"DT"}),"]"]}),(0,r.jsx)(n.p,{children:"####### rhs"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"#tensor",children:(0,r.jsx)(n.code,{children:"Tensor"})}),"<",(0,r.jsx)(n.code,{children:"DT"}),">"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensoradd",children:"Tensor.add()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"add(other): Tensor<DT>\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"#tensor",children:(0,r.jsx)(n.code,{children:"Tensor"})}),"<",(0,r.jsx)(n.code,{children:"DT"}),"> | ",(0,r.jsx)(n.a,{href:"#datatypemap",children:(0,r.jsx)(n.code,{children:"DataTypeMap"})}),"[",(0,r.jsx)(n.code,{children:"DT"}),"]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorsubtract",children:"Tensor.subtract()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"subtract(other): Tensor<DT>\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"#tensor",children:(0,r.jsx)(n.code,{children:"Tensor"})}),"<",(0,r.jsx)(n.code,{children:"DT"}),"> | ",(0,r.jsx)(n.a,{href:"#datatypemap",children:(0,r.jsx)(n.code,{children:"DataTypeMap"})}),"[",(0,r.jsx)(n.code,{children:"DT"}),"]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensormultiply",children:"Tensor.multiply()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"multiply(other): Tensor<DT>\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"#tensor",children:(0,r.jsx)(n.code,{children:"Tensor"})}),"<",(0,r.jsx)(n.code,{children:"DT"}),"> | ",(0,r.jsx)(n.a,{href:"#datatypemap",children:(0,r.jsx)(n.code,{children:"DataTypeMap"})}),"[",(0,r.jsx)(n.code,{children:"DT"}),"]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensordivide",children:"Tensor.divide()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"divide(other): Tensor<DT>\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"#tensor",children:(0,r.jsx)(n.code,{children:"Tensor"})}),"<",(0,r.jsx)(n.code,{children:"DT"}),"> | ",(0,r.jsx)(n.a,{href:"#datatypemap",children:(0,r.jsx)(n.code,{children:"DataTypeMap"})}),"[",(0,r.jsx)(n.code,{children:"DT"}),"]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorpower",children:"Tensor.power()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"power(other): Tensor<DT>\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"#tensor",children:(0,r.jsx)(n.code,{children:"Tensor"})}),"<",(0,r.jsx)(n.code,{children:"DT"}),"> | ",(0,r.jsx)(n.a,{href:"#datatypemap",children:(0,r.jsx)(n.code,{children:"DataTypeMap"})}),"[",(0,r.jsx)(n.code,{children:"DT"}),"]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"tensorequals",children:"Tensor.equals()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"equals(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"#tensor",children:(0,r.jsx)(n.code,{children:"Tensor"})}),"<",(0,r.jsx)(n.code,{children:"DT"}),">"]})]}),"\n",(0,r.jsx)(n.h2,{id:"type",children:"Type"}),"\n",(0,r.jsx)(n.h3,{id:"boxedtype",children:"BoxedType"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"new-boxedtype",children:"new BoxedType()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"new BoxedType(type, typeResolver?): BoxedType\n"})}),(0,r.jsx)(n.p,{children:"####### type"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"string"})," | ",(0,r.jsx)(n.a,{href:"#algebraictype",children:(0,r.jsx)(n.code,{children:"AlgebraicType"})})," | ",(0,r.jsx)(n.a,{href:"#negationtype",children:(0,r.jsx)(n.code,{children:"NegationType"})})," | ",(0,r.jsx)(n.a,{href:"#collectiontype",children:(0,r.jsx)(n.code,{children:"CollectionType"})})," | ",(0,r.jsx)(n.a,{href:"#listtype",children:(0,r.jsx)(n.code,{children:"ListType"})})," | ",(0,r.jsx)(n.a,{href:"#settype",children:(0,r.jsx)(n.code,{children:"SetType"})})," | ",(0,r.jsx)(n.a,{href:"#recordtype",children:(0,r.jsx)(n.code,{children:"RecordType"})})," | ",(0,r.jsx)(n.a,{href:"#dictionarytype",children:(0,r.jsx)(n.code,{children:"DictionaryType"})})," | ",(0,r.jsx)(n.a,{href:"#tupletype",children:(0,r.jsx)(n.code,{children:"TupleType"})})," | ",(0,r.jsx)(n.a,{href:"#symboltype",children:(0,r.jsx)(n.code,{children:"SymbolType"})})," | ",(0,r.jsx)(n.a,{href:"#expressiontype",children:(0,r.jsx)(n.code,{children:"ExpressionType"})})," | ",(0,r.jsx)(n.a,{href:"#numerictype",children:(0,r.jsx)(n.code,{children:"NumericType"})})," | ",(0,r.jsx)(n.a,{href:"#functionsignature",children:(0,r.jsx)(n.code,{children:"FunctionSignature"})})," | ",(0,r.jsx)(n.a,{href:"#valuetype",children:(0,r.jsx)(n.code,{children:"ValueType"})})," | ",(0,r.jsx)(n.a,{href:"#typereference",children:(0,r.jsx)(n.code,{children:"TypeReference"})})]}),(0,r.jsx)(n.p,{children:"####### typeResolver?"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#typeresolver",children:(0,r.jsx)(n.code,{children:"TypeResolver"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypeunknown",children:"BoxedType.unknown"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static unknown: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypenumber",children:"BoxedType.number"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static number: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypenon_finite_number",children:"BoxedType.non_finite_number"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static non_finite_number: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypefinite_number",children:"BoxedType.finite_number"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static finite_number: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypefinite_integer",children:"BoxedType.finite_integer"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static finite_integer: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypefinite_real",children:"BoxedType.finite_real"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static finite_real: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypestring",children:"BoxedType.string"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static string: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypedictionary",children:"BoxedType.dictionary"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static dictionary: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypesetnumber",children:"BoxedType.setNumber"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static setNumber: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypesetcomplex",children:"BoxedType.setComplex"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static setComplex: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypesetimaginary",children:"BoxedType.setImaginary"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static setImaginary: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypesetreal",children:"BoxedType.setReal"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static setReal: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypesetrational",children:"BoxedType.setRational"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static setRational: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypesetfiniteinteger",children:"BoxedType.setFiniteInteger"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static setFiniteInteger: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypesetinteger",children:"BoxedType.setInteger"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static setInteger: BoxedType;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypetype",children:"BoxedType.type"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type: Type;\n"})})]}),"\n",(0,r.jsx)(d.A,{children:(0,r.jsx)(n.h5,{id:"boxedtypeisunknown",children:"BoxedType.isUnknown"})}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypewiden",children:"BoxedType.widen()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static widen(...types): BoxedType\n"})}),(0,r.jsx)(n.p,{children:"####### types"}),(0,r.jsxs)(n.p,{children:["...readonly (",(0,r.jsx)(n.a,{href:"#type-3",children:(0,r.jsx)(n.code,{children:"Type"})})," | ",(0,r.jsx)(n.a,{href:"#boxedtype",children:(0,r.jsx)(n.code,{children:"BoxedType"})}),")[]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypenarrow",children:"BoxedType.narrow()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"static narrow(...types): BoxedType\n"})}),(0,r.jsx)(n.p,{children:"####### types"}),(0,r.jsxs)(n.p,{children:["...readonly (",(0,r.jsx)(n.a,{href:"#type-3",children:(0,r.jsx)(n.code,{children:"Type"})})," | ",(0,r.jsx)(n.a,{href:"#boxedtype",children:(0,r.jsx)(n.code,{children:"BoxedType"})}),")[]"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypematches",children:"BoxedType.matches()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"matches(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"#type-3",children:(0,r.jsx)(n.code,{children:"Type"})})," | ",(0,r.jsx)(n.a,{href:"#boxedtype",children:(0,r.jsx)(n.code,{children:"BoxedType"})})]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypeis",children:"BoxedType.is()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"is(other): boolean\n"})}),(0,r.jsx)(n.p,{children:"####### other"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"#type-3",children:(0,r.jsx)(n.code,{children:"Type"})})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypetostring",children:"BoxedType.toString()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"toString(): string\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypetojson",children:"BoxedType.toJSON()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"toJSON(): string\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypetoprimitive",children:"BoxedType.[toPrimitive]()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"toPrimitive: string\n"})}),(0,r.jsx)(n.p,{children:"####### hint"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"string"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h5,{id:"boxedtypevalueof",children:"BoxedType.valueOf()"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"valueOf(): string\n"})})]}),"\n",(0,r.jsx)(n.h2,{id:"mathjson",children:"MathJSON"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"mathjsonattributes",children:"MathJsonAttributes"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type MathJsonAttributes = {\n  comment: string;\n  documentation: string;\n  latex: string;\n  wikidata: string;\n  wikibase: string;\n  openmathSymbol: string;\n  openmathCd: string;\n  sourceUrl: string;\n  sourceContent: string;\n  sourceOffsets: [number, number];\n};\n"})}),(0,r.jsx)(n.p,{children:"The following properties can be added to any MathJSON expression\nto provide additional information about the expression."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"mathjsonsymbol",children:"MathJsonSymbol"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type MathJsonSymbol = string;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"mathjsonnumberobject",children:"MathJsonNumberObject"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type MathJsonNumberObject = {\n  num: "NaN" | "-Infinity" | "+Infinity" | string;\n } & MathJsonAttributes;\n'})}),(0,r.jsx)(n.p,{children:"A MathJSON numeric quantity."}),(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"num"})," string is made of:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["an optional ",(0,r.jsx)(n.code,{children:"-"})," minus sign"]}),"\n",(0,r.jsx)(n.li,{children:"a string of decimal digits"}),"\n",(0,r.jsxs)(n.li,{children:["an optional fraction part (a ",(0,r.jsx)(n.code,{children:"."})," decimal marker followed by decimal digits)"]}),"\n",(0,r.jsx)(n.li,{children:"an optional repeating decimal pattern: a string of digits enclosed in\nparentheses"}),"\n",(0,r.jsxs)(n.li,{children:["an optional exponent part (a ",(0,r.jsx)(n.code,{children:"e"})," or ",(0,r.jsx)(n.code,{children:"E"})," exponent marker followed by an\noptional ",(0,r.jsx)(n.code,{children:"-"})," minus sign, followed by a string of digits)"]}),"\n"]}),(0,r.jsxs)(n.p,{children:["It can also consist of the string ",(0,r.jsx)(n.code,{children:"NaN"}),", ",(0,r.jsx)(n.code,{children:"-Infinity"})," or ",(0,r.jsx)(n.code,{children:"+Infinity"})," to\nrepresent these respective values."]}),(0,r.jsx)(n.p,{children:"A MathJSON number may contain more digits or an exponent with a greater\nrange than can be represented in an IEEE 64-bit floating-point."}),(0,r.jsx)(n.p,{children:"For example:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"-12.34"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"0.234e-56"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"1.(3)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"123456789123456789.123(4567)e999"})}),"\n"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"mathjsonsymbolobject",children:"MathJsonSymbolObject"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type MathJsonSymbolObject = {\n  sym: MathJsonSymbol;\n } & MathJsonAttributes;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"mathjsonstringobject",children:"MathJsonStringObject"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type MathJsonStringObject = {\n  str: string;\n } & MathJsonAttributes;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"mathjsonfunctionobject",children:"MathJsonFunctionObject"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type MathJsonFunctionObject = {\n  fn: [MathJsonSymbol, ...Expression[]];\n } & MathJsonAttributes;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"dictionaryvalue",children:"DictionaryValue"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type DictionaryValue = \n  | boolean\n  | number\n  | string\n  | ExpressionObject\n| ReadonlyArray<DictionaryValue>;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"mathjsondictionaryobject",children:"MathJsonDictionaryObject"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type MathJsonDictionaryObject = {\n  dict: Record<string, DictionaryValue>;\n } & MathJsonAttributes;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"expressionobject",children:"ExpressionObject"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type ExpressionObject = \n  | MathJsonNumberObject\n  | MathJsonStringObject\n  | MathJsonSymbolObject\n  | MathJsonFunctionObject\n  | MathJsonDictionaryObject;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"expression",children:"Expression"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Expression = \n  | ExpressionObject\n  | number\n  | MathJsonSymbol\n  | string\n  | readonly [MathJsonSymbol, ...Expression[]];\n"})}),(0,r.jsx)(n.p,{children:"A MathJSON expression is a recursive data structure."}),(0,r.jsx)(n.p,{children:"The leaf nodes of an expression are numbers, strings and symbols.\nThe dictionary and function nodes can contain expressions themselves."})]}),"\n",(0,r.jsx)(n.h2,{id:"type-1",children:"Type"}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"primitivetype",children:"PrimitiveType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type PrimitiveType = \n  | NumericPrimitiveType\n  | "collection"\n  | "indexed_collection"\n  | "list"\n  | "set"\n  | "dictionary"\n  | "record"\n  | "dictionary"\n  | "tuple"\n  | "value"\n  | "scalar"\n  | "function"\n  | "symbol"\n  | "boolean"\n  | "string"\n  | "expression"\n  | "unknown"\n  | "error"\n  | "nothing"\n  | "never"\n  | "any";\n'})}),(0,r.jsx)(n.p,{children:"A primitive type is a simple type that represents a concrete value."}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"any"}),": the top type"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"expression"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"error"}),": an invalid value, such as ",(0,r.jsx)(n.code,{children:'["Error", "missing"]'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"nothing"}),": the type of the ",(0,r.jsx)(n.code,{children:"Nothing"})," symbol, the unit type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"never"}),": the bottom type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"unknown"}),": a value whose type is not known"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"expression"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["a symbolic expression, such as ",(0,r.jsx)(n.code,{children:'["Add", "x", 1]'})]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<value>"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"symbol"}),": a symbol, such as ",(0,r.jsx)(n.code,{children:"x"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"function"}),": a function literal\nsuch as ",(0,r.jsx)(n.code,{children:'["Function", ["Add", "x", 1], "x"]'}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"value"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"scalar"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<number>"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"boolean"}),": a boolean value: ",(0,r.jsx)(n.code,{children:"True"})," or ",(0,r.jsx)(n.code,{children:"False"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"string"}),": a string of characters."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"collection"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"set"}),": a collection of unique expressions, e.g. ",(0,r.jsx)(n.code,{children:"set<string>"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"record"}),": a collection of specific key-value pairs,\ne.g. ",(0,r.jsx)(n.code,{children:"record<x: number, y: boolean>"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dictionary"}),": a collection of arbitrary key-value pairs\ne.g. ",(0,r.jsx)(n.code,{children:"dictionary<string, number>"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"indexed_collection"}),": collections whose elements can be accessed\nby a numeric index","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"list"}),": a collection of expressions, possibly recursive,\nwith optional dimensions, e.g. ",(0,r.jsx)(n.code,{children:"[number]"}),", ",(0,r.jsx)(n.code,{children:"[boolean^32]"}),",\n",(0,r.jsx)(n.code,{children:"[number^(2x3)]"}),". Used to represent a vector, a matrix or a\ntensor when the type of its elements is a number"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"tuple"}),": a fixed-size collection of named or unnamed elements,\ne.g. ",(0,r.jsx)(n.code,{children:"tuple<number, boolean>"}),", ",(0,r.jsx)(n.code,{children:"tuple<x: number, y: boolean>"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"numericprimitivetype",children:"NumericPrimitiveType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type NumericPrimitiveType = \n  | "number"\n  | "finite_number"\n  | "complex"\n  | "finite_complex"\n  | "imaginary"\n  | "real"\n  | "finite_real"\n  | "rational"\n  | "finite_rational"\n  | "integer"\n  | "finite_integer"\n  | "non_finite_number";\n'})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"number"}),": any numeric value = ",(0,r.jsx)(n.code,{children:"complex"})," + ",(0,r.jsx)(n.code,{children:"real"})," plus ",(0,r.jsx)(n.code,{children:"NaN"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"complex"}),": a number with non-zero real and imaginary parts = ",(0,r.jsx)(n.code,{children:"finite_complex"})," plus ",(0,r.jsx)(n.code,{children:"ComplexInfinity"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"finite_complex"}),": a finite complex number = ",(0,r.jsx)(n.code,{children:"imaginary"})," + ",(0,r.jsx)(n.code,{children:"finite_real"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"imaginary"}),": a complex number with a real part of 0 (pure imaginary)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"finite_number"}),": a finite numeric value = ",(0,r.jsx)(n.code,{children:"finite_complex"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"finite_real"}),": a finite real number = ",(0,r.jsx)(n.code,{children:"finite_rational"})," + ",(0,r.jsx)(n.code,{children:"finite_integer"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"finite_rational"}),": a pure rational number"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"finite_integer"}),": a whole number"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"real"}),": a complex number with an imaginary part of 0 = ",(0,r.jsx)(n.code,{children:"finite_real"})," + ",(0,r.jsx)(n.code,{children:"non_finite_number"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"non_finite_number"}),": ",(0,r.jsx)(n.code,{children:"PositiveInfinity"}),", ",(0,r.jsx)(n.code,{children:"NegativeInfinity"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"integer"}),": a whole number = ",(0,r.jsx)(n.code,{children:"finite_integer"})," + ",(0,r.jsx)(n.code,{children:"non_finite_number"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rational"}),": a pure rational number (not an integer) = ",(0,r.jsx)(n.code,{children:"finite_rational"})," + ",(0,r.jsx)(n.code,{children:"non_finite_number"})]}),"\n"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"namedelement",children:"NamedElement"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type NamedElement = {\n  name: string;\n  type: Type;\n};\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"functionsignature",children:"FunctionSignature"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type FunctionSignature = {\n  kind: "signature";\n  args: NamedElement[];\n  optArgs: NamedElement[];\n  variadicArg: NamedElement;\n  variadicMin: 0 | 1;\n  result: Type;\n};\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"algebraictype",children:"AlgebraicType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type AlgebraicType = {\n  kind: "union" | "intersection";\n  types: Type[];\n};\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"negationtype",children:"NegationType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type NegationType = {\n  kind: "negation";\n  type: Type;\n};\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"valuetype",children:"ValueType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type ValueType = {\n  kind: "value";\n  value: any;\n};\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"recordtype",children:"RecordType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type RecordType = {\n  kind: "record";\n  elements: Record<string, Type>;\n};\n'})}),(0,r.jsx)(n.p,{children:"A record is a collection of key-value pairs."}),(0,r.jsx)(n.p,{children:"The keys are strings. The set of keys is fixed."}),(0,r.jsx)(n.p,{children:"For a record type to be a subtype of another record type, it must have a\nsubset of the keys, and all their types must match (width subtyping)."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"dictionarytype",children:"DictionaryType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type DictionaryType = {\n  kind: "dictionary";\n  values: Type;\n};\n'})}),(0,r.jsx)(n.p,{children:"A dictionary is a collection of key-value pairs."}),(0,r.jsx)(n.p,{children:"The keys are strings. The set of keys is also not defined as part of the\ntype and can be modified at runtime."}),(0,r.jsx)(n.p,{children:"A dictionary is suitable for use as cache or data storage."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"collectiontype",children:"CollectionType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type CollectionType = {\n  kind: "collection" | "indexed_collection";\n  elements: Type;\n};\n'})}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"CollectionType"})," is a generic collection of elements of a certain type."]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Indexed collections: List, Tuple"}),"\n",(0,r.jsx)(n.li,{children:"Non-indexed: Set, Record, Dictionary"}),"\n"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"listtype",children:"ListType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type ListType = {\n  kind: "list";\n  elements: Type;\n  dimensions: number[];\n};\n'})}),(0,r.jsx)(n.p,{children:"The elements of a list can be accessed by their one-based index."}),(0,r.jsxs)(n.p,{children:["All elements of a list have the same type, but it can be a broad type,\nup to ",(0,r.jsx)(n.code,{children:"any"}),"."]}),(0,r.jsx)(n.p,{children:"The same element can be present in the list more than once."}),(0,r.jsx)(n.p,{children:"A list can be multi-dimensional. For example, a list of integers with\ndimensions 2x3x4 is a 3D tensor with 2 layers, 3 rows and 4 columns."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"symboltype",children:"SymbolType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type SymbolType = {\n  kind: "symbol";\n  name: string;\n};\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"expressiontype",children:"ExpressionType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type ExpressionType = {\n  kind: "expression";\n  operator: string;\n};\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"numerictype",children:"NumericType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type NumericType = {\n  kind: "numeric";\n  type: NumericPrimitiveType;\n  lower: number;\n  upper: number;\n};\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"settype",children:"SetType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type SetType = {\n  kind: "set";\n  elements: Type;\n};\n'})}),(0,r.jsx)(n.p,{children:"Each element of a set is unique (is not present in the set more than once).\nThe elements of a set are not indexed."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"tupletype",children:"TupleType"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type TupleType = {\n  kind: "tuple";\n  elements: NamedElement[];\n};\n'})}),(0,r.jsx)(n.p,{children:"The elements of a tuple are indexed and may be named or unnamed.\nIf one element is named, all elements must be named."})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"typereference",children:"TypeReference"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type TypeReference = {\n  kind: "reference";\n  name: string;\n  alias: boolean;\n  def: Type | undefined;\n};\n'})}),(0,r.jsx)(n.p,{children:"Nominal typing"})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"type-2",children:"Type"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type Type = \n  | PrimitiveType\n  | AlgebraicType\n  | NegationType\n  | CollectionType\n  | ListType\n  | SetType\n  | RecordType\n  | DictionaryType\n  | TupleType\n  | SymbolType\n  | ExpressionType\n  | NumericType\n  | NumericPrimitiveType\n  | FunctionSignature\n  | ValueType\n  | TypeReference;\n"})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"typestring",children:"TypeString"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type TypeString = string;\n"})}),(0,r.jsx)(n.p,{children:"The type of a boxed expression indicates the kind of expression it is and\nthe value it represents."}),(0,r.jsx)(n.p,{children:"The type is represented either by a primitive type (e.g. number, complex, collection, etc.), or a compound type (e.g. tuple, function signature, etc.)."}),(0,r.jsx)(n.p,{children:"Types are described using the following BNF grammar:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bnf",children:'<type> ::= <union_type> | "(" <type> ")"\n\n<union_type> ::= <intersection_type> (" | " <intersection_type>)*\n\n<intersection_type> ::= <primary_type> (" & " <primary_type>)*\n\n<primary_type> ::=  <primitive>\n               | <tuple_type>\n               | <signature>\n               | <list_type>\n\n<primitive> ::= "any" | "unknown" | <value-type> | <symbolic-type> | <numeric-type>\n\n<numeric-type> ::= "number" | "complex" | "imaginary" | "real" | "rational" | "integer"\n\n<value-type> ::= "value" | <numeric-type> | "collection" | "boolean" | "string"\n\n<symbolic-type> ::= "expression" | "function" | "symbol"\n\n<tuple_type> ::= "tuple<" (<name> <type> "," <named_tuple_elements>*) ">"\n           | "tuple<" (<type> "," <unnamed_tuple_elements>*) ">" |\n           | "tuple<" <tuple_elements> ">"\n\n<tuple_elements> ::= <unnamed_tuple_elements> | <named_tuple_elements>\n\n<unnamed_tuple_elements> ::= <type> ("," <type>)*\n\n<named_tuple_elements> ::= <name> <type> ("," <name> <type>)*\n\n<signature> ::=  <arguments> " -> " <type>\n\n<arguments> ::= "()"\n           | <argument>\n           | "(" <argument-list> ")"\n\n<argument> ::= <type>\n           | <name> <type>\n\n<rest_argument> ::= "..." <type>\n           | <name> "..." <type>\n\n<optional_argument> ::= <argument> "?"\n\n<optional_arguments> ::= <optional_argument> ("," <optional_argument>)*\n\n<required_arguments> ::= <argument> ("," <argument>)*\n\n<argument-list> ::= <required_arguments> ("," <rest_argument>)?\n           | <required_arguments> <optional_arguments>?\n           | <optional_arguments>?\n           | <rest_argument>\n\n<list_type> ::= "list<" <type> <dimensions>? ">"\n\n<dimensions> ::= "^" <fixed_size>\n           | "^(" <multi_dimensional_size> ")"\n\n<fixed_size> ::= <positive-integer_literal>\n\n<multi_dimensional_size> ::= <positive-integer_literal> "x" <positive-integer_literal> ("x" <positive-integer_literal>)*\n\n<map> ::= "map" | "map<" <map_elements> ">"\n\n<map_elements> ::= <name> <type> ("," <name> <type>)*\n\n<set> ::= "set<" <type> ">"\n\n<collection ::= "collection<" <type> ">"\n\n<name> ::= <identifier> ":"\n\n<identifier> ::= [a-zA-Z_][a-zA-Z0-9_]*\n\n<positive-integer_literal> ::= [1-9][0-9]*\n'})}),(0,r.jsx)(n.p,{children:"Examples of types strings:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"number"'}),"    -- a simple type primitive"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"(number, boolean)"'})," -- a tuple type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"(x: number, y:boolean)"'})," -- a named tuple/record type. Either all arguments are named, or none are"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"collection<any>"'})," -- an arbitrary collection type, with no length or element type restrictions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"collection<integer>"'})," -- a collection type where all the elements are integers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"collection<(number, boolean)>"'})," -- a collection of tuples"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"collection<(value:number, seen:boolean)>"'})," -- a collection of named tuples"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"[boolean]^32"'})," -- a collection type with a fixed size of 32 elements"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"[integer]^(2x3)"'})," -- an integer matrix of 2 columns and 3 rows"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"[integer]^(2x3x4)"'})," -- a tensor of dimensions 2x3x4"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"number -> number"'})," -- a signature with a single argument"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"(x: number, number) -> number"'})," -- a signature with a named argument"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"(number, y:number?) -> number"'})," -- a signature with an optional named argument (can have several optional arguments, at the end)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"(number, number+) -> number"'})," -- a signature with a rest argument (can have only one, and no optional arguments if there is a rest argument)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"() -> number"'})," -- a signature with an empty argument list"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"number | boolean"'})," -- a union type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"(x: number) & (y: number)"'})," -- an intersection type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"number | ((x: number) & (y: number))"'})," -- a union type with an intersection type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"(number -> number) | number"'})," -- a union type with a signature and a primitive type"]}),"\n"]})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"typecompatibility",children:"TypeCompatibility"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type TypeCompatibility = "covariant" | "contravariant" | "bivariant" | "invariant";\n'})})]}),"\n",(0,r.jsxs)(d.A,{children:[(0,r.jsx)(n.h3,{id:"typeresolver",children:"TypeResolver"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type TypeResolver = {\n  get names: string[];\n  forward: (name) => TypeReference | undefined;\n  resolve: (name) => TypeReference | undefined;\n};\n"})}),(0,r.jsx)(n.p,{children:"A type resolver should return a definition for a given type name."})]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(x,{...e})}):x(e)}},7471(e,n,s){s.d(n,{A:()=>d});const i="memberCard_JQCf";var r=s(4164),l=s(4848);function d({children:e}){return(0,l.jsx)("div",{className:(0,r.A)(i,"member-card"),children:e})}},8453(e,n,s){s.d(n,{R:()=>d,x:()=>a});var i=s(6540);const r={},l=i.createContext(r);function d(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);