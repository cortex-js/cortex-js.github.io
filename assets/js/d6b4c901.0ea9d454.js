"use strict";(self.webpackChunkcortexjs_io=self.webpackChunkcortexjs_io||[]).push([[6494],{2184:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"compute-engine/guide-assumptions","title":"Assumptions","description":"Assumptions are statements about symbols that are assumed to be true. For","source":"@site/docs/compute-engine/14-guide-assumptions.md","sourceDirName":"compute-engine","slug":"/compute-engine/guides/assumptions/","permalink":"/compute-engine/guides/assumptions/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1746150700000,"sidebarPosition":14,"frontMatter":{"title":"Assumptions","slug":"/compute-engine/guides/assumptions/"},"sidebar":"docSidebar","previous":{"title":"Compiling Expressions","permalink":"/compute-engine/guides/compiling/"},"next":{"title":"Patterns and Rules","permalink":"/compute-engine/guides/patterns-and-rules/"}}');var i=n(4848),r=n(8453);const o={title:"Assumptions",slug:"/compute-engine/guides/assumptions/"},a=void 0,c={},l=[{value:"Defining New Assumptions",id:"defining-new-assumptions",level:2},{value:"Assumptions Lifecycle",id:"assumptions-lifecycle",level:2},{value:"Assumption Propositions",id:"assumption-propositions",level:2},{value:"Verifying Assumptions",id:"verifying-assumptions",level:2}];function d(e){const s={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components},{Icon:n,Intro:t,ReadMore:o}=s;return n||p("Icon",!0),t||p("Intro",!0),o||p("ReadMore",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t,{children:(0,i.jsx)(s.p,{children:"Assumptions are statements about symbols that are assumed to be true. For\nexample, the assumption that \\(x\\) is a positive real number can be used to\nsimplify \\(|x|\\) to \\(x\\)."})}),"\n",(0,i.jsx)(s.p,{children:"Assumptions can be used to describe the range of values that a symbol can take."}),"\n",(0,i.jsx)(s.p,{children:"The assumptions knowledge base is then used by the Compute Engine to simplify\nexpressions."}),"\n",(0,i.jsx)(o,{path:"/compute-engine/guides/simplify/",children:(0,i.jsxs)(s.p,{children:["Read more about ",(0,i.jsx)(s.strong,{children:"Simplifying Expressions"})," ",(0,i.jsx)(n,{name:"chevron-right-bold"})]})}),"\n",(0,i.jsx)(s.p,{children:"For example, the assumption that \\(x\\) is positive is used to simplify\n\\(\\sqrt{x^2}\\) to \\(x\\)."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'ce.assume(["Greater", "x", 0]);\nce.parse("\\\\sqrt{x^2}").simplify().print();\n// \u2794 x\n'})}),"\n",(0,i.jsx)(s.p,{children:"Assumptions can be used for other operations as well, such as solving equations or\nintegrating."}),"\n",(0,i.jsx)(s.h2,{id:"defining-new-assumptions",children:"Defining New Assumptions"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"To make an assumption about a symbol"}),", use the ",(0,i.jsx)(s.code,{children:"ce.assume()"})," method."]}),"\n",(0,i.jsx)(s.p,{children:"For example, to indicate \\(\\beta \\neq 0\\):"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'ce.assume(ce.parse("\\\\beta \\\\neq 0"));\n'})}),"\n",(0,i.jsxs)(s.p,{children:["Each call to ",(0,i.jsx)(s.code,{children:"ce.assume()"})," replaces the previous assumptions about the symbol."]}),"\n",(0,i.jsx)(s.h2,{id:"assumptions-lifecycle",children:"Assumptions Lifecycle"}),"\n",(0,i.jsx)(s.p,{children:"Assumptions are stored in a knowledge base which is tied to the current\nevaluation context."}),"\n",(0,i.jsx)(s.p,{children:"Any assumptions made in the current context are automatically inherited by all\nchild contexts."}),"\n",(0,i.jsx)(s.p,{children:"When a context is exited, all assumptions made in that context are forgotten."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"To remove previous assumptions"}),", use ",(0,i.jsx)(s.code,{children:"ce.forget()"}),"."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Invoking ",(0,i.jsx)(s.code,{children:"ce.forget()"})," with no arguments will remove all assumptions."]}),"\n",(0,i.jsx)(s.li,{children:"Passing an array of symbol names will remove assumptions about each of the\nsymbols."}),"\n",(0,i.jsx)(s.li,{children:"Passing a symbol name will only remove assumptions about that particular\nsymbol."}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'ce.declare("x", "number");\nce.assume(ce.parse("x > 0"));\nce.is(ce.parse("x > 2"));\n// \u2794  true\n\nce.forget("x");\n\nce.is(ce.parse("x > 2"));\n// \u2794  undefined\n'})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"To temporarily define a series of assumptions"}),", create a new scope."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'ce.declare("x", "number");\nce.is(ce.parse("x > 2"));\n// \u2794 undefined\n\nce.pushScope();\n\nce.assume(ce.parse("x > 0"));\nce.is(ce.parse("x > 2"));\n// \u2794  true\n\nce.popScope(); // all assumptions made in the current scope are forgotten\n\nce.is(ce.parse("x > 2"));\n// \u2794  undefined\n'})}),"\n",(0,i.jsx)(s.h2,{id:"assumption-propositions",children:"Assumption Propositions"}),"\n",(0,i.jsxs)(s.p,{children:["The argument of the ",(0,i.jsx)(s.code,{children:"ce.assume()"})," method is a ",(0,i.jsx)(s.strong,{children:"proposition"}),". A proposition is a\nstatement that can be either true or false. Assumption propositions can take\nthe following forms:"]}),"\n",(0,i.jsx)("div",{className:"symbols-table",children:(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{style:{textAlign:"left"},children:"Operator"}),(0,i.jsx)(s.th,{style:{textAlign:"left"}})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,i.jsx)(s.code,{children:"Element"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"NotElement"})]}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:"Indicate the domain of a symbol"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,i.jsx)(s.code,{children:"Less"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"LessEqual"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"Greater"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"GreaterEqual"})]}),(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:["Inequality. Both sides are assumed to be ",(0,i.jsx)(s.code,{children:"RealNumbers"})]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsxs)(s.td,{style:{textAlign:"left"},children:[(0,i.jsx)(s.code,{children:"Equal"}),(0,i.jsx)("br",{}),(0,i.jsx)(s.code,{children:"NotEqual"})]}),(0,i.jsx)(s.td,{style:{textAlign:"left"},children:"Equality"})]})]})]})}),"\n",(0,i.jsx)(s.p,{children:"Some propositions can be described in several equivalent ways. You can use\nwhichever form you prefer. Similarly, when querying the knowledge base later,\nyou can use any form you'd like."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:"example",children:'ce.assume(ce.parse("x > 0"));\n\n// Equivalent to...\nce.assume(ce.parse("0 < x"));\n'})}),"\n",(0,i.jsx)(s.h2,{id:"verifying-assumptions",children:"Verifying Assumptions"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"To test if a particular assumption is valid"})," call the ",(0,i.jsx)(s.code,{children:"ce.verify()"})," method."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'ce.verify(ce.parse("x > 0"));\n'})}),"\n",(0,i.jsxs)(s.p,{children:["The method ",(0,i.jsx)(s.code,{children:"ce.verify()"})," return ",(0,i.jsx)(s.code,{children:"true"})," if the assumption is true, ",(0,i.jsx)(s.code,{children:"false"})," if it is\nnot, and ",(0,i.jsx)(s.code,{children:"undefined"})," if it cannot be determined."]}),"\n",(0,i.jsxs)(s.p,{children:["While ",(0,i.jsx)(s.code,{children:"ce.verify()"})," is appropriate to get boolean answers, more complex queries can\nalso be made."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"To query the assumptions knowledge base"})," call the ",(0,i.jsx)(s.code,{children:"ce.ask()"})," method."]}),"\n",(0,i.jsxs)(s.p,{children:["The argument of ",(0,i.jsx)(s.code,{children:"ce.ask()"})," can be a pattern, and it returns an array of matches as\n",(0,i.jsx)(s.code,{children:"Substitution"})," objects."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",children:'// "x is a positive integer"\nce.assume(ce.parse("x > 0"));\n\n// "What is x greater than?"\nce.ask(["Greater", "x", "_val"]);\n\n//  -> [{"val": 0}] "It is greater than 0"\n'})}),"\n",(0,i.jsx)(o,{path:"/compute-engine/guides/patterns-and-rules/",children:(0,i.jsxs)(s.p,{children:["Read more about ",(0,i.jsx)(s.strong,{children:"Patterns and Rules"}),(0,i.jsx)(n,{name:"chevron-right-bold"})]})})]})}function u(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function p(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>a});var t=n(6540);const i={},r=t.createContext(i);function o(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);