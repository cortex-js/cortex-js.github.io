"use strict";(self.webpackChunkcortexjs_io=self.webpackChunkcortexjs_io||[]).push([[568],{9249:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"compute-engine/guide-augmenting","title":"Custom Functions and Symbols","description":"The MathJSON Standard Library is a","source":"@site/docs/compute-engine/06-guide-augmenting.md","sourceDirName":"compute-engine","slug":"/compute-engine/guides/augmenting/","permalink":"/compute-engine/guides/augmenting/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1743780205000,"sidebarPosition":6,"frontMatter":{"title":"Custom Functions and Symbols","slug":"/compute-engine/guides/augmenting/"},"sidebar":"docSidebar","previous":{"title":"Symbols","permalink":"/compute-engine/guides/symbols/"},"next":{"title":"LaTeX Syntax","permalink":"/compute-engine/guides/latex-syntax/"}}');var a=i(4848),t=i(8453);const o={title:"Custom Functions and Symbols",slug:"/compute-engine/guides/augmenting/"},r=void 0,c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Automatic Declaration",id:"automatic-declaration",level:3},{value:"Declarations are Scoped",id:"declarations-are-scoped",level:3},{value:"Definitions Using LaTeX",id:"definitions-using-latex",level:2},{value:"Explicit Declarations",id:"explicit-declarations",level:2},{value:"Defining a Symbol",id:"defining-a-symbol",level:3},{value:"Defining a Function",id:"defining-a-function",level:3},{value:"Overloading Functions",id:"overloading-functions",level:2},{value:"Defining Multiple Functions and Symbols",id:"defining-multiple-functions-and-symbols",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components},{Icon:i,ReadMore:s}=n;return i||u("Icon",!0),s||u("ReadMore",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"/compute-engine/guides/standard-library/",children:"MathJSON Standard Library"})," is a\ncollection of definitions for ",(0,a.jsx)(n.strong,{children:"symbols"})," and ",(0,a.jsx)(n.strong,{children:"functions"})," such as ",(0,a.jsx)(n.code,{children:"Pi"}),", ",(0,a.jsx)(n.code,{children:"Add"}),",\n",(0,a.jsx)(n.code,{children:"Sin"}),", ",(0,a.jsx)(n.code,{children:"Power"}),", ",(0,a.jsx)(n.code,{children:"List"}),", etc..."]}),"\n",(0,a.jsx)(n.p,{children:"In this guide we discuss how to augment the MathJSON Standard Library with your\nown definitions."}),"\n",(0,a.jsxs)(s,{path:"/compute-engine/guides/latex-syntax/#customizing-the-latex-dictionary",children:[(0,a.jsxs)(n.p,{children:["You may also be interested in ",(0,a.jsx)(n.strong,{children:"augmenting the LaTeX dictionary"})," which defines\nhow LaTeX is parsed from and serialized to MathJSON."]}),(0,a.jsxs)(n.p,{children:["This is useful if you want to add support for custom LaTeX macros that you'd\nlike to parse to MathJSON. ",(0,a.jsx)(i,{name:"chevron-right-bold"})]})]}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:"When a new symbol or function is encountered in an expression, the Compute Engine\nwill look up its definition in the set of known identifiers, including the Standard\nLibrary."}),"\n",(0,a.jsx)(n.h3,{id:"automatic-declaration",children:"Automatic Declaration"}),"\n",(0,a.jsx)(n.p,{children:"If the identifier is found, the definition associated with it will be\nused to evaluate the expression."}),"\n",(0,a.jsxs)(n.p,{children:["If the identifier is not found, an automatic declaration will be made of the\nidentifier as a symbol of type ",(0,a.jsx)(n.code,{children:"unknown"}),", or a more specific type if the\ncontext allows it."]}),"\n",(0,a.jsx)(s,{path:"/compute-engine/guides/types",children:(0,a.jsxs)(n.p,{children:["Learn more about ",(0,a.jsx)(n.strong,{children:"types"}),".",(0,a.jsx)(i,{name:"chevron-right-bold"})]})}),"\n",(0,a.jsxs)(n.p,{children:["To provide a more explicit definition for the identifier, you can ",(0,a.jsx)(n.a,{href:"#definitions-using-latex",children:"define it\nusing a LaTeX"})," expression, or an ",(0,a.jsx)(n.a,{href:"#explicit-declarations",children:"explicit declaration"})," using the ",(0,a.jsx)(n.code,{children:"ce.declare()"}),"\nor ",(0,a.jsx)(n.code,{children:"ce.assign()"})," methods."]}),"\n",(0,a.jsx)(n.h3,{id:"declarations-are-scoped",children:"Declarations are Scoped"}),"\n",(0,a.jsxs)(n.p,{children:["The declaration of an identifier is done within a ",(0,a.jsx)(n.strong,{children:"scope"}),". A scope is a\nhierarchical collection of definitions."]}),"\n",(0,a.jsx)(s,{path:"/compute-engine/guides/evaluate/#scopes",children:(0,a.jsxs)(n.p,{children:["Read more about ",(0,a.jsx)(n.strong,{children:"scopes"})," ",(0,a.jsx)(i,{name:"chevron-right-bold"})]})}),"\n",(0,a.jsx)(n.h2,{id:"definitions-using-latex",children:"Definitions Using LaTeX"}),"\n",(0,a.jsx)(n.p,{children:"The simplest way to define a new symbol or function is to use LaTeX."}),"\n",(0,a.jsxs)(n.p,{children:["For example, to define a new symbol ",(0,a.jsx)(n.code,{className:"language-math math-inline",children:"m"})," with a value of ",(0,a.jsx)(n.code,{className:"language-math math-inline",children:"42"}),", use the\nfollowing LaTeX expression:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.parse("m := 42").evaluate();\nce.parse("m").evaluate().print();\n// \u2794 42\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Note"}),": the assignment expression must be evaluated to take effect."]}),"\n",(0,a.jsxs)(n.p,{children:["To define a new function ",(0,a.jsx)(n.code,{className:"language-math math-inline",children:"f"})," that multiplies its argument by ",(0,a.jsx)(n.code,{className:"language-math math-inline",children:"2"}),", use\nthe following LaTeX expression:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.parse("f(x) := 2x").evaluate();\nce.parse("f(3)").evaluate().print();\n// \u2794 6\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"\\mapsto"})," operator is an alternative syntax to define a function:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.parse("f := x \\\\mapsto 2x").evaluate();\nce.parse("f(3)").evaluate().print();\n// \u2794 6\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To define multiletter symbols"}),", use the ",(0,a.jsx)(n.code,{children:"\\operatorname{}"})," command:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"ce.parse('\\\\operatorname{double}(x) := 2x').evaluate().print();\nce.parse('\\\\operatorname{double}(3)').evaluate().print();\n// \u2794 6\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Note"}),": you can also use the ",(0,a.jsx)(n.code,{children:"\\mathrm{}"})," or ",(0,a.jsx)(n.code,{children:"\\mathit{}"})," commands to wrap\nmultiletter symbols."]}),"\n",(0,a.jsxs)(n.p,{children:["The LaTeX identifiers are mapped to MathJSON identifiers. For example,\nthe LaTeX ",(0,a.jsx)(n.code,{children:"\\operatorname{double}"})," is mapped to the MathJSON identifier ",(0,a.jsx)(n.code,{children:"double"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"console.info(ce.parse('\\\\operatorname{double}(3)').json);\n// \u2794 [\"double\", 3]\n"})}),"\n",(0,a.jsx)(n.h2,{id:"explicit-declarations",children:"Explicit Declarations"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To have more control over the definition of a symbol or function"}),", use\nthe ",(0,a.jsx)(n.code,{children:"ce.declare()"})," and ",(0,a.jsx)(n.code,{children:"ce.assign()"})," methods."]}),"\n",(0,a.jsx)(n.p,{children:"When declaring a symbol or function, you can specify the type of the symbol or signature of the function, its\nvalue or body, and other properties."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'// Declaring a symbol "m"\nce.declare("m", { type: "integer", value: 42 });\n\n// Declaring a function "f"\nce.declare("f", {\n  signature: "number -> number",\n  evaluate: ce.parse("x \\\\mapsto 2x"),\n});\n'})}),"\n",(0,a.jsx)(n.h3,{id:"defining-a-symbol",children:"Defining a Symbol"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To prevent the value of a symbol from being changed"}),", set the ",(0,a.jsx)(n.code,{children:"constant"}),"\nproperty to ",(0,a.jsx)(n.code,{children:"true"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("m_e", {\n  value: 9.1e-31,\n  constant: true,\n});\n'})}),"\n",(0,a.jsxs)(n.p,{children:["If you do not provide a ",(0,a.jsx)(n.code,{children:"type"})," property for a symbol, the type will be\ninferred from the value of the symbol. If no type and no value are\nprovided, the type will be ",(0,a.jsx)(n.code,{children:"unknown"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To provide the type of the identifier, without associating\nit with a value"}),", use the following syntax:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("n", "integer");\n'})}),"\n",(0,a.jsxs)(n.p,{children:["As a shorthand, a symbol can be declated by assigning it a value using ",(0,a.jsx)(n.code,{children:"ce.assign()"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.assign("m", 42);\n'})}),"\n",(0,a.jsx)(n.p,{children:"If the symbol was not previously defined, this is equivalent to:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("m", { value: 42 });\n'})}),"\n",(0,a.jsx)(n.p,{children:"Alternatively:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.box("m").value = 42;\n'})}),"\n",(0,a.jsx)(n.h3,{id:"defining-a-function",children:"Defining a Function"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To define a function"}),", associate an ",(0,a.jsx)(n.code,{children:"evaluate"})," handler, which\nis the body of the function, with the function declaration."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("double", { evaluate: ce.parse("x \\\\mapsto 2x") });\n'})}),"\n",(0,a.jsx)(n.p,{children:"The evaluate handler can be either a MathJSON expression as above or\na JavaScript function."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("double", { evaluate: ([x]) => x.mul(2) });\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The signature of the ",(0,a.jsx)(n.code,{children:"evaluate"})," handler is ",(0,a.jsx)(n.code,{children:"(args[], options)"}),", where:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"args"}),": an array of the arguments that have been applied to the function. Each\nargument is a boxed expression. The array may be empty if there are no\narguments."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"options"}),": an object literal which includes an ",(0,a.jsx)(n.code,{children:"engine"})," property that is the\nCompute Engine instance that is evaluating the expression and a ",(0,a.jsx)(n.code,{children:"numericApproximation"})," property that is true if the result should be a numeric approximation."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Since ",(0,a.jsx)(n.code,{children:"args"})," is an array, you can use destructuring to get the arguments:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("double", { evaluate: (args) => args[0].mul(2) });\n\n// or\nce.declare("double", { evaluate: ([x]) => x.mul(2) });\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In addition to the ",(0,a.jsx)(n.code,{children:"evaluate"})," handler the function definition can include\na ",(0,a.jsx)(n.code,{children:"signature"})," type that describes the arguments and return value of the\nfunction."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("double", {\n  signature: "number -> number",\n  evaluate: ([x]) => x.mul(2),\n});\n'})}),"\n",(0,a.jsxs)(n.p,{children:["See ",(0,a.jsx)(n.code,{children:"FunctionDefinition"})," for more details on the other handlers and\nproperties that can be provided when defining a function."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To define a function without specifying a body for it"}),", specify\nthe signature of the function as the second argument of ",(0,a.jsx)(n.code,{children:"ce.declare()"})," or\nuse the ",(0,a.jsx)(n.code,{children:'"function"'})," type."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("double", "function" );\n'})}),"\n",(0,a.jsx)(n.p,{children:"Functions that do not have an evaluate handler remain unchanged when\nevaluated."}),"\n",(0,a.jsxs)(n.p,{children:["You can set the body of the function later using ",(0,a.jsx)(n.code,{children:"ce.assign()"}),":"]}),"\n",(0,a.jsxs)(n.p,{children:["When using ",(0,a.jsx)(n.code,{children:"ce.assign()"})," to define a function, the value can be a JavaScript\nfunction, a MathJSON expression or a LaTeX expression."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.assign("double", ([x]) => x.mul(2));\n\nce.assign("double", ["Function", ["Multiply", "x", 2], "x"]);\n\nce.assign("double",ce.parse("x \\\\mapsto 2x"));\n'})}),"\n",(0,a.jsx)(n.h2,{id:"overloading-functions",children:"Overloading Functions"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To overload a function"}),", use the ",(0,a.jsx)(n.code,{children:"ce.lookupFunction()"})," and  ",(0,a.jsx)(n.code,{children:"ce.define()"})," methods."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, to overload the ",(0,a.jsx)(n.code,{children:"Sqrt"})," function to return ",(0,a.jsx)(n.code,{children:"NaN"})," for\nnon-real numbers, you can use the following code:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const originalSqrtDefinition = ce.lookupFunction('Sqrt')!;\nce.defineFunction('Sqrt', {\n  ...originalSqrtDefinition,\n  evaluate: (x, options) => {\n    const y = originalSqrtDefinition.evaluate!(x, options);\n    return y?.isReal ? y : ce.NaN;\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"defining-multiple-functions-and-symbols",children:"Defining Multiple Functions and Symbols"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To define multiple functions and symbols"}),", use the ",(0,a.jsx)(n.code,{children:"ce.declare()"})," method\nwith a dictionary of definitions."]}),"\n",(0,a.jsx)(n.admonition,{title:"Note",type:"info",children:(0,a.jsxs)(n.p,{children:["The keys to ",(0,a.jsx)(n.code,{children:"ce.declare()"})," (",(0,a.jsx)(n.code,{children:"m"}),", ",(0,a.jsx)(n.code,{children:"f"}),", etc...) are MathJSON\nidentifiers, not LaTeX commands. For example, if you have a symbol ",(0,a.jsx)(n.code,{children:"\u03b1"}),", use\n",(0,a.jsx)(n.code,{children:"alpha"}),", not ",(0,a.jsx)(n.code,{children:"\\alpha"})]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare({\n  m: { type: "number", value: 5 },\n  f: { type: "function" },\n  g: { type: "function" },\n  Smallfrac: {\n    signature: "(number, number) -> number",\n    evaluate: ([x,y]) => x.div(y),\n  },\n});\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To assign multiple functions and symbols"}),", use the ",(0,a.jsx)(n.code,{children:"ce.assign()"})," method with\na dictionary of values."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.assign({\n  "m": 10,\n  "f(x)": ce.parse("x^2 + x + 41"),\n  "g(t)": ce.parse("t^3 + t^2 + 17"),\n});\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>r});var s=i(6540);const a={},t=s.createContext(a);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);