"use strict";(globalThis.webpackChunkcortexjs_io=globalThis.webpackChunkcortexjs_io||[]).push([[653],{3202(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"compute-engine/guide-symbolic-computing","title":"Symbolic Computing","description":"The Compute Engine essentially performs computation by applying","source":"@site/docs/compute-engine/09-guide-symbolic-computing.md","sourceDirName":"compute-engine","slug":"/compute-engine/guides/symbolic-computing/","permalink":"/compute-engine/guides/symbolic-computing/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1746803465000,"sidebarPosition":9,"frontMatter":{"title":"Symbolic Computing","slug":"/compute-engine/guides/symbolic-computing/","date":"Last Modified"},"sidebar":"docSidebar","previous":{"title":"Evaluation of Expressions","permalink":"/compute-engine/guides/evaluate/"},"next":{"title":"Numeric Evaluation","permalink":"/compute-engine/guides/numeric-evaluation/"}}');var i=s(4848),r=s(8453);const l={title:"Symbolic Computing",slug:"/compute-engine/guides/symbolic-computing/",date:"Last Modified"},a=void 0,o={},c=[{value:"Comparing Expressions",id:"comparing-expressions",level:2},{value:"Structural Equality: <code>isSame()</code>",id:"structural-equality-issame",level:3},{value:"Mathematical Equality: <code>isEqual()</code>",id:"mathematical-equality-isequal",level:3},{value:"Other Comparisons",id:"other-comparisons",level:3},{value:"Replacing a Symbol in an Expresssion",id:"replacing-a-symbol-in-an-expresssion",level:2},{value:"Other Symbolic Manipulation",id:"other-symbolic-manipulation",level:2}];function d(e){const n={a:"a",code:"code","code-playground":"code-playground",div:"div",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components},s=n["code-playground"],{Icon:t,Intro:l,ReadMore:a}=n;return t||x("Icon",!0),l||x("Intro",!0),a||x("ReadMore",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(l,{children:(0,i.jsx)(n.p,{children:"The Compute Engine essentially performs computation by applying\nrewriting rules to a MathJSON expression."})}),"\n",(0,i.jsx)(n.p,{children:"There are three common transformations that can be applied to an expression:"}),"\n",(0,i.jsx)("div",{className:"symbols-table first-column-header",style:{"--first-col-width":"16ch"},children:(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Transformation"}),(0,i.jsx)(n.th,{style:{textAlign:"left"}})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"expr.simplify()"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Eliminate constants and common sub-expressions. Use available assumptions to determine which rules are applicable. Limit calculations to exact results."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"expr.evaluate()"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Calculate the exact value of an expression. Replace symbols with their value."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"expr.N()"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Calculate a numeric approximation of an expression using floating point numbers."})]})]})]})}),"\n",(0,i.jsxs)(n.p,{children:["A key difference between ",(0,i.jsx)(n.code,{children:"expr.evaluate()"})," and ",(0,i.jsx)(n.code,{children:"expr.N()"})," is that the former\nwill use the exact value of symbols, while the latter will use their numeric\napproximation. An exact value is a rational number, an integer, the square root\nof an integer and some constants such as \\(\\pi\\) or \\(e\\). A numeric\napproximation is a floating point number."]}),"\n",(0,i.jsx)("div",{className:"first-column-header",children:(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"\xa0"}),(0,i.jsx)(n.th,{style:{textAlign:"center"},children:(0,i.jsx)(n.code,{children:"expr.simplify()"})}),(0,i.jsx)(n.th,{style:{textAlign:"center"},children:(0,i.jsx)(n.code,{children:"expr.evaluate()"})}),(0,i.jsx)(n.th,{style:{textAlign:"center"},children:(0,i.jsx)(n.code,{children:"expr.N()"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Use assumptions on symbols"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:(0,i.jsx)(t,{name:"circle-check",color:"green-700"})}),(0,i.jsx)(n.td,{style:{textAlign:"center"}}),(0,i.jsx)(n.td,{style:{textAlign:"center"}})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Exact calculations"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:(0,i.jsx)(t,{name:"circle-check",color:"green-700"})}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:(0,i.jsx)(t,{name:"circle-check",color:"green-700"})}),(0,i.jsx)(n.td,{style:{textAlign:"center"}})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Floating-point approximations"}),(0,i.jsx)(n.td,{style:{textAlign:"center"}}),(0,i.jsx)(n.td,{style:{textAlign:"center"}}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:(0,i.jsx)(t,{name:"circle-check",color:"green-700"})})]})]})]})}),"\n",(0,i.jsxs)(a,{path:"/compute-engine/guides/simplify/",children:[" Read more about\n",(0,i.jsx)("strong",{children:"Simplify"})," ",(0,i.jsx)(t,{name:"chevron-right-bold"})]}),"\n",(0,i.jsxs)(a,{path:"/compute-engine/guides/evaluate/",children:[" Read more about\n",(0,i.jsx)("strong",{children:"Evaluate"})," ",(0,i.jsx)(t,{name:"chevron-right-bold"})]}),"\n",(0,i.jsxs)(a,{path:"/compute-engine/guides/numeric-evaluation/",children:[" Read more about\n",(0,i.jsx)("strong",{children:"Numerical Evaluation"})," ",(0,i.jsx)(t,{name:"chevron-right-bold"})]}),"\n",(0,i.jsx)(n.p,{children:"Other operations can be performed on an expression: comparing it to a pattern,\nreplacing part of it, and applying conditional rewrite rules."}),"\n",(0,i.jsx)(s,{"show-line-numbers":"",children:(0,i.jsxs)(n.div,{slot:"javascript",children:["const expr = ce.parse('3x^2 + 2x^2 + x + 5');\n","console.log(expr, '=', expr.simplify());\n"]})}),"\n",(0,i.jsx)(n.h2,{id:"comparing-expressions",children:"Comparing Expressions"}),"\n",(0,i.jsx)(n.p,{children:"There are two useful ways to compare symbolic expressions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"structural equality"}),"\n",(0,i.jsx)(n.li,{children:"mathematical equality"}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"structural-equality-issame",children:["Structural Equality: ",(0,i.jsx)(n.code,{children:"isSame()"})]}),"\n",(0,i.jsxs)(n.p,{children:["Structural equality (or syntactic equality) considers the ",(0,i.jsx)(n.strong,{children:"symbolic structure"})," used\nto represent an expression."]}),"\n",(0,i.jsx)(n.p,{children:"The symbolic structure of an expression is the tree of symbols and functions\nthat make up the expression."}),"\n",(0,i.jsxs)(n.p,{children:["For example, the symbolic structure of \\(2 + 1\\) is a sum of two terms,\nthe first term is the number ",(0,i.jsx)(n.code,{children:"2"})," and the second term is the number ",(0,i.jsx)(n.code,{children:"1"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The symbolic structure of \\(3\\) is a number ",(0,i.jsx)(n.code,{children:"3"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The symbolic structure of \\(2 + 1\\) and \\(3\\) are different, even though\nthey represent the same mathematical object."}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"lhs.isSame(rhs)"})," function returns true if ",(0,i.jsx)(n.code,{children:"lhs"})," and ",(0,i.jsx)(n.code,{children:"rhs"})," are structurally\nexactly identical, that is each sub-expression is recursively identical in ",(0,i.jsx)(n.code,{children:"lhs"}),"\nand ",(0,i.jsx)(n.code,{children:"rhs"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\\(1 + 1 \\) and \\( 2 \\) are not structurally equal, one is a sum of two\nintegers, the other is an integer"}),"\n",(0,i.jsx)(n.li,{children:"\\( (x + 1)^2 \\) and \\( x^2 + 2x + 1 \\) are not structural equal, one is a\npower of a sum, the other a sum of terms."}),"\n"]}),"\n",(0,i.jsx)(s,{"show-line-numbers":"",children:(0,i.jsxs)(n.div,{slot:"javascript",children:["const a = ce.parse('2 + 1');\n","const b = ce.parse('3');\n","console.log('isSame?', a.isSame(b));\n"]})}),"\n",(0,i.jsx)(n.p,{children:"By default, when parsing or boxing an expression, they are put in canonical\nform. For example, fractions are automatically reduced to their simplest form,\nand arguments are sorted in a standard way."}),"\n",(0,i.jsxs)(n.p,{children:["The expressions \\( \\frac",1,10," \\) and \\( \\frac",2,20," \\) are\nstructurally equal because they get put into a canonical form when parsed,\nin which the fractions are reduced."]}),"\n",(0,i.jsxs)(n.p,{children:["Similarly, \\( x^2 - 3x + 4 \\) and \\( 4 - 3x + x^2 \\) are structurally equal\n(",(0,i.jsx)(n.code,{children:"isSame"})," returns true) because the arguments of the sum are sorted in a standard\nway."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To compare two expressions without canonicalizing them"}),", parse or box\nthem with the ",(0,i.jsx)(n.code,{children:"canonical"})," option set to ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsx)(s,{"show-line-numbers":"","mark-javascript-line":"5-6",children:(0,i.jsxs)(n.div,{slot:"javascript",children:["const a = ce.parse('\\\\frac{1}{10}');\n","const b = ce.parse('\\\\frac{2}{20}');\n","console.log('Canonical isSame?', a.isSame(b));\n","\n","const aPrime = ce.parse('\\\\frac{1}{10}', {canonical: false});\n","const bPrime = ce.parse('\\\\frac{2}{20}', {canonical: false});\n","console.log('Non-canonical isSame?', aPrime.isSame(bPrime));\n"]})}),"\n",(0,i.jsx)(n.p,{children:"In some cases you may want to compare two expressions with a weak form\nof canonicalization, for example to ignore the order of the arguments of a sum."}),"\n",(0,i.jsx)(n.p,{children:"You can achieve this by comparing the expressions in their canonical order:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:"example",children:'ce.box(["CanonicalForm", ["Add", 1, "x"], "Order"]).isSame(\n  ["CanonicalForm", ["Add", "x", 1], "Order"]\n)\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"mathematical-equality-isequal",children:["Mathematical Equality: ",(0,i.jsx)(n.code,{children:"isEqual()"})]}),"\n",(0,i.jsx)(n.p,{children:"It turns out that comparing two arbitrary mathematical expressions is a complex\nproblem."}),"\n",(0,i.jsxs)(n.p,{children:["In fact, ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Richardson%27s_theorem",children:"Richardson's Theorem"}),"\nproves that it is impossible to determine if two symbolic expressions are\nidentical in general."]}),"\n",(0,i.jsx)(n.p,{children:"However, there are many cases where it is possible to make a comparison between\ntwo expressions to check if they represent the same mathematical object."}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"lhs.isEqual(rhs)"})," function return true if ",(0,i.jsx)(n.code,{children:"lhs"})," and ",(0,i.jsx)(n.code,{children:"rhs"})," represent the\nsame mathematical object."]}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"lhs"})," and ",(0,i.jsx)(n.code,{children:"rhs"})," are numeric expressions, they are evaluated before being\ncompared. They are considered equal if the absolute value of the difference\nbetween them is less than ",(0,i.jsx)(n.code,{children:"ce.tolerance"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The expressions \\( x^2 - 3x + 4 \\) and \\( 4 - 3x + x^2 \\) will be considered\nequal (",(0,i.jsx)(n.code,{children:"isEqual"})," returns true) because the difference between them is zero,\ni.e. \\( (x^2 - 3x + 4) - (4 - 3x + x^2) \\) is zero once the expression has\nbeen simplified."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that unlike ",(0,i.jsx)(n.code,{children:"expr.isSame()"}),", ",(0,i.jsx)(n.code,{children:"expr.isEqual()"})," can return ",(0,i.jsx)(n.code,{children:"true"}),", ",(0,i.jsx)(n.code,{children:"false"})," or\n",(0,i.jsx)(n.code,{children:"undefined"}),". The latter value indicates that there is not enough information to\ndetermine if the two expressions are mathematically equal."]}),"\n",(0,i.jsx)(s,{"show-line-numbers":"",children:(0,i.jsxs)(n.div,{slot:"javascript",children:["const a = ce.parse('1 + 2');\n","const b = ce.parse('3');\n","console.log('isEqual?', a.isEqual(b));\n"]})}),"\n",(0,i.jsx)(n.h3,{id:"other-comparisons",children:"Other Comparisons"}),"\n",(0,i.jsx)("div",{children:(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"}}),(0,i.jsx)(n.th,{style:{textAlign:"left"}})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"lhs === rhs"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"If true, same box expression instances"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"lhs.isSame(rhs)"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Structural equality"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"lhs.isEqual(rhs)"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Mathematical equality"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"lhs.match(rhs) !== null"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"Pattern match"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"lhs.is(rhs)"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Synonym for ",(0,i.jsx)(n.code,{children:"lhs.isSame(rhs)"}),", but the argument of ",(0,i.jsx)(n.code,{children:"is()"})," can be a boolean or number."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:'ce.box(["Equal", lhs, rhs]).evaluate()'})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Synonym for ",(0,i.jsx)(n.code,{children:"lhs.isEqual(rhs)"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:'ce.box(["Same", lhs, rhs]).evaluate()'})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:["Synonym for ",(0,i.jsx)(n.code,{children:"lhs.isSame(rhs)"})]})]})]})]})}),"\n",(0,i.jsx)(n.h2,{id:"replacing-a-symbol-in-an-expresssion",children:"Replacing a Symbol in an Expresssion"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To replace a symbol in an expression"})," use the ",(0,i.jsx)(n.code,{children:"subs()"})," function."]}),"\n",(0,i.jsxs)(n.p,{children:["The argument of the ",(0,i.jsx)(n.code,{children:"subs()"})," function is an object literal. Each key/value\npairs is a symbol and the value to be substituted with. The value can be either\na number or a boxed expression."]}),"\n",(0,i.jsx)(s,{"show-line-numbers":"","mark-javascript-line":"4",children:(0,i.jsxs)(n.div,{slot:"javascript",children:["\n","let expr = ce.parse('\\\\sqrt{\\\\frac{1}{x+1}}');\n","console.log(expr.json);\n","\n","expr = expr.subs({x: 3});\n","\n",'console.log("Substitute x -> 3\\n", expr.json);\n','console.log("Numerical Evaluation:", expr.N());\n']})}),"\n",(0,i.jsx)(n.h2,{id:"other-symbolic-manipulation",children:"Other Symbolic Manipulation"}),"\n",(0,i.jsx)(n.p,{children:"There are a number of operations that can be performed on an expression:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"creating an expression from a raw MathJSON expression or from a LaTeX string"}),"\n",(0,i.jsx)(n.li,{children:"simplifying an expression"}),"\n",(0,i.jsx)(n.li,{children:"evaluating an expression"}),"\n",(0,i.jsx)(n.li,{children:"applying a substitution to an expression"}),"\n",(0,i.jsx)(n.li,{children:"applying conditional rewrite rules to an expression"}),"\n",(0,i.jsx)(n.li,{children:"checking if an expression matches a pattern"}),"\n",(0,i.jsx)(n.li,{children:"checking if an expression is a number, a symbol, a function, etc..."}),"\n",(0,i.jsx)(n.li,{children:"checking if an expression is zero, positive, negative, etc..."}),"\n",(0,i.jsx)(n.li,{children:"checking if an expression is an integer, a rational, etc..."}),"\n",(0,i.jsx)(n.li,{children:"and more..."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"We've introduced some of these operations in this guide, but there are many more\nthat are available."}),"\n",(0,i.jsxs)(a,{path:"/compute-engine/guides/expressions/",children:[" Read more about\n",(0,i.jsx)("strong",{children:"Expressions"}),", their properties and methods ",(0,i.jsx)(t,{name:"chevron-right-bold"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"To check if an expression matches a pattern"}),", apply a substitution to some\nelements in an expression or apply conditional rewriting rules to an expression."]}),"\n",(0,i.jsxs)(a,{path:"/compute-engine/guides/patterns-and-rules/",children:[" Read more about\n",(0,i.jsx)("strong",{children:"Patterns and Rules"})," for these operations ",(0,i.jsx)(t,{name:"chevron-right-bold"})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function x(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453(e,n,s){s.d(n,{R:()=>l,x:()=>a});var t=s(6540);const i={},r=t.createContext(i);function l(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);