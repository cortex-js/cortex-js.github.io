"use strict";(self.webpackChunkcortexjs_io=self.webpackChunkcortexjs_io||[]).push([[4437],{7791:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"compute-engine/guide-patterns-and-rules","title":"Patterns and Rules","description":"Recognizing patterns and applying rules is a powerful symbolic computing tool to","source":"@site/docs/compute-engine/15-guide-patterns-and-rules.md","sourceDirName":"compute-engine","slug":"/compute-engine/guides/patterns-and-rules/","permalink":"/compute-engine/guides/patterns-and-rules/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1737956976000,"sidebarPosition":15,"frontMatter":{"title":"Patterns and Rules","slug":"/compute-engine/guides/patterns-and-rules/"},"sidebar":"docSidebar","previous":{"title":"Assumptions","permalink":"/compute-engine/guides/assumptions/"},"next":{"title":"MathJSON Format","permalink":"/math-json/"}}');var t=i(4848),r=i(8453);const d={title:"Patterns and Rules",slug:"/compute-engine/guides/patterns-and-rules/"},a=void 0,l={},o=[{value:"Wildcards",id:"wildcards",level:2},{value:"Patterns",id:"patterns",level:2},{value:"Matching an Expression to a Pattern",id:"matching-an-expression-to-a-pattern",level:2},{value:"Commutativity",id:"commutativity",level:3},{value:"Exact Matching",id:"exact-matching",level:3},{value:"Recursive Matching",id:"recursive-matching",level:3},{value:"Repeated Named Wildcards",id:"repeated-named-wildcards",level:3},{value:"Capturing the Head of Functions",id:"capturing-the-head-of-functions",level:3},{value:"Substitution",id:"substitution",level:2},{value:"Applying Rewrite Rules",id:"applying-rewrite-rules",level:2},{value:"Simplifying an Expression",id:"simplifying-an-expression",level:3},{value:"Substituting Symbols",id:"substituting-symbols",level:3}];function c(e){const n={code:"code","code-playground":"code-playground",div:"div",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},i=n["code-playground"];return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Recognizing patterns and applying rules is a powerful symbolic computing tool to\nidentify and manipulate the structure of expressions."}),"\n",(0,t.jsx)(n.h2,{id:"wildcards",children:"Wildcards"}),"\n",(0,t.jsxs)(n.p,{children:["Wildcard are placeholders identifiers in an expression. They start with a ",(0,t.jsx)(n.code,{children:"_"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:'"_"'})," universal wildcard matches anything that is in the corresponding\nposition in an expression."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:'"__"'})," wildcard matches any sequence of 1 or more expressions in its\ncorresponding position. It is useful to capture the arguments of a function."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:'"___"'})," wildcard matches any sequence of 0 or more expressions in its\ncorresponding position."]}),"\n",(0,t.jsxs)(n.p,{children:["A wildcard symbol may include a name which is used to ",(0,t.jsx)(n.strong,{children:"capture"})," the matching\nexpression, for example ",(0,t.jsx)(n.code,{children:"_a"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["When using a named wildcard, all instances of the named wildcard must match. In contrast, an un-named wildcard\n(a universal wildcard such as ",(0,t.jsx)(n.code,{children:'"_"'})," ",(0,t.jsx)(n.code,{children:'"__"'})," or ",(0,t.jsx)(n.code,{children:'"___"'}),") can be used multiple\ntimes to match different values."]}),"\n",(0,t.jsx)(n.h2,{id:"patterns",children:"Patterns"}),"\n",(0,t.jsx)(n.p,{children:"A pattern is an expression which can include one or more placeholders in the\nform of wildcards."}),"\n",(0,t.jsx)(n.p,{children:"Patterns are similar to Regular Expressions in traditional programming languages\nbut they are tailored to deal with MathJSON expressions instead of strings."}),"\n",(0,t.jsx)(n.p,{children:"Given a pattern and an expression the goal of pattern matching is to find a\nsubstitution for all the wildcards such that the pattern becomes the expression."}),"\n",(0,t.jsxs)(n.p,{children:["An expression is said to match a pattern if there exists a set of values such\nthat replacing the wildcards with those values is equal to the expression.\nThis set of values is called a ",(0,t.jsx)(n.strong,{children:"substitution"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, the pattern ",(0,t.jsx)(n.code,{children:'["Add", 3, "_c"]'})," becomes the expression\n",(0,t.jsx)(n.code,{children:'["Add", 3, "x"]'})," by replacing the wildcard ",(0,t.jsx)(n.code,{children:'"_c"'})," with ",(0,t.jsx)(n.code,{children:'"x"'}),". The substitution\nis therefore ",(0,t.jsx)(n.code,{children:'{_c : "x"}'}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["On the other hand, the expression ",(0,t.jsx)(n.code,{children:'["Divide", "x", 2]'})," does not match the\npattern ",(0,t.jsx)(n.code,{children:'["Add", 3, "_c"]'}),": no substitution exists to transform the pattern\ninto the expression by substituting the wildcards."]}),"\n",(0,t.jsx)(n.h2,{id:"matching-an-expression-to-a-pattern",children:"Matching an Expression to a Pattern"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"To check if an expression matches a pattern"}),", use the\n",(0,t.jsx)(n.code,{children:"_expression_.match(_pattern_)"})," method."]}),"\n",(0,t.jsxs)(n.p,{children:["If there is no match, the method returns ",(0,t.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["If there is a match, a ",(0,t.jsx)(n.code,{children:"Substitution"})," object literal with\nkeys corresponding to the matching named wildcards is returned."]}),"\n",(0,t.jsx)(n.p,{children:"If no named wildcards are used and there is a match, an empty object literal\nis returned."}),"\n",(0,t.jsxs)(n.p,{children:["For convenience, the ",(0,t.jsx)(n.em,{children:"pattern"})," argument can be an unboxed MathJSON expression."]}),"\n",(0,t.jsx)(n.h3,{id:"commutativity",children:"Commutativity"}),"\n",(0,t.jsx)(n.p,{children:"The commutativity of functions is taken into account when matching patterns."}),"\n",(0,t.jsx)(i,{children:(0,t.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,t.jsx)(n.h3,{id:"exact-matching",children:"Exact Matching"}),"\n",(0,t.jsxs)(n.p,{children:["By default, the ",(0,t.jsx)(n.code,{children:"expr.match()"})," method will match some variants of the same\nexpression, for example ",(0,t.jsx)(n.code,{children:"x+_a"})," and ",(0,t.jsx)(n.code,{children:"x"})," are considered to match (with the\nsubstitution ",(0,t.jsx)(n.code,{children:"{_a : 0}"}),")."]}),"\n",(0,t.jsx)(i,{children:(0,t.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"To prevent the matching of variants"}),", set the ",(0,t.jsx)(n.code,{children:"exact"})," property to ",(0,t.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,t.jsx)(i,{children:(0,t.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,t.jsx)(n.p,{children:"The variants can be applied to the whole expression or to sub-expressions."}),"\n",(0,t.jsx)(i,{children:(0,t.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,t.jsx)(n.h3,{id:"recursive-matching",children:"Recursive Matching"}),"\n",(0,t.jsxs)(n.p,{children:["By default, the ",(0,t.jsx)(n.code,{children:"expr.match()"})," method does not consider sub-expressions:\nit is not recursive."]}),"\n",(0,t.jsx)(i,{children:(0,t.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"To match sub-expressions recursively"}),", set the ",(0,t.jsx)(n.code,{children:"recursive"})," property to\n",(0,t.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,t.jsx)(i,{children:(0,t.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,t.jsx)(n.h3,{id:"repeated-named-wildcards",children:"Repeated Named Wildcards"}),"\n",(0,t.jsx)(n.p,{children:"If a named wildcard is referenced multiple times in a pattern, all its values\nmust match."}),"\n",(0,t.jsx)(i,{children:(0,t.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,t.jsx)(n.h3,{id:"capturing-the-head-of-functions",children:"Capturing the Head of Functions"}),"\n",(0,t.jsx)(n.p,{children:"Wildcards can be used to capture the head of functions:"}),"\n",(0,t.jsx)(i,{children:(0,t.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"substitution",children:"Substitution"}),"\n",(0,t.jsxs)(n.p,{children:["The return value of the ",(0,t.jsx)(n.code,{children:"expr.match()"})," function is a ",(0,t.jsx)(n.code,{children:"Substitution"})," object: a\nmapping from wildcards to expressions."]}),"\n",(0,t.jsxs)(n.p,{children:["If there is no match, ",(0,t.jsx)(n.code,{children:"expr.match()"})," returns ",(0,t.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"To apply a substitution to a pattern"}),", and therefore recover the expression\nit was derived from, use the ",(0,t.jsx)(n.code,{children:"subs()"})," function."]}),"\n",(0,t.jsx)(i,{children:(0,t.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"applying-rewrite-rules",children:"Applying Rewrite Rules"}),"\n",(0,t.jsx)(n.p,{children:"A rewrite rule is an object with three properties:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"match"}),": a matching pattern"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"replace"}),": a substitution pattern"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"condition"}),": an optional condition predicate"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"To apply a set of rules to an expression"}),", call the ",(0,t.jsx)(n.code,{children:"expr.replace()"}),"\nfunction."]}),"\n",(0,t.jsx)(n.p,{children:"Each rule in the ruleset is applied to the expression in turn. If a rule\nmatches, the expression is replaced by the substitution pattern of the rule."}),"\n",(0,t.jsx)(i,{children:(0,t.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"expr.replace()"})," function continues applying all the rules in the ruleset\nuntil no rules are applicable."]}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"expr"})," is not canonical, the result of the replace operation is not\ncanonical either."]}),"\n",(0,t.jsx)(n.h3,{id:"simplifying-an-expression",children:"Simplifying an Expression"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"expr.simplify()"})," function applies a collection of built-in rewrite rules."]}),"\n",(0,t.jsxs)(n.p,{children:["You can define your own rules and apply them using ",(0,t.jsx)(n.code,{children:"expr.replace()"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"substituting-symbols",children:"Substituting Symbols"}),"\n",(0,t.jsxs)(n.p,{children:["If a pattern does not contain any named wildcards and only symbols, the\n",(0,t.jsx)(n.code,{children:"expr.subs()"})," function can be used to replace all occurrences of matching symbols."]}),"\n",(0,t.jsx)(i,{children:(0,t.jsxs)(n.div,{slot:"style",children:["\n","      ","math-field {\n","        ","border: 1px solid var(--neutral-400);\n","        ","background: var(--neutral-200);\n","        ","border-radius: 8px;\n","        ","padding: 8px;\n","      ","}\n","undefined\n"]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>a});var s=i(6540);const t={},r=s.createContext(t);function d(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);