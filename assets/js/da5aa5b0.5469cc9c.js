"use strict";(globalThis.webpackChunkcortexjs_io=globalThis.webpackChunkcortexjs_io||[]).push([[568],{3942(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"compute-engine/guide-augmenting","title":"Custom Functions and Symbols","description":"The MathJSON Standard Library is a","source":"@site/docs/compute-engine/06-guide-augmenting.md","sourceDirName":"compute-engine","slug":"/compute-engine/guides/augmenting/","permalink":"/compute-engine/guides/augmenting/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1769648952000,"sidebarPosition":6,"frontMatter":{"title":"Custom Functions and Symbols","slug":"/compute-engine/guides/augmenting/"},"sidebar":"docSidebar","previous":{"title":"Symbols","permalink":"/compute-engine/guides/symbols/"},"next":{"title":"LaTeX Syntax","permalink":"/compute-engine/guides/latex-syntax/"}}');var a=s(4848),r=s(8453);const c={title:"Custom Functions and Symbols",slug:"/compute-engine/guides/augmenting/"},t=void 0,l={},o=[{value:"Introduction",id:"introduction",level:2},{value:"Automatic Declaration",id:"automatic-declaration",level:3},{value:"Declarations are Scoped",id:"declarations-are-scoped",level:3},{value:"Definitions Using LaTeX",id:"definitions-using-latex",level:2},{value:"Explicit Declarations",id:"explicit-declarations",level:2},{value:"Declaring a Symbol",id:"declaring-a-symbol",level:3},{value:"Declaring a Function",id:"declaring-a-function",level:3},{value:"Declaring a Sequence with Subscript Evaluation",id:"declaring-a-sequence-with-subscript-evaluation",level:3},{value:"Declarative Sequence Definitions",id:"declarative-sequence-definitions",level:3},{value:"LaTeX-Based Sequence Definitions",id:"latex-based-sequence-definitions",level:3},{value:"Overloading Functions",id:"overloading-functions",level:2},{value:"Defining Multiple Functions and Symbols",id:"defining-multiple-functions-and-symbols",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components},{Icon:s,ReadMore:i}=n;return s||u("Icon",!0),i||u("ReadMore",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"/compute-engine/standard-library/",children:"MathJSON Standard Library"})," is a\ncollection of definitions for ",(0,a.jsx)(n.strong,{children:"symbols"})," such as ",(0,a.jsx)(n.code,{children:"Pi"}),", ",(0,a.jsx)(n.code,{children:"Add"}),",\n",(0,a.jsx)(n.code,{children:"Sin"}),", ",(0,a.jsx)(n.code,{children:"Power"}),", ",(0,a.jsx)(n.code,{children:"List"}),", etc..."]}),"\n",(0,a.jsx)(n.p,{children:"In this guide we discuss how to augment the MathJSON Standard Library with your\nown symbols."}),"\n",(0,a.jsxs)(i,{path:"/compute-engine/guides/latex-syntax/#customizing-the-latex-dictionary",children:[(0,a.jsxs)(n.p,{children:["You may also be interested in ",(0,a.jsx)(n.strong,{children:"augmenting the LaTeX dictionary"})," which defines\nhow LaTeX is parsed from and serialized to MathJSON."]}),(0,a.jsxs)(n.p,{children:["This is useful if you want to add support for custom LaTeX macros that you'd\nlike to parse to MathJSON. ",(0,a.jsx)(s,{name:"chevron-right-bold"})]})]}),"\n",(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsxs)(n.p,{children:["When a symbol such as ",(0,a.jsx)(n.code,{children:"Pi"})," or ",(0,a.jsx)(n.code,{children:"Sin"})," is encountered in an expression, the\nCompute Engine will look up its definition in the set of known\nsymbols, including the Standard Library."]}),"\n",(0,a.jsx)(n.h3,{id:"automatic-declaration",children:"Automatic Declaration"}),"\n",(0,a.jsx)(n.p,{children:"If a matching definition is found, it will be bound to the symbol and\nused later to evaluate the expression."}),"\n",(0,a.jsxs)(n.p,{children:["If no definition is found, an automatic declaration will be made of the\nsymbol with a type ",(0,a.jsx)(n.code,{children:"unknown"})," or a more specific type if the context allows it."]}),"\n",(0,a.jsx)(i,{path:"/compute-engine/guides/types",children:(0,a.jsxs)(n.p,{children:["Learn more about ",(0,a.jsx)(n.strong,{children:"types"}),".",(0,a.jsx)(s,{name:"chevron-right-bold"})]})}),"\n",(0,a.jsxs)(n.p,{children:["To provide a more explicit definition for the symbol, you can ",(0,a.jsx)(n.a,{href:"#definitions-using-latex",children:"define it\nusing a LaTeX"})," expression, or an ",(0,a.jsx)(n.a,{href:"#explicit-declarations",children:"explicit declaration"})," using the ",(0,a.jsx)(n.code,{children:"ce.declare()"})," method."]}),"\n",(0,a.jsx)(n.h3,{id:"declarations-are-scoped",children:"Declarations are Scoped"}),"\n",(0,a.jsxs)(n.p,{children:["The declaration of a symbol is done within a ",(0,a.jsx)(n.strong,{children:"lexical scope"}),". A scope\nis a hierarchical collection of definitions."]}),"\n",(0,a.jsx)(i,{path:"/compute-engine/guides/evaluate/#lexical-scopes-and-evaluation-contexts",children:(0,a.jsxs)(n.p,{children:["Read more about ",(0,a.jsx)(n.strong,{children:"scopes"})," ",(0,a.jsx)(s,{name:"chevron-right-bold"})]})}),"\n",(0,a.jsx)(n.h2,{id:"definitions-using-latex",children:"Definitions Using LaTeX"}),"\n",(0,a.jsx)(n.p,{children:"The simplest way to define a new symbol is to use LaTeX."}),"\n",(0,a.jsxs)(n.p,{children:["For example, to define a new symbol ",(0,a.jsx)(n.code,{className:"language-math math-inline",children:"m"})," with a value of ",(0,a.jsx)(n.code,{className:"language-math math-inline",children:"42"}),", use the\nfollowing LaTeX expression:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.parse("m := 42").evaluate();\nce.parse("m").value.print();\n// \u2794 42\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Note"}),": the assignment expression must be evaluated to take effect."]}),"\n",(0,a.jsxs)(n.p,{children:["To define a new function ",(0,a.jsx)(n.code,{className:"language-math math-inline",children:"f"})," that multiplies its argument by ",(0,a.jsx)(n.code,{className:"language-math math-inline",children:"2"}),", use\nthe following LaTeX expression:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.parse("f(x) := 2x").evaluate();\nce.parse("f(3)").evaluate().print();\n// \u2794 6\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"\\mapsto"})," operator is an alternative syntax to define a function:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.parse("f := x \\\\mapsto 2x").evaluate();\nce.parse("f(3)").evaluate().print();\n// \u2794 6\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To define multiletter symbols"}),", use the ",(0,a.jsx)(n.code,{children:"\\operatorname{}"})," command:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"ce.parse('\\\\operatorname{double}(x) := 2x').evaluate().print();\nce.parse('\\\\operatorname{double}(3)').evaluate().print();\n// \u2794 6\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Note"}),": you can also use the ",(0,a.jsx)(n.code,{children:"\\mathrm{}"})," or ",(0,a.jsx)(n.code,{children:"\\mathit{}"})," commands to wrap\nmultiletter symbols."]}),"\n",(0,a.jsxs)(n.p,{children:["The LaTeX identifiers are mapped to MathJSON symbols. For example,\nthe LaTeX ",(0,a.jsx)(n.code,{children:"\\operatorname{double}"})," is mapped to the MathJSON symbol ",(0,a.jsx)(n.code,{children:"double"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"console.info(ce.parse('\\\\operatorname{double}(3)').json);\n// \u2794 [\"double\", 3]\n"})}),"\n",(0,a.jsx)(n.h2,{id:"explicit-declarations",children:"Explicit Declarations"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To have more control over the definition of a symbol"})," use\nthe ",(0,a.jsx)(n.code,{children:"ce.declare()"})," method."]}),"\n",(0,a.jsx)(n.p,{children:"When declaring a symbol, you can specify the type of the symbol, its value\nand other properties."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'// Declaring a symbol "m"\nce.declare("m",  "integer");\n\n// Declaring a function "f"\nce.declare("f", {\n  signature: "number -> number",\n  evaluate: ce.parse("x \\\\mapsto 2x"),\n});\n'})}),"\n",(0,a.jsx)(n.h3,{id:"declaring-a-symbol",children:"Declaring a Symbol"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To declare a symbol"})," use the ",(0,a.jsx)(n.code,{children:"ce.declare()"})," method with the name of the\nsymbol as the first argument and a type as the second argument."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("n", "integer");\n'})}),"\n",(0,a.jsxs)(i,{path:"/compute-engine/guides/types",children:["The type specifies the\nvalid values of the symbol. For example, ",(0,a.jsx)(n.code,{children:"boolean"}),", ",(0,a.jsx)(n.code,{children:"integer"}),", ",(0,a.jsx)(n.code,{children:"rational"}),", ",(0,a.jsx)(n.code,{children:"function"}),", ",(0,a.jsx)(n.code,{children:"string"}),", etc. Learn more about ",(0,a.jsx)(n.strong,{children:"types"}),".",(0,a.jsx)(s,{name:"chevron-right-bold"})]}),"\n",(0,a.jsxs)(n.p,{children:["Alternatively, you can provide an object literal with the additional properties\n",(0,a.jsx)(n.code,{children:"value"}),", ",(0,a.jsx)(n.code,{children:"type"}),", ",(0,a.jsx)(n.code,{children:"isConstant"}),", and more."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("m", {\n  type: "integer",\n  value: 42,\n});\n'})}),"\n",(0,a.jsxs)(n.p,{children:["If you do not provide a ",(0,a.jsx)(n.code,{children:"type"})," property for a symbol, the type will be\ninferred from the value of the symbol. If no type and no value are\nprovided, the type of the symbol will be ",(0,a.jsx)(n.code,{children:"unknown"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["As a shorthand, a symbol can be declared by assigning it a value using ",(0,a.jsx)(n.code,{children:"ce.assign()"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.assign("m", 42);\n'})}),"\n",(0,a.jsx)(n.p,{children:"If the symbol was not previously defined, this is equivalent to:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("m", { value: 42 });\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Alternatively, you can set the value of a symbol using the ",(0,a.jsx)(n.code,{children:"value"})," property:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.box("m").value = 42;\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To prevent the value of a symbol from being changed"}),", set the ",(0,a.jsx)(n.code,{children:"isConstant"}),"\nproperty to ",(0,a.jsx)(n.code,{children:"true"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("m_e", {\n  value: 9.1e-31,\n  isConstant: true,\n});\n'})}),"\n",(0,a.jsx)(n.h3,{id:"declaring-a-function",children:"Declaring a Function"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To declare a function"}),", associate an ",(0,a.jsx)(n.code,{children:"evaluate"})," handler, which\nis the body of the function, with a symbol."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("double", { \n  evaluate: ce.parse("x \\\\mapsto 2x") \n});\n'})}),"\n",(0,a.jsx)(n.admonition,{title:"Caution",type:"caution",children:(0,a.jsxs)(n.p,{children:["The first argument of ",(0,a.jsx)(n.code,{children:"declare()"})," is a MathJSON symbol, not a LaTeX command.\nFor example, use ",(0,a.jsx)(n.code,{children:"double"})," instead of ",(0,a.jsx)(n.code,{children:"\\operatorname{double}"}),"."]})}),"\n",(0,a.jsx)(n.p,{children:"The evaluate handler can be either a MathJSON expression as above or\na JavaScript function."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("double", { evaluate: ([x]) => x.mul(2) });\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The signature of the ",(0,a.jsx)(n.code,{children:"evaluate"})," handler is ",(0,a.jsx)(n.code,{children:"(args[], options)"}),", where:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"args"}),": an array of the arguments that have been applied to the function. Each\nargument is a boxed expression. The array may be empty if there are no\narguments."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"options"}),": an object literal which includes an ",(0,a.jsx)(n.code,{children:"engine"})," property that is the\nCompute Engine instance that is evaluating the expression and a ",(0,a.jsx)(n.code,{children:"numericApproximation"})," property that is true if the result should be a numeric approximation."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Since ",(0,a.jsx)(n.code,{children:"args"})," is an array, you can use destructuring to get the arguments:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("double", { evaluate: (args) => args[0].mul(2) });\n\n// or\nce.declare("double", { evaluate: ([x]) => x.mul(2) });\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In addition to the ",(0,a.jsx)(n.code,{children:"evaluate"})," handler the function definition can include\na ",(0,a.jsx)(n.code,{children:"signature"})," type that describes the arguments and return value of the\nfunction."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("double", {\n  signature: "number -> number",\n  evaluate: ([x]) => x.mul(2),\n});\n'})}),"\n",(0,a.jsxs)(n.p,{children:["See ",(0,a.jsx)(n.code,{children:"FunctionDefinition"})," for more details on the other handlers and\nproperties that can be provided when defining a function."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To define a function without specifying a body for it"}),", specify\nthe signature of the function as the second argument of ",(0,a.jsx)(n.code,{children:"ce.declare()"})," or\nuse the ",(0,a.jsx)(n.code,{children:'"function"'})," type."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare("double", "function");\n'})}),"\n",(0,a.jsx)(n.p,{children:"Functions that do not have an evaluate handler or a function literal as a\nvalue remain unchanged when evaluated."}),"\n",(0,a.jsxs)(n.p,{children:["You can set the body of the function later using ",(0,a.jsx)(n.code,{children:"ce.assign()"}),":"]}),"\n",(0,a.jsxs)(n.p,{children:["When using ",(0,a.jsx)(n.code,{children:"ce.assign()"})," to define a function, the value can be a JavaScript\nfunction, a MathJSON expression or a LaTeX expression."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.assign("double", ([x]) => x.mul(2));\n\nce.assign("double", ["Function", ["Multiply", "x", 2], "x"]);\n\nce.assign("double",ce.parse("x \\\\mapsto 2x"));\n'})}),"\n",(0,a.jsx)(i,{path:"/compute-engine/reference/functions/",children:(0,a.jsxs)(n.p,{children:["Learn more about the standard operator to manipulate ",(0,a.jsx)(n.strong,{children:"functions"}),". ",(0,a.jsx)(s,{name:"chevron-right-bold"})]})}),"\n",(0,a.jsx)(n.h3,{id:"declaring-a-sequence-with-subscript-evaluation",children:"Declaring a Sequence with Subscript Evaluation"}),"\n",(0,a.jsxs)(n.p,{children:["Mathematical sequences like Fibonacci numbers (",(0,a.jsx)(n.code,{className:"language-math math-inline",children:"F_n"}),"), indexed coefficients\n(",(0,a.jsx)(n.code,{className:"language-math math-inline",children:"a_n"}),"), or matrix elements (",(0,a.jsx)(n.code,{className:"language-math math-inline",children:"M_{i,j}"}),") are commonly written using subscript\nnotation. You can define custom evaluation logic for subscripted symbols using\nthe ",(0,a.jsx)(n.code,{children:"subscriptEvaluate"})," handler."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'// Define a sequence of squares: S_n = n\xb2\nce.declare("S", {\n  subscriptEvaluate: (subscript, { engine }) => {\n    const n = subscript.re;\n    if (!Number.isInteger(n) || n < 0) return undefined;\n    return engine.number(n * n);\n  },\n});\n\nce.parse("S_{5}").evaluate();   // \u2192 25\nce.parse("S_3").evaluate();     // \u2192 9\nce.parse("S_n").evaluate();     // \u2192 stays as Subscript(S, n)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"subscriptEvaluate"})," handler receives:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"subscript"}),": the subscript expression (already evaluated)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"options"}),": an object with ",(0,a.jsx)(n.code,{children:"engine"})," (the ComputeEngine) and ",(0,a.jsx)(n.code,{children:"numericApproximation"}),"\n(true when called from ",(0,a.jsx)(n.code,{children:".N()"}),")"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["Return ",(0,a.jsx)(n.code,{children:"undefined"})]})," to keep the expression symbolic. This is useful when the\nsubscript contains unknowns or is outside the valid range."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'// Fibonacci sequence with memoization\nconst fibMemo = new Map();\nconst fib = (n) => {\n  if (n <= 1) return n;\n  if (fibMemo.has(n)) return fibMemo.get(n);\n  const result = fib(n - 1) + fib(n - 2);\n  fibMemo.set(n, result);\n  return result;\n};\n\nce.declare("F", {\n  subscriptEvaluate: (subscript, { engine }) => {\n    const n = subscript.re;\n    if (!Number.isInteger(n) || n < 0) return undefined;\n    return engine.number(fib(n));\n  },\n});\n\nce.parse("F_{10}").evaluate();  // \u2192 55\nce.parse("F_n").evaluate();     // \u2192 Subscript(F, n) - stays symbolic\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Multi-index subscripts"})," (like matrix elements) receive the subscript as a\n",(0,a.jsx)(n.code,{children:"Tuple"})," expression:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'const matrix = [[1,2,3], [4,5,6], [7,8,9]];\n\nce.declare("M", {\n  subscriptEvaluate: (subscript, { engine }) => {\n    if (subscript.operator === "Tuple" && subscript.ops) {\n      const [i, j] = subscript.ops;\n      const row = matrix[i.re - 1];  // 1-indexed\n      if (row && row[j.re - 1] !== undefined) {\n        return engine.number(row[j.re - 1]);\n      }\n    }\n    return undefined;\n  },\n});\n\nce.parse("M_{2,3}").evaluate();  // \u2192 6\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Subscripted expressions with ",(0,a.jsx)(n.code,{children:"subscriptEvaluate"})," have type ",(0,a.jsx)(n.code,{children:"number"})," and can be\nused in arithmetic:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.parse("S_{5} + S_{3}").evaluate();  // \u2192 34 (25 + 9)\nce.parse("2 * F_{10}").evaluate();     // \u2192 110 (2 \xd7 55)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"declarative-sequence-definitions",children:"Declarative Sequence Definitions"}),"\n",(0,a.jsxs)(n.p,{children:["For common mathematical sequences defined by recurrence relations, the\n",(0,a.jsx)(n.code,{children:"declareSequence()"})," method provides a simpler declarative API:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Fibonacci sequence: F_n = F_{n-1} + F_{n-2}, with F_0 = 0, F_1 = 1\nce.declareSequence('F', {\n  base: { 0: 0, 1: 1 },\n  recurrence: 'F_{n-1} + F_{n-2}',\n});\n\nce.parse('F_{10}').evaluate();  // \u2192 55\nce.parse('F_{20}').evaluate();  // \u2192 6765\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"SequenceDefinition"})," object accepts:"]}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Property"}),(0,a.jsx)(n.th,{children:"Type"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"base"})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"Record<number, number | BoxedExpression>"})}),(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.strong,{children:"Required."})," Base cases as index \u2192 value mapping"]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"recurrence"})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"string | BoxedExpression"})}),(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.strong,{children:"Required."})," Recurrence relation (LaTeX string or expression)"]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"variable"})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"string"})}),(0,a.jsxs)(n.td,{children:["Index variable name (default: ",(0,a.jsx)(n.code,{children:"'n'"}),")"]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"memoize"})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"boolean"})}),(0,a.jsxs)(n.td,{children:["Cache computed values (default: ",(0,a.jsx)(n.code,{children:"true"}),")"]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"domain"})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"{ min?: number, max?: number }"})}),(0,a.jsx)(n.td,{children:"Valid index range"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Arithmetic sequence: a_n = a_{n-1} + 2\nce.declareSequence('A', {\n  base: { 0: 1 },\n  recurrence: 'A_{n-1} + 2',\n});\nce.parse('A_{5}').evaluate();  // \u2192 11\n\n// Factorial via recurrence: n! = n \xd7 (n-1)!\nce.declareSequence('H', {\n  base: { 0: 1 },\n  recurrence: 'n \\\\cdot H_{n-1}',\n});\nce.parse('H_{5}').evaluate();  // \u2192 120\n\n// Triangular numbers: T_n = T_{n-1} + n\nce.declareSequence('T', {\n  base: { 0: 0 },\n  recurrence: 'T_{n-1} + n',\n});\nce.parse('T_{5}').evaluate();  // \u2192 15\n\n// Using a custom index variable\nce.declareSequence('W', {\n  variable: 'k',\n  base: { 0: 1 },\n  recurrence: 'W_{k-1} + k',\n});\nce.parse('W_{5}').evaluate();  // \u2192 16\n\n// With domain constraints (only valid for n \u2265 1)\nce.declareSequence('X', {\n  base: { 1: 1 },\n  recurrence: 'X_{n-1} + 1',\n  domain: { min: 1 },\n});\nce.parse('X_{5}').evaluate();  // \u2192 5\nce.parse('X_{0}').evaluate();  // \u2192 stays symbolic (outside domain)\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Symbolic behavior:"})," When the subscript is symbolic or non-integer, the\nexpression stays symbolic:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"ce.parse('F_k').evaluate();     // \u2192 Subscript(F, k) - stays symbolic\nce.parse('F_{1.5}').evaluate(); // \u2192 Subscript(F, 1.5) - stays symbolic\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Memoization:"})," By default, computed values are cached for efficiency. This is\nespecially important for sequences like Fibonacci that have exponential\ncomplexity without memoization:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Fast even for large indices thanks to memoization\nce.parse('F_{30}').evaluate();  // \u2192 832040 (computed quickly)\n"})}),"\n",(0,a.jsx)(n.p,{children:"To disable memoization (e.g., for memory-constrained environments):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"ce.declareSequence('O', {\n  base: { 0: 1 },\n  recurrence: 'O_{n-1} + 1',\n  memoize: false,\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"latex-based-sequence-definitions",children:"LaTeX-Based Sequence Definitions"}),"\n",(0,a.jsx)(n.p,{children:"Sequences can also be defined using natural LaTeX assignment notation. This is\nespecially useful in interactive environments or when working with mathematical\nnotation directly:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Arithmetic sequence via LaTeX\nce.parse('L_0 := 1').evaluate();\nce.parse('L_n := L_{n-1} + 2').evaluate();\nce.parse('L_{5}').evaluate();  // \u2192 11\n\n// Fibonacci via LaTeX\nce.parse('F_0 := 0').evaluate();\nce.parse('F_1 := 1').evaluate();\nce.parse('F_n := F_{n-1} + F_{n-2}').evaluate();\nce.parse('F_{10}').evaluate();  // \u2192 55\n\n// Factorial via LaTeX\nce.parse('D_0 := 1').evaluate();\nce.parse('D_n := n \\\\cdot D_{n-1}').evaluate();\nce.parse('D_{5}').evaluate();  // \u2192 120\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Order independence:"})," Base cases and recurrence can be defined in any order.\nThe sequence is finalized when both a base case and a recurrence relation are\npresent:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Recurrence first, then base case\nce.parse('K_n := K_{n-1} + 1').evaluate();\nce.parse('K_0 := 0').evaluate();  // Sequence finalized here\nce.parse('K_{5}').evaluate();  // \u2192 5\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"How it works:"})," The system detects sequence definitions by checking if the\nright-hand side contains self-references (like ",(0,a.jsx)(n.code,{children:"L_{n-1}"})," when defining ",(0,a.jsx)(n.code,{children:"L_n"}),").\nAssignments without self-references are treated as function definitions instead:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// This defines a function f(x) = x\xb2, not a sequence\nce.parse('f_x := x^2').evaluate();\nce.parse('f_{3}').evaluate();  // \u2192 9\n"})}),"\n",(0,a.jsx)(n.h2,{id:"overloading-functions",children:"Overloading Functions"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Overloading"})," is the ability to define multiple functions with the same name."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To overload a function"}),", use the ",(0,a.jsx)(n.code,{children:"ce.declare()"})," methods."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, to overload the ",(0,a.jsx)(n.code,{children:"Sqrt"})," function to return ",(0,a.jsx)(n.code,{children:"NaN"})," for\nnon-real numbers, use the following code:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const originalSqrtDefinition = ce.box('Sqrt').operatorDefinition!;\nce.declare('Sqrt', {\n  ...originalSqrtDefinition,\n  evaluate: (x, options) => {\n    const y = originalSqrtDefinition.evaluate!(x, options);\n    return y?.isReal ? y : ce.NaN;\n  },\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In general, re-declaring a function in the same scope is not allowed and\nwill throw an error. However, the standard functions are in a ",(0,a.jsx)(n.code,{children:"system"})," scope\nso a new declaration in the ",(0,a.jsx)(n.code,{children:"global"})," scope or a child scope will\noverride the original declaration."]}),"\n",(0,a.jsx)(n.h2,{id:"defining-multiple-functions-and-symbols",children:"Defining Multiple Functions and Symbols"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To define multiple functions and symbols"}),", use the ",(0,a.jsx)(n.code,{children:"ce.declare()"})," method\nwith a dictionary of definitions."]}),"\n",(0,a.jsx)(n.admonition,{title:"Note",type:"info",children:(0,a.jsxs)(n.p,{children:["The keys to ",(0,a.jsx)(n.code,{children:"ce.declare()"})," (",(0,a.jsx)(n.code,{children:"m"}),", ",(0,a.jsx)(n.code,{children:"f"}),", etc...) are MathJSON\nsymbols, not LaTeX commands. For example, if you have a symbol ",(0,a.jsx)(n.code,{children:"\u03b1"}),", use\n",(0,a.jsx)(n.code,{children:"alpha"}),", not ",(0,a.jsx)(n.code,{children:"\\alpha"})]})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.declare({\n  m: { type: "number", value: 5 },\n  f: { type: "function" },\n  g: { type: "function" },\n  Smallfrac: {\n    signature: "(number, number) -> number",\n    evaluate: ([x,y]) => x.div(y),\n  },\n});\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"To assign multiple functions and symbols"}),", use the ",(0,a.jsx)(n.code,{children:"ce.assign()"})," method with\na dictionary of values."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'ce.assign({\n  "m": 10,\n  "f": ce.parse("x \\\\mapsto x^2 + x + 41"),\n  "g": ce.parse("t \\\\mapsto t^3 + t^2 + 17"),\n});\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453(e,n,s){s.d(n,{R:()=>c,x:()=>t});var i=s(6540);const a={},r=i.createContext(a);function c(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);