"use strict";(self.webpackChunkcortexjs_io=self.webpackChunkcortexjs_io||[]).push([[7649],{6421:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"compute-engine/reference-core","title":"Core","description":"The functions described in this section are part of the core of the Compute","source":"@site/docs/compute-engine/85-reference-core.md","sourceDirName":"compute-engine","slug":"/compute-engine/reference/core/","permalink":"/compute-engine/reference/core/","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1750373564000,"sidebarPosition":85,"frontMatter":{"title":"Core","slug":"/compute-engine/reference/core/"},"sidebar":"docSidebar","previous":{"title":"Control Structures","permalink":"/compute-engine/reference/control-structures/"},"next":{"title":"Functions","permalink":"/compute-engine/reference/functions/"}}');var r=s(4848),l=s(8453);const a={title:"Core",slug:"/compute-engine/reference/core/"},t=void 0,d={},c=[{value:"Constants",id:"constants",level:2},{value:"Declaring, Assigning and Assuming",id:"declaring-assigning-and-assuming",level:2},{value:"Declare",id:"declare",level:3},{value:"Assign",id:"assign",level:3},{value:"Assume",id:"assume",level:3},{value:"Structural Operations",id:"structural-operations",level:2},{value:"About",id:"about",level:3},{value:"Head",id:"head",level:3},{value:"Tail",id:"tail",level:3},{value:"Hold",id:"hold",level:3},{value:"Identity",id:"identity",level:3},{value:"Inspecting an Expression",id:"inspecting-an-expression",level:2},{value:"Domain",id:"domain",level:3},{value:"IsSame",id:"issame",level:3},{value:"Transforming an Expression",id:"transforming-an-expression",level:2},{value:"Evaluate",id:"evaluate",level:3},{value:"Expand",id:"expand",level:3},{value:"ExpandAll",id:"expandall",level:3},{value:"Factor",id:"factor",level:3},{value:"Together",id:"together",level:3},{value:"Simplify",id:"simplify",level:3},{value:"CanonicalForm",id:"canonicalform",level:3},{value:"N",id:"n",level:3},{value:"Core Functions",id:"core-functions",level:2},{value:"Error",id:"error",level:3},{value:"InverseFunction",id:"inversefunction",level:3},{value:"String",id:"string",level:3},{value:"Symbol",id:"symbol",level:3},{value:"Parsing and Serializing Latex",id:"parsing-and-serializing-latex",level:2},{value:"Parse",id:"parse",level:3},{value:"Latex",id:"latex",level:3},{value:"LatexString",id:"latexstring",level:3},{value:"Superscripts and Subscripts",id:"superscripts-and-subscripts",level:2}];function o(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components},{FunctionDefinition:s,Intro:i,Latex:a,ReadMore:t,Signature:d}=n;return s||x("FunctionDefinition",!0),i||x("Intro",!0),a||x("Latex",!0),t||x("ReadMore",!0),d||x("Signature",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i,{children:(0,r.jsxs)(n.p,{children:["The functions described in this section are part of the ",(0,r.jsx)(n.strong,{children:"core"})," of the Compute\nEngine."]})}),"\n",(0,r.jsx)(n.h2,{id:"constants",children:"Constants"}),"\n",(0,r.jsxs)(n.p,{children:["The symbols below are ",(0,r.jsx)(n.strong,{children:"inert constants"}),". They are used as tags and have no\nvalue other than themselves."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{style:{textAlign:"left"},children:"Symbol"}),(0,r.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"All"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:"All the possible values apply"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"None"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:"None of the possible values apply"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"Nothing"})}),(0,r.jsxs)(n.td,{style:{textAlign:"left"},children:["An ",(0,r.jsx)(n.strong,{children:"optional"})," expression is not present. Used in sparse list to indicate skipped elements."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"Undefined"})}),(0,r.jsxs)(n.td,{style:{textAlign:"left"},children:["The result is not defined.",(0,r.jsx)("br",{}),"Note that for numbers, the equivalent is ",(0,r.jsx)(n.code,{children:"NaN"})," (Not a Number)"]})]})]})]}),"\n",(0,r.jsx)(a,{value:"\\lbrack 2, ,3 \\rbrack "}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["List", 2, "Nothing", 3]\n'})}),"\n",(0,r.jsx)(n.h2,{id:"declaring-assigning-and-assuming",children:"Declaring, Assigning and Assuming"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:'["Declare"]'})," expression is used to declare a symbol in the current scope."]}),"\n",(0,r.jsxs)(n.p,{children:["Once a symbol has been declared, its value can be changed using an\n",(0,r.jsx)(n.code,{children:'["Assign"]'})," expression."]}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.code,{children:'["Assume"]'})," expression is used to assert a predicate about an expression. It is\nused to provide additional information to the system, for example to indicate\nthat a variable is positive."]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"declare",children:"Declare"})}),"\n",(0,r.jsxs)(s,{name:"Declare",children:[(0,r.jsxs)(d,{name:"Declare",children:[(0,r.jsx)(n.em,{children:"symbol"}),", ",(0,r.jsx)(n.em,{children:"type"}),"_"]}),(0,r.jsxs)(d,{name:"Declare",children:[(0,r.jsx)(n.em,{children:"symbol"}),", ",(0,r.jsx)(n.em,{children:"type"}),", ",(0,r.jsx)(n.em,{children:"value"})]}),(0,r.jsx)(n.p,{children:"Declare a new symbol in the current scope, and set its value and type."}),(0,r.jsxs)(n.p,{children:["If the symbol already has a definition in the current scope, evaluate to an\nerror, otherwise evaluate to ",(0,r.jsx)(n.code,{children:"value"}),"."]}),(0,r.jsxs)(n.p,{children:["This is equivalent to ",(0,r.jsx)(n.code,{children:"let"})," in JavaScript or ",(0,r.jsx)(n.code,{children:"var"})," in Python."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"To change the value of an existing symbol"}),", use an ",(0,r.jsx)(n.code,{children:'["Assign"]'}),"\nexpression."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Declare"})," is not a ",(0,r.jsx)(n.a,{href:"/compute-engine/guides/expressions#pure-expressions",children:"pure function"}),"\nsince it changes the state of the Compute Engine."]}),(0,r.jsxs)(t,{path:"/compute-engine/guides/augmenting/",children:["Read more about using\n",(0,r.jsx)(n.code,{children:"ce.declare()"})," to declare a new symbol. "]})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"assign",children:"Assign"})}),"\n",(0,r.jsxs)(s,{name:"Assign",children:[(0,r.jsxs)(d,{name:"Assign",children:[(0,r.jsx)(n.em,{children:"symbol"}),", ",(0,r.jsx)(n.em,{children:"value"})]}),(0,r.jsxs)(n.p,{children:["Set the value of ",(0,r.jsx)(n.code,{children:"symbol"})," to ",(0,r.jsx)(n.code,{children:"value"}),"."]}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"symbol"})," has not been declared in the current scope, consider parent\nscopes until a definition for the symbol is found."]}),(0,r.jsxs)(n.p,{children:["If a definition is found, change the value of the symbol to ",(0,r.jsx)(n.code,{children:"value"})," if the\nvalue is compatible with the type of the symbol: once set, the type of\na symbol cannot be changed."]}),(0,r.jsxs)(n.p,{children:["If there is no definition for the symbol, add a new definition in the\ncurrent scope, and use the ",(0,r.jsx)(n.code,{children:"value"})," to infer the type of the symbol."]}),(0,r.jsxs)(n.p,{children:["This is equivalent to ",(0,r.jsx)(n.code,{children:"="})," in may programming languages."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Assign"})," is not a ",(0,r.jsx)(n.a,{href:"/compute-engine/guides/expressions#pure-expressions",children:"pure function"}),"."]}),(0,r.jsxs)(t,{path:"/compute-engine/guides/augmenting/",children:["Read more about using\n",(0,r.jsx)(n.code,{children:"Assign"})," to change the value of a symbol or function. "]})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"assume",children:"Assume"})}),"\n",(0,r.jsxs)(s,{name:"Assume",children:[(0,r.jsx)(d,{name:"Assume",children:(0,r.jsx)(n.em,{children:"predicate"})}),(0,r.jsxs)(n.p,{children:["The predicate is an expression that evaluates to ",(0,r.jsx)(n.code,{children:"True"})," or ",(0,r.jsx)(n.code,{children:"False"}),"."]}),(0,r.jsx)(n.p,{children:"The symbols in the predicate expression may be free, i.e. they may not have\nbeen declared yet. Asserting an assumption does not declare the symbols in\nthe predicate."}),(0,r.jsx)(n.p,{children:"The predicate can take the form of:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["an equality: ",(0,r.jsx)(n.code,{children:'["Assume", ["Equal", "x", 3]]'})]}),"\n",(0,r.jsxs)(n.li,{children:["an inequality: ",(0,r.jsx)(n.code,{children:'["Assume", ["Greater", "x", 0]]'})]}),"\n",(0,r.jsxs)(n.li,{children:["a membership expression: ",(0,r.jsx)(n.code,{children:'["Assume", ["Element", "x", "Integers"]]'})]}),"\n"]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Assign"})," is not a ",(0,r.jsx)(n.a,{href:"/compute-engine/guides/expressions#pure-expressions",children:"pure function"}),"\nsince it changes the state of the Compute Engine."]})]}),"\n",(0,r.jsx)(n.h2,{id:"structural-operations",children:"Structural Operations"}),"\n",(0,r.jsx)(n.p,{children:"The following functions can be applied to non-canonical expressions.\nThe do not depend on the canonical form, but reflect the structure of the\nexpression."}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"about",children:"About"})}),"\n",(0,r.jsxs)(s,{name:"About",children:[(0,r.jsxs)(d,{name:"About",children:[(0,r.jsx)(n.em,{children:"symbol"}),"_"]}),(0,r.jsx)(n.p,{children:"Evaluate to a dictionary expression containing information about a symbol\nsuch as its type, its attributes, its value, etc..."})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"head",children:"Head"})}),"\n",(0,r.jsxs)(s,{name:"Head",children:[(0,r.jsx)(d,{name:"Head",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsxs)(n.p,{children:["Evaluate to the head of ",(0,r.jsx)(n.em,{children:"expression"})]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["Head", ["Add", 2, 3]]\n\n// \u2794 "Add"\n'})})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"tail",children:"Tail"})}),"\n",(0,r.jsxs)(s,{name:"Tail",children:[(0,r.jsx)(d,{name:"Tail",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsxs)(n.p,{children:["Evaluate to a sequence of the arguments of ",(0,r.jsx)(n.em,{children:"expression"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["Tail", ["Add", 2, 3]]\n// \u2794 ["Sequence", 2, 3]\n'})}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Tail"})," can be used to change the head of an expression, for example:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["Multiply", ["Tail", ["Add", 2, 3]]]\n// \u2794 ["Multiply", 2, 3]\n'})})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"hold",children:"Hold"})}),"\n",(0,r.jsxs)(s,{name:"Hold",children:[(0,r.jsx)(d,{name:"Hold",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsx)(n.p,{children:"Tag an expression that should be kept in an unevaluated form"})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"identity",children:"Identity"})}),"\n",(0,r.jsxs)(s,{name:"Identity",children:[(0,r.jsx)(d,{name:"Identity",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsx)(n.p,{children:"Evaluate to its argument"}),(0,r.jsx)(n.p,{children:"In the mathematical sense, this is an operator (a function that takes a function\nas an argument and returns a function)."})]}),"\n",(0,r.jsx)(n.h2,{id:"inspecting-an-expression",children:"Inspecting an Expression"}),"\n",(0,r.jsx)(n.p,{children:"The following functions can be used to obtain information about an expression."}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"domain",children:"Domain"})}),"\n",(0,r.jsxs)(s,{name:"Domain",children:[(0,r.jsx)(d,{name:"Domain",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsxs)(n.p,{children:["Evaluate to the domain of ",(0,r.jsx)(n.em,{children:"expression"})]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["Domain", 2.4531]\n\n// \u2794 "RealNumbers"\n'})})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"issame",children:"IsSame"})}),"\n",(0,r.jsxs)(s,{name:"IsSame",children:[(0,r.jsxs)(d,{name:"IsSame",children:[(0,r.jsx)(n.em,{children:"expression1"}),", ",(0,r.jsx)(n.em,{children:"expression2"})]}),(0,r.jsxs)(n.p,{children:["Evaluate to ",(0,r.jsx)(n.code,{children:"True"})," if the two expressions are structurally identical, otherwise\nevaluate to ",(0,r.jsx)(n.code,{children:"False"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["IsSame", ["Add", 2, 3], ["Add", 2, 3]]\n// \u2794 True\n'})}),(0,r.jsxs)(n.p,{children:["To compare two expressions for mathematical equality, use ",(0,r.jsx)(n.code,{children:"Equal"}),"."]}),(0,r.jsxs)(n.p,{children:["To compare two expressions structurally, but ignoring the order of the arguments\nof commutative functions, use ",(0,r.jsx)(n.a,{href:"#CanonicalForm",children:(0,r.jsx)(n.code,{children:"CanonicalForm"})}),"."]}),(0,r.jsxs)(n.p,{children:["See ",(0,r.jsx)(n.a,{href:"/compute-engine/guides/symbolic-computing/#comparing-expressions",children:"Comparing Expressions"})," for other options to compare two expressions, such\nas the ",(0,r.jsx)(n.code,{children:"Equal"})," function."]})]}),"\n",(0,r.jsx)(n.h2,{id:"transforming-an-expression",children:"Transforming an Expression"}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"evaluate",children:"Evaluate"})}),"\n",(0,r.jsxs)(s,{name:"Evaluate",children:[(0,r.jsx)(d,{name:"Evaluate",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsxs)(n.p,{children:["Apply a sequence of definitions to an expression in order to reduce, simplify\nand calculate its value. Overrides ",(0,r.jsx)(n.code,{children:"Hold"})," and hold attributes of a function."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Evaluate"})," only performs ",(0,r.jsx)(n.strong,{children:"exact"})," calculations. To perform numerical\napproximations, use ",(0,r.jsx)(n.code,{children:"N"}),"."]}),(0,r.jsxs)(n.p,{children:["Read more about ",(0,r.jsx)(n.a,{href:"/compute-engine/guides/numeric-evaluation/",children:"exact calculations and approximate calculations"}),"."]})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"expand",children:"Expand"})}),"\n",(0,r.jsxs)(s,{name:"Expand",children:[(0,r.jsx)(d,{name:"Expand",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsx)(n.p,{children:"Apply the distributive law if the expression is a product or power of sums."}),(0,r.jsxs)(n.p,{children:["For example: ",(0,r.jsx)(n.code,{children:"a(b + c) = ab + ac"})]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Expand the terms of the expression if it is a sum or negate."}),"\n",(0,r.jsx)(n.li,{children:"If the expression is a fraction, expand the numerator."}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["Expand", ["Power", ["Add", "x", 1], 2]]\n// \u2794 ["Add", 1, ["Multiply", 2, "x"], ["Power", "x", 2]]\n'})})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"expandall",children:"ExpandAll"})}),"\n",(0,r.jsxs)(s,{name:"ExpandAll",children:[(0,r.jsx)(d,{name:"ExpandAll",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsx)(n.p,{children:"Expand an expression, recursively."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["ExpandAll", ["Power", ["Multiply", ["Add", "x", 1], 3], 2]]\n// \u2794 ["Add", 1, ["Multiply", 6, "x"], ["Multiply", 6, ["Power", "x", 2]], ["Power", "x", 3]]\n'})})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"factor",children:"Factor"})}),"\n",(0,r.jsxs)(s,{name:"Factor",children:[(0,r.jsx)(d,{name:"Factor",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsx)(n.p,{children:"Factor an expression."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["Factor", ["Add", ["Multiply", 2, "x"], ["Multiply", 2, "y"]]]\n// \u2794 ["Multiply", 2, ["Add", "x", "y"]]\n'})})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"together",children:"Together"})}),"\n",(0,r.jsxs)(s,{name:"Together",children:[(0,r.jsx)(d,{name:"Together",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsx)(n.p,{children:"Combine the terms of a sum of fractions into a single fraction."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["Together", ["Add", ["Divide", 1, 2], ["Divide", 1, 3]]]\n// \u2794 ["Divide", 5, 6]\n'})})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"simplify",children:"Simplify"})}),"\n",(0,r.jsxs)(s,{name:"Simplify",children:[(0,r.jsx)(d,{name:"Simplify",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Simplify"})," function applies a sequence of transformations to an expression\nin order to reduce, simplify and calculate its value."]})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"canonicalform",children:"CanonicalForm"})}),"\n",(0,r.jsxs)(s,{name:"CanonicalForm",children:[(0,r.jsx)(d,{name:"CanonicalForm",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsxs)(d,{name:"CanonicalForm",children:[(0,r.jsx)(n.em,{children:"expression"}),", ",(0,r.jsx)(n.em,{children:"form-1"}),", ",(0,r.jsx)(n.em,{children:"form-2"}),", ..."]}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.em,{children:"expression"})," is already canonical, this function has no effect."]}),(0,r.jsxs)(n.p,{children:["If there are no ",(0,r.jsx)(n.em,{children:"form-n"})," arguments, the expression is transformed to its\ncanonical form."]}),(0,r.jsxs)(n.p,{children:["If some ",(0,r.jsx)(n.em,{children:"form-n"})," arguments are provided, they indicate one or more\ncanonical transformations to apply to the expression. The following\ncanonical forms are supported:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"Order"})}),": If ",(0,r.jsx)(n.em,{children:"expression"})," is a commutative function, sort the\narguments according to the canonical order of the arguments of the function."]}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["CanonicalForm", ["Add", 3, 2, 1], "Order"]\n// -> ["Add", 1, 2, 3]\n'})}),(0,r.jsx)(n.p,{children:"This can be useful to compare two non-canonical expressions for equality, for example:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["IsSame",\n  ["Add", 1, "x"], \n  ["Add", "x", 1]\n]\n// -> False\n\n["IsSame", \n  ["CanonicalForm", ["Add", 1, "x"], "Order"], \n  ["CanonicalForm", ["Add", "x", 1], "Order"]\n]\n// -> True\n'})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"Flatten"})}),": Simplify associative expressions, remove any\nunnecessary delimiters indicating the order of operations,\nflattens any ",(0,r.jsx)(n.code,{children:"Sequence"})," expressions."]}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["CanonicalForm", ["Add", 1, ["Add", 2, 3]], "Flatten"]\n// -> ["Add", 1, 2, 3]\n\n["CanonicalForm", ["Add", 1, ["Delimiter", ["Sequence", 2, 3]]], "Flatten"] \n// -> ["Add", 1, 2, 3]\n\n["CanonicalForm", ["Add", 1, ["Sequence", 2, 3]], "Flatten"]\n// -> ["Add", 1, 2, 3]\n'})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"Number"})}),": Transform some number forms, for example ",(0,r.jsx)(n.code,{children:'["Add", 2, ["Multiply", 3, "ImaginaryI"]]'}),"\nto ",(0,r.jsx)(n.code,{children:'["Complex", 2, 3]'}),", simplify and normalize numerator and denominator of\nrational numbers, etc..."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"InvisibleOperator"})}),": Remove any invisible operators that may be\ncontained in the expression and replace them with ",(0,r.jsx)(n.code,{children:"Multiply"})," or function\napplication, depending on the context"]}),"\n"]}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["CanonicalForm", ["InvisibleOperator", "2", "x"], "InvisibleOperator"]\n// -> ["Multiply", 2, "x"]\n'})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"Multiply"})}),": If ",(0,r.jsx)(n.em,{children:"expression"})," is a ",(0,r.jsx)(n.code,{children:"Multiply"})," function, simplify it by\ncombining the coefficients and the factors, transform product to a ",(0,r.jsx)(n.code,{children:"Power"}),"\nexpression when possible."]}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["CanonicalForm", ["Multiply", 2, 3, "x"], "Multiply"]\n// -> ["Multiply", 6, "x"]\n'})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"Add"})}),": If ",(0,r.jsx)(n.em,{children:"expression"})," is an ",(0,r.jsx)(n.code,{children:"Add"})," function, remove any ",(0,r.jsx)(n.code,{children:"0"}),", transform\nsum into multiplication when possible. If ",(0,r.jsx)(n.em,{children:"expression"})," is a ",(0,r.jsx)(n.code,{children:"Subtract"}),"\ntransform it into an ",(0,r.jsx)(n.code,{children:"Add"}),". If ",(0,r.jsx)(n.em,{children:"expression"})," is a ",(0,r.jsx)(n.code,{children:"Negate"})," transform it into\na ",(0,r.jsx)(n.code,{children:"Multiply"})," or negate number literals."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"Power"})}),": Transform ",(0,r.jsx)(n.code,{children:"Exp"}),", ",(0,r.jsx)(n.code,{children:"Square"}),", ",(0,r.jsx)(n.code,{children:"Sqrt"}),", ",(0,r.jsx)(n.code,{children:"Root"})," function to a ",(0,r.jsx)(n.code,{children:"Power"}),"\nexpression;"]}),"\n"]}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["CanonicalForm", ["Exp", "x"], "Power"]\n\n```json example\n["CanonicalForm", ["Power", 2, 3], "Power"]\n// -> ["Power", 8]\n'})}),(0,r.jsx)(n.p,{children:"To compare the input from a mathfield with an expected\nanswer, you could use:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",metastring:"example",children:'const correct = ce.parse(mf.value, {canonical: "Order"})\n    .isSame(ce.parse("1+x"))\n'})}),(0,r.jsxs)(n.p,{children:["Both ",(0,r.jsx)(n.code,{children:"1+x"})," and ",(0,r.jsx)(n.code,{children:"x+1"})," will return ",(0,r.jsx)(n.strong,{children:"true"}),", but ",(0,r.jsx)(n.code,{children:"2-1+x"})," will return ",(0,r.jsx)(n.strong,{children:"false"}),"."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": see also the options for the ",(0,r.jsx)(n.code,{children:"canonical"})," option of ",(0,r.jsx)(n.code,{children:"ce.parse()"})," and\n",(0,r.jsx)(n.code,{children:"ce.box()"})," which can also be used to specify a custom canonical form:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",metastring:"example",children:'const correct = ce.parse(mf.value, {canonical: "Order"})\n    .isSame(ce.parse("x+1"))\n'})})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"n",children:"N"})}),"\n",(0,r.jsxs)(s,{name:"N",children:[(0,r.jsx)(d,{name:"N",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsx)(n.p,{children:"Evaluate to a numerical approximation of the expression."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["N", "Pi"]\n\n// \u2794 3.141592653589793\n'})})]}),"\n",(0,r.jsx)(n.h2,{id:"core-functions",children:"Core Functions"}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"error",children:"Error"})}),"\n",(0,r.jsxs)(s,{name:"Error",children:[(0,r.jsxs)(d,{name:"Error",children:[(0,r.jsx)(n.em,{children:"error-code"}),", ",(0,r.jsx)(n.em,{children:"context"})]}),(0,r.jsx)(n.p,{children:"Tag an expression that could not be interpreted correctly. It may have a syntax\nerror, a reference to an unknown symbol or some other problem."}),(0,r.jsxs)(n.p,{children:["The first argument, ",(0,r.jsx)(n.code,{children:"error-code"})," is either a string, or an ",(0,r.jsx)(n.code,{children:'["ErrorCode"]'}),"\nexpression."]}),(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.em,{children:"context"})," is an optional expression that provides additional information\nabout the error."]})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"inversefunction",children:"InverseFunction"})}),"\n",(0,r.jsxs)(s,{name:"InverseFunction",children:[(0,r.jsx)(d,{name:"InverseFunction",children:(0,r.jsx)(n.em,{children:"symbol"})}),(0,r.jsxs)(n.p,{children:["Evaluate to the inverse function of its argument for example ",(0,r.jsx)(n.code,{children:"Arcsin"})," for ",(0,r.jsx)(n.code,{children:"Sin"}),"."]}),(0,r.jsx)(a,{value:"\\sin^{-1}(x)"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'[["InverseFunction", "Sin"], "x"]\n'})}),(0,r.jsx)(n.p,{children:"In the mathematical sense, this is an operator (a function that takes a function\nas an argument and returns a function)."})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"string",children:"String"})}),"\n",(0,r.jsxs)(s,{name:"String",children:[(0,r.jsx)(d,{name:"String",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsx)(n.p,{children:"Evaluate to a string made from the concatenation of the arguments converted to\nstrings"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["String", "x", 2]\n\n// \u2794 "\'x2\'"\n'})})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"symbol",children:"Symbol"})}),"\n",(0,r.jsxs)(s,{name:"Symbol",children:[(0,r.jsx)(d,{name:"Symbol",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsx)(n.p,{children:"Evaluate to a new symbol made of a concatenation of the arguments."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["Symbol", "x", 2]\n\n// \u2794 "x2"\n'})}),(0,r.jsxs)(n.p,{children:["The symbol is not declared, it remains a free variable. To declare the symbol\nuse ",(0,r.jsx)(n.code,{children:"Declare"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["Declare", ["Symbol", "x", 2], "RealNumbers"]\n'})})]}),"\n",(0,r.jsx)(n.h2,{id:"parsing-and-serializing-latex",children:"Parsing and Serializing Latex"}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"parse",children:"Parse"})}),"\n",(0,r.jsxs)(s,{name:"Parse",children:[(0,r.jsx)(d,{name:"Parse",children:(0,r.jsx)(n.em,{children:"string"})}),(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.em,{children:"expr"})," is a ",(0,r.jsx)(n.code,{children:'["LatexString"]'})," expression, evaluate to a MathJSON expression\ncorresponding to the LaTeX string."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",metastring:"example",children:'["Parse", ["LatexString", "\'\\frac{\\pi}{2}\'"]]\n\n// \u2794 ["Divide", "Pi", 2]\n'})})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"latex",children:"Latex"})}),"\n",(0,r.jsxs)(s,{name:"Latex",children:[(0,r.jsx)(d,{name:"Latex",children:(0,r.jsx)(n.em,{children:"expression"})}),(0,r.jsxs)(n.p,{children:["Evaluate to a ",(0,r.jsx)(n.code,{children:"LatexString"})," which is the expression serialized to LaTeX"]})]}),"\n",(0,r.jsx)("nav",{className:"hidden",children:(0,r.jsx)(n.h3,{id:"latexstring",children:"LatexString"})}),"\n",(0,r.jsxs)(s,{name:"LatexString",children:[(0,r.jsx)(d,{name:"LatexString",children:(0,r.jsx)(n.em,{children:"string"})}),(0,r.jsx)(n.p,{children:"Tag a string as a LaTeX string"})]}),"\n",(0,r.jsx)(n.h2,{id:"superscripts-and-subscripts",children:"Superscripts and Subscripts"}),"\n",(0,r.jsx)(n.p,{children:"These functions are all inert functions, that is they evaluate to themselves."}),"\n",(0,r.jsx)("div",{className:"symbols-table first-column-header",children:(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{style:{textAlign:"left"},children:"Function"}),(0,r.jsx)(n.th,{style:{textAlign:"left"}}),(0,r.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"Subminus"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{className:"language-math math-inline",children:"x_-"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"}})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"Subplus"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{className:"language-math math-inline",children:" x_+"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"}})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"Subscript"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{className:"language-math math-inline",children:"x_{n}"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"}})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"Substar"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{className:"language-math math-inline",children:" x_*"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"}})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"Superdagger"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{className:"language-math math-inline",children:" x^\\dagger"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"}})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"Superminus"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{className:"language-math math-inline",children:" x^-"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"}})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"Superplus"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{className:"language-math math-inline",children:" x^+"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"}})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{children:"Superstar"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:(0,r.jsx)(n.code,{className:"language-math math-inline",children:" x^*"})}),(0,r.jsx)(n.td,{style:{textAlign:"left"},children:"When the argument is a complex number, indicate the conjugate."})]})]})]})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}function x(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>t});var i=s(6540);const r={},l=i.createContext(r);function a(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);